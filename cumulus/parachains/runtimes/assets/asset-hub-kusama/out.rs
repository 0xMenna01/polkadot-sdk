#![feature(prelude_import)]
//! # Asset Hub Kusama Runtime
//!
//! Asset Hub Kusama, formerly known as "Statemine", is the canary network for its Polkadot cousin.
#![recursion_limit = "256"]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
pub const WASM_BINARY: Option<&[u8]> = None;
pub const WASM_BINARY_BLOATY: Option<&[u8]> = None;
mod weights {
    pub mod block_weights {
        pub mod constants {
            use frame_support::{parameter_types, weights::{constants, Weight}};
            /// Importing a block with 0 Extrinsics.
            pub struct BlockExecutionWeight;
            impl BlockExecutionWeight {
                /// Returns the value of this parameter type.
                pub const fn get() -> Weight {
                    Weight::from_parts(
                        constants::WEIGHT_REF_TIME_PER_NANOS.saturating_mul(5_000_000),
                        0,
                    )
                }
            }
            impl<_I: From<Weight>> ::frame_support::traits::Get<_I>
            for BlockExecutionWeight {
                fn get() -> _I {
                    _I::from(Self::get())
                }
            }
            impl ::frame_support::traits::TypedGet for BlockExecutionWeight {
                type Type = Weight;
                fn get() -> Weight {
                    Self::get()
                }
            }
        }
    }
    pub mod cumulus_pallet_xcmp_queue {
        //! Autogenerated weights for `cumulus_pallet_xcmp_queue`
        //!
        //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
        //! DATE: 2023-07-31, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
        //! WORST CASE MAP SIZE: `1000000`
        //! HOSTNAME: `runner-ynta1nyy-project-238-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
        //! EXECUTION: ``, WASM-EXECUTION: `Compiled`, CHAIN: `Some("asset-hub-kusama-dev")`, DB CACHE: 1024
        #![allow(unused_parens)]
        #![allow(unused_imports)]
        #![allow(missing_docs)]
        use frame_support::{traits::Get, weights::Weight};
        use core::marker::PhantomData;
        /// Weight functions for `cumulus_pallet_xcmp_queue`.
        pub struct WeightInfo<T>(PhantomData<T>);
        impl<T: frame_system::Config> cumulus_pallet_xcmp_queue::WeightInfo
        for WeightInfo<T> {
            /// Storage: `XcmpQueue::QueueConfig` (r:1 w:1)
            /// Proof: `XcmpQueue::QueueConfig` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            fn set_config_with_u32() -> Weight {
                Weight::from_parts(5_634_000, 0)
                    .saturating_add(Weight::from_parts(0, 1561))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `XcmpQueue::QueueConfig` (r:1 w:1)
            /// Proof: `XcmpQueue::QueueConfig` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            fn set_config_with_weight() -> Weight {
                Weight::from_parts(5_570_000, 0)
                    .saturating_add(Weight::from_parts(0, 1561))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
        }
    }
    pub mod extrinsic_weights {
        pub mod constants {
            use frame_support::{parameter_types, weights::{constants, Weight}};
            /// Executing a NO-OP `System::remarks` Extrinsic.
            pub struct ExtrinsicBaseWeight;
            impl ExtrinsicBaseWeight {
                /// Returns the value of this parameter type.
                pub const fn get() -> Weight {
                    Weight::from_parts(
                        constants::WEIGHT_REF_TIME_PER_NANOS.saturating_mul(125_000),
                        0,
                    )
                }
            }
            impl<_I: From<Weight>> ::frame_support::traits::Get<_I>
            for ExtrinsicBaseWeight {
                fn get() -> _I {
                    _I::from(Self::get())
                }
            }
            impl ::frame_support::traits::TypedGet for ExtrinsicBaseWeight {
                type Type = Weight;
                fn get() -> Weight {
                    Self::get()
                }
            }
        }
    }
    pub mod frame_system {
        //! Autogenerated weights for `frame_system`
        //!
        //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
        //! DATE: 2023-07-31, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
        //! WORST CASE MAP SIZE: `1000000`
        //! HOSTNAME: `runner-ynta1nyy-project-238-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
        //! EXECUTION: ``, WASM-EXECUTION: `Compiled`, CHAIN: `Some("asset-hub-kusama-dev")`, DB CACHE: 1024
        #![allow(unused_parens)]
        #![allow(unused_imports)]
        #![allow(missing_docs)]
        use frame_support::{traits::Get, weights::Weight};
        use core::marker::PhantomData;
        /// Weight functions for `frame_system`.
        pub struct WeightInfo<T>(PhantomData<T>);
        impl<T: frame_system::Config> frame_system::WeightInfo for WeightInfo<T> {
            /// The range of component `b` is `[0, 3932160]`.
            fn remark(b: u32) -> Weight {
                Weight::from_parts(1_884_213, 0)
                    .saturating_add(Weight::from_parts(0, 0))
                    .saturating_add(Weight::from_parts(388, 0).saturating_mul(b.into()))
            }
            /// The range of component `b` is `[0, 3932160]`.
            fn remark_with_event(b: u32) -> Weight {
                Weight::from_parts(27_081_927, 0)
                    .saturating_add(Weight::from_parts(0, 0))
                    .saturating_add(
                        Weight::from_parts(1_730, 0).saturating_mul(b.into()),
                    )
            }
            /// Storage: `System::Digest` (r:1 w:1)
            /// Proof: `System::Digest` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: UNKNOWN KEY `0x3a686561707061676573` (r:0 w:1)
            /// Proof: UNKNOWN KEY `0x3a686561707061676573` (r:0 w:1)
            fn set_heap_pages() -> Weight {
                Weight::from_parts(4_149_000, 0)
                    .saturating_add(Weight::from_parts(0, 1485))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `ParachainSystem::ValidationData` (r:1 w:0)
            /// Proof: `ParachainSystem::ValidationData` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `ParachainSystem::UpgradeRestrictionSignal` (r:1 w:0)
            /// Proof: `ParachainSystem::UpgradeRestrictionSignal` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `ParachainSystem::PendingValidationCode` (r:1 w:1)
            /// Proof: `ParachainSystem::PendingValidationCode` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `ParachainSystem::HostConfiguration` (r:1 w:0)
            /// Proof: `ParachainSystem::HostConfiguration` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `ParachainSystem::NewValidationCode` (r:0 w:1)
            /// Proof: `ParachainSystem::NewValidationCode` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `ParachainSystem::DidSetValidationCode` (r:0 w:1)
            /// Proof: `ParachainSystem::DidSetValidationCode` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            fn set_code() -> Weight {
                Weight::from_parts(106_870_091_000, 0)
                    .saturating_add(Weight::from_parts(0, 1604))
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(T::DbWeight::get().writes(3))
            }
            /// Storage: `Skipped::Metadata` (r:0 w:0)
            /// Proof: `Skipped::Metadata` (`max_values`: None, `max_size`: None, mode: `Measured`)
            /// The range of component `i` is `[0, 1000]`.
            fn set_storage(i: u32) -> Weight {
                Weight::from_parts(2_302_000, 0)
                    .saturating_add(Weight::from_parts(0, 0))
                    .saturating_add(
                        Weight::from_parts(763_456, 0).saturating_mul(i.into()),
                    )
                    .saturating_add(
                        T::DbWeight::get().writes((1_u64).saturating_mul(i.into())),
                    )
            }
            /// Storage: `Skipped::Metadata` (r:0 w:0)
            /// Proof: `Skipped::Metadata` (`max_values`: None, `max_size`: None, mode: `Measured`)
            /// The range of component `i` is `[0, 1000]`.
            fn kill_storage(i: u32) -> Weight {
                Weight::from_parts(2_238_000, 0)
                    .saturating_add(Weight::from_parts(0, 0))
                    .saturating_add(
                        Weight::from_parts(571_397, 0).saturating_mul(i.into()),
                    )
                    .saturating_add(
                        T::DbWeight::get().writes((1_u64).saturating_mul(i.into())),
                    )
            }
            /// Storage: `Skipped::Metadata` (r:0 w:0)
            /// Proof: `Skipped::Metadata` (`max_values`: None, `max_size`: None, mode: `Measured`)
            /// The range of component `p` is `[0, 1000]`.
            fn kill_prefix(p: u32) -> Weight {
                Weight::from_parts(3_947_000, 0)
                    .saturating_add(Weight::from_parts(0, 80))
                    .saturating_add(
                        Weight::from_parts(1_212_360, 0).saturating_mul(p.into()),
                    )
                    .saturating_add(
                        T::DbWeight::get().reads((1_u64).saturating_mul(p.into())),
                    )
                    .saturating_add(
                        T::DbWeight::get().writes((1_u64).saturating_mul(p.into())),
                    )
                    .saturating_add(Weight::from_parts(0, 70).saturating_mul(p.into()))
            }
        }
    }
    pub mod pallet_asset_conversion {
        //! Autogenerated weights for `pallet_asset_conversion`
        //!
        //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
        //! DATE: 2023-07-26, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
        //! WORST CASE MAP SIZE: `1000000`
        //! HOSTNAME: `runner-ynta1nyy-project-238-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
        //! EXECUTION: ``, WASM-EXECUTION: `Compiled`, CHAIN: `Some("asset-hub-kusama-dev")`, DB CACHE: 1024
        #![allow(unused_parens)]
        #![allow(unused_imports)]
        #![allow(missing_docs)]
        use frame_support::{traits::Get, weights::Weight};
        use core::marker::PhantomData;
        /// Weight functions for `pallet_asset_conversion`.
        pub struct WeightInfo<T>(PhantomData<T>);
        impl<T: frame_system::Config> pallet_asset_conversion::WeightInfo
        for WeightInfo<T> {
            /// Storage: `AssetConversion::Pools` (r:1 w:1)
            /// Proof: `AssetConversion::Pools` (`max_values`: None, `max_size`: Some(1224), added: 3699, mode: `MaxEncodedLen`)
            /// Storage: UNKNOWN KEY `0x76a2c49709deec21d9c05f96c1f47351` (r:1 w:0)
            /// Proof: UNKNOWN KEY `0x76a2c49709deec21d9c05f96c1f47351` (r:1 w:0)
            /// Storage: `System::Account` (r:2 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Account` (r:1 w:1)
            /// Proof: `ForeignAssets::Account` (`max_values`: None, `max_size`: Some(732), added: 3207, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `AssetConversion::NextPoolAssetId` (r:1 w:1)
            /// Proof: `AssetConversion::NextPoolAssetId` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Account` (r:1 w:1)
            /// Proof: `PoolAssets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            fn create_pool() -> Weight {
                Weight::from_parts(92_964_000, 0)
                    .saturating_add(Weight::from_parts(0, 6196))
                    .saturating_add(T::DbWeight::get().reads(9))
                    .saturating_add(T::DbWeight::get().writes(7))
            }
            /// Storage: `AssetConversion::Pools` (r:1 w:0)
            /// Proof: `AssetConversion::Pools` (`max_values`: None, `max_size`: Some(1224), added: 3699, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Account` (r:2 w:2)
            /// Proof: `ForeignAssets::Account` (`max_values`: None, `max_size`: Some(732), added: 3207, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Account` (r:2 w:2)
            /// Proof: `PoolAssets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            fn add_liquidity() -> Weight {
                Weight::from_parts(157_018_000, 0)
                    .saturating_add(Weight::from_parts(0, 7404))
                    .saturating_add(T::DbWeight::get().reads(8))
                    .saturating_add(T::DbWeight::get().writes(7))
            }
            /// Storage: `AssetConversion::Pools` (r:1 w:0)
            /// Proof: `AssetConversion::Pools` (`max_values`: None, `max_size`: Some(1224), added: 3699, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Account` (r:2 w:2)
            /// Proof: `ForeignAssets::Account` (`max_values`: None, `max_size`: Some(732), added: 3207, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: UNKNOWN KEY `0x2433d831722b1f4aeb1666953f1c0e77` (r:1 w:0)
            /// Proof: UNKNOWN KEY `0x2433d831722b1f4aeb1666953f1c0e77` (r:1 w:0)
            /// Storage: `PoolAssets::Account` (r:1 w:1)
            /// Proof: `PoolAssets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            fn remove_liquidity() -> Weight {
                Weight::from_parts(147_865_000, 0)
                    .saturating_add(Weight::from_parts(0, 7404))
                    .saturating_add(T::DbWeight::get().reads(8))
                    .saturating_add(T::DbWeight::get().writes(6))
            }
            /// Storage: `ForeignAssets::Asset` (r:2 w:2)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Account` (r:4 w:4)
            /// Proof: `ForeignAssets::Account` (`max_values`: None, `max_size`: Some(732), added: 3207, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:2 w:2)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn swap_exact_tokens_for_tokens() -> Weight {
                Weight::from_parts(174_283_000, 0)
                    .saturating_add(Weight::from_parts(0, 13818))
                    .saturating_add(T::DbWeight::get().reads(8))
                    .saturating_add(T::DbWeight::get().writes(8))
            }
            /// Storage: `System::Account` (r:2 w:2)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Asset` (r:2 w:2)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Account` (r:4 w:4)
            /// Proof: `ForeignAssets::Account` (`max_values`: None, `max_size`: Some(732), added: 3207, mode: `MaxEncodedLen`)
            fn swap_tokens_for_exact_tokens() -> Weight {
                Weight::from_parts(173_702_000, 0)
                    .saturating_add(Weight::from_parts(0, 13818))
                    .saturating_add(T::DbWeight::get().reads(8))
                    .saturating_add(T::DbWeight::get().writes(8))
            }
        }
    }
    pub mod pallet_assets_foreign {
        //! Autogenerated weights for `pallet_assets`
        //!
        //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
        //! DATE: 2023-06-20, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
        //! WORST CASE MAP SIZE: `1000000`
        //! HOSTNAME: `runner-ynta1nyy-project-238-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
        //! EXECUTION: ``, WASM-EXECUTION: `Compiled`, CHAIN: `Some("asset-hub-kusama-dev")`, DB CACHE: 1024
        #![allow(unused_parens)]
        #![allow(unused_imports)]
        #![allow(missing_docs)]
        use frame_support::{traits::Get, weights::Weight};
        use core::marker::PhantomData;
        /// Weight functions for `pallet_assets`.
        pub struct WeightInfo<T>(PhantomData<T>);
        impl<T: frame_system::Config> pallet_assets::WeightInfo for WeightInfo<T> {
            /// Storage: `ParachainInfo::ParachainId` (r:1 w:0)
            /// Proof: `ParachainInfo::ParachainId` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn create() -> Weight {
                Weight::from_parts(31_007_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(3))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            fn force_create() -> Weight {
                Weight::from_parts(13_304_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            fn start_destroy() -> Weight {
                Weight::from_parts(16_063_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: ForeignAssets Asset (r:1 w:1)
            /// Proof: ForeignAssets Asset (max_values: None, max_size: Some(808), added: 3283, mode: MaxEncodedLen)
            /// Storage: ForeignAssets Account (r:1001 w:1000)
            /// Proof: ForeignAssets Account (max_values: None, max_size: Some(732), added: 3207, mode: MaxEncodedLen)
            /// Storage: System Account (r:1000 w:1000)
            /// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: MaxEncodedLen)
            /// The range of component `c` is `[0, 1000]`.
            /// The range of component `c` is `[0, 1000]`.
            fn destroy_accounts(c: u32) -> Weight {
                Weight::from_parts(18_791_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(
                        Weight::from_parts(12_049_659, 0).saturating_mul(c.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(
                        T::DbWeight::get().reads((2_u64).saturating_mul(c.into())),
                    )
                    .saturating_add(T::DbWeight::get().writes(1))
                    .saturating_add(
                        T::DbWeight::get().writes((2_u64).saturating_mul(c.into())),
                    )
                    .saturating_add(Weight::from_parts(0, 3207).saturating_mul(c.into()))
            }
            /// Storage: ForeignAssets Asset (r:1 w:1)
            /// Proof: ForeignAssets Asset (max_values: None, max_size: Some(808), added: 3283, mode: MaxEncodedLen)
            /// Storage: ForeignAssets Approvals (r:1001 w:1000)
            /// Proof: ForeignAssets Approvals (max_values: None, max_size: Some(746), added: 3221, mode: MaxEncodedLen)
            /// The range of component `a` is `[0, 1000]`.
            /// The range of component `a` is `[0, 1000]`.
            fn destroy_approvals(a: u32) -> Weight {
                Weight::from_parts(20_148_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(
                        Weight::from_parts(13_897_319, 0).saturating_mul(a.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(
                        T::DbWeight::get().reads((1_u64).saturating_mul(a.into())),
                    )
                    .saturating_add(T::DbWeight::get().writes(1))
                    .saturating_add(
                        T::DbWeight::get().writes((1_u64).saturating_mul(a.into())),
                    )
                    .saturating_add(Weight::from_parts(0, 3221).saturating_mul(a.into()))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Metadata` (r:1 w:0)
            /// Proof: `ForeignAssets::Metadata` (`max_values`: None, `max_size`: Some(738), added: 3213, mode: `MaxEncodedLen`)
            fn finish_destroy() -> Weight {
                Weight::from_parts(16_241_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Account` (r:1 w:1)
            /// Proof: `ForeignAssets::Account` (`max_values`: None, `max_size`: Some(732), added: 3207, mode: `MaxEncodedLen`)
            fn mint() -> Weight {
                Weight::from_parts(28_182_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Account` (r:1 w:1)
            /// Proof: `ForeignAssets::Account` (`max_values`: None, `max_size`: Some(732), added: 3207, mode: `MaxEncodedLen`)
            fn burn() -> Weight {
                Weight::from_parts(33_860_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Account` (r:2 w:2)
            /// Proof: `ForeignAssets::Account` (`max_values`: None, `max_size`: Some(732), added: 3207, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn transfer() -> Weight {
                Weight::from_parts(45_856_000, 0)
                    .saturating_add(Weight::from_parts(0, 7404))
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(T::DbWeight::get().writes(4))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Account` (r:2 w:2)
            /// Proof: `ForeignAssets::Account` (`max_values`: None, `max_size`: Some(732), added: 3207, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn transfer_keep_alive() -> Weight {
                Weight::from_parts(40_791_000, 0)
                    .saturating_add(Weight::from_parts(0, 7404))
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(T::DbWeight::get().writes(4))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Account` (r:2 w:2)
            /// Proof: `ForeignAssets::Account` (`max_values`: None, `max_size`: Some(732), added: 3207, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn force_transfer() -> Weight {
                Weight::from_parts(45_980_000, 0)
                    .saturating_add(Weight::from_parts(0, 7404))
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(T::DbWeight::get().writes(4))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:0)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Account` (r:1 w:1)
            /// Proof: `ForeignAssets::Account` (`max_values`: None, `max_size`: Some(732), added: 3207, mode: `MaxEncodedLen`)
            fn freeze() -> Weight {
                Weight::from_parts(19_326_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:0)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Account` (r:1 w:1)
            /// Proof: `ForeignAssets::Account` (`max_values`: None, `max_size`: Some(732), added: 3207, mode: `MaxEncodedLen`)
            fn thaw() -> Weight {
                Weight::from_parts(19_205_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            fn freeze_asset() -> Weight {
                Weight::from_parts(15_825_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            fn thaw_asset() -> Weight {
                Weight::from_parts(15_769_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Metadata` (r:1 w:0)
            /// Proof: `ForeignAssets::Metadata` (`max_values`: None, `max_size`: Some(738), added: 3213, mode: `MaxEncodedLen`)
            fn transfer_ownership() -> Weight {
                Weight::from_parts(16_931_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            fn set_team() -> Weight {
                Weight::from_parts(15_435_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: ForeignAssets Asset (r:1 w:0)
            /// Proof: ForeignAssets Asset (max_values: None, max_size: Some(808), added: 3283, mode: MaxEncodedLen)
            /// Storage: ForeignAssets Metadata (r:1 w:1)
            /// Proof: ForeignAssets Metadata (max_values: None, max_size: Some(738), added: 3213, mode: MaxEncodedLen)
            /// The range of component `n` is `[0, 50]`.
            /// The range of component `s` is `[0, 50]`.
            /// The range of component `n` is `[0, 50]`.
            /// The range of component `s` is `[0, 50]`.
            fn set_metadata(_n: u32, _s: u32) -> Weight {
                Weight::from_parts(31_607_649, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:0)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Metadata` (r:1 w:1)
            /// Proof: `ForeignAssets::Metadata` (`max_values`: None, `max_size`: Some(738), added: 3213, mode: `MaxEncodedLen`)
            fn clear_metadata() -> Weight {
                Weight::from_parts(31_008_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: ForeignAssets Asset (r:1 w:0)
            /// Proof: ForeignAssets Asset (max_values: None, max_size: Some(808), added: 3283, mode: MaxEncodedLen)
            /// Storage: ForeignAssets Metadata (r:1 w:1)
            /// Proof: ForeignAssets Metadata (max_values: None, max_size: Some(738), added: 3213, mode: MaxEncodedLen)
            /// The range of component `n` is `[0, 50]`.
            /// The range of component `s` is `[0, 50]`.
            /// The range of component `n` is `[0, 50]`.
            /// The range of component `s` is `[0, 50]`.
            fn force_set_metadata(_n: u32, s: u32) -> Weight {
                Weight::from_parts(14_717_332, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(
                        Weight::from_parts(2_595, 0).saturating_mul(s.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:0)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Metadata` (r:1 w:1)
            /// Proof: `ForeignAssets::Metadata` (`max_values`: None, `max_size`: Some(738), added: 3213, mode: `MaxEncodedLen`)
            fn force_clear_metadata() -> Weight {
                Weight::from_parts(29_918_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            fn force_asset_status() -> Weight {
                Weight::from_parts(14_138_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Approvals` (r:1 w:1)
            /// Proof: `ForeignAssets::Approvals` (`max_values`: None, `max_size`: Some(746), added: 3221, mode: `MaxEncodedLen`)
            fn approve_transfer() -> Weight {
                Weight::from_parts(33_524_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Approvals` (r:1 w:1)
            /// Proof: `ForeignAssets::Approvals` (`max_values`: None, `max_size`: Some(746), added: 3221, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Account` (r:2 w:2)
            /// Proof: `ForeignAssets::Account` (`max_values`: None, `max_size`: Some(732), added: 3207, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn transfer_approved() -> Weight {
                Weight::from_parts(64_078_000, 0)
                    .saturating_add(Weight::from_parts(0, 7404))
                    .saturating_add(T::DbWeight::get().reads(5))
                    .saturating_add(T::DbWeight::get().writes(5))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Approvals` (r:1 w:1)
            /// Proof: `ForeignAssets::Approvals` (`max_values`: None, `max_size`: Some(746), added: 3221, mode: `MaxEncodedLen`)
            fn cancel_approval() -> Weight {
                Weight::from_parts(35_484_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Approvals` (r:1 w:1)
            /// Proof: `ForeignAssets::Approvals` (`max_values`: None, `max_size`: Some(746), added: 3221, mode: `MaxEncodedLen`)
            fn force_cancel_approval() -> Weight {
                Weight::from_parts(36_266_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            fn set_min_balance() -> Weight {
                Weight::from_parts(16_182_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `ForeignAssets::Account` (r:1 w:1)
            /// Proof: `ForeignAssets::Account` (`max_values`: None, `max_size`: Some(732), added: 3207, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn touch() -> Weight {
                Weight::from_parts(35_512_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(3))
                    .saturating_add(T::DbWeight::get().writes(3))
            }
            /// Storage: `ForeignAssets::Account` (r:1 w:1)
            /// Proof: `ForeignAssets::Account` (`max_values`: None, `max_size`: Some(732), added: 3207, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            fn touch_other() -> Weight {
                Weight::from_parts(34_124_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `ForeignAssets::Account` (r:1 w:1)
            /// Proof: `ForeignAssets::Account` (`max_values`: None, `max_size`: Some(732), added: 3207, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn refund() -> Weight {
                Weight::from_parts(32_012_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(3))
                    .saturating_add(T::DbWeight::get().writes(3))
            }
            /// Storage: `ForeignAssets::Account` (r:1 w:1)
            /// Proof: `ForeignAssets::Account` (`max_values`: None, `max_size`: Some(732), added: 3207, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Asset` (r:1 w:1)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            fn refund_other() -> Weight {
                Weight::from_parts(29_968_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `ForeignAssets::Asset` (r:1 w:0)
            /// Proof: `ForeignAssets::Asset` (`max_values`: None, `max_size`: Some(808), added: 3283, mode: `MaxEncodedLen`)
            /// Storage: `ForeignAssets::Account` (r:1 w:1)
            /// Proof: `ForeignAssets::Account` (`max_values`: None, `max_size`: Some(732), added: 3207, mode: `MaxEncodedLen`)
            fn block() -> Weight {
                Weight::from_parts(19_172_000, 0)
                    .saturating_add(Weight::from_parts(0, 4273))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
        }
    }
    pub mod pallet_assets_local {
        //! Autogenerated weights for `pallet_assets`
        //!
        //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
        //! DATE: 2023-07-31, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
        //! WORST CASE MAP SIZE: `1000000`
        //! HOSTNAME: `runner-ynta1nyy-project-238-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
        //! EXECUTION: ``, WASM-EXECUTION: `Compiled`, CHAIN: `Some("asset-hub-kusama-dev")`, DB CACHE: 1024
        #![allow(unused_parens)]
        #![allow(unused_imports)]
        #![allow(missing_docs)]
        use frame_support::{traits::Get, weights::Weight};
        use core::marker::PhantomData;
        /// Weight functions for `pallet_assets`.
        pub struct WeightInfo<T>(PhantomData<T>);
        impl<T: frame_system::Config> pallet_assets::WeightInfo for WeightInfo<T> {
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn create() -> Weight {
                Weight::from_parts(27_332_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn force_create() -> Weight {
                Weight::from_parts(11_395_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn start_destroy() -> Weight {
                Weight::from_parts(14_108_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Account` (r:1001 w:1000)
            /// Proof: `Assets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1000 w:1000)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            /// The range of component `c` is `[0, 1000]`.
            /// The range of component `c` is `[0, 1000]`.
            fn destroy_accounts(c: u32) -> Weight {
                Weight::from_parts(16_636_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(
                        Weight::from_parts(15_306_152, 0).saturating_mul(c.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(
                        T::DbWeight::get().reads((2_u64).saturating_mul(c.into())),
                    )
                    .saturating_add(T::DbWeight::get().writes(1))
                    .saturating_add(
                        T::DbWeight::get().writes((2_u64).saturating_mul(c.into())),
                    )
                    .saturating_add(Weight::from_parts(0, 2609).saturating_mul(c.into()))
            }
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Approvals` (r:1001 w:1000)
            /// Proof: `Assets::Approvals` (`max_values`: None, `max_size`: Some(148), added: 2623, mode: `MaxEncodedLen`)
            /// The range of component `a` is `[0, 1000]`.
            /// The range of component `a` is `[0, 1000]`.
            fn destroy_approvals(a: u32) -> Weight {
                Weight::from_parts(17_247_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(
                        Weight::from_parts(15_634_963, 0).saturating_mul(a.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(
                        T::DbWeight::get().reads((1_u64).saturating_mul(a.into())),
                    )
                    .saturating_add(T::DbWeight::get().writes(1))
                    .saturating_add(Weight::from_parts(0, 2623).saturating_mul(a.into()))
            }
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Metadata` (r:1 w:0)
            /// Proof: `Assets::Metadata` (`max_values`: None, `max_size`: Some(140), added: 2615, mode: `MaxEncodedLen`)
            fn finish_destroy() -> Weight {
                Weight::from_parts(14_721_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Account` (r:1 w:1)
            /// Proof: `Assets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            fn mint() -> Weight {
                Weight::from_parts(25_023_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Account` (r:1 w:1)
            /// Proof: `Assets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            fn burn() -> Weight {
                Weight::from_parts(32_235_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Account` (r:2 w:2)
            /// Proof: `Assets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn transfer() -> Weight {
                Weight::from_parts(44_106_000, 0)
                    .saturating_add(Weight::from_parts(0, 6208))
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(T::DbWeight::get().writes(4))
            }
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Account` (r:2 w:2)
            /// Proof: `Assets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn transfer_keep_alive() -> Weight {
                Weight::from_parts(38_772_000, 0)
                    .saturating_add(Weight::from_parts(0, 6208))
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(T::DbWeight::get().writes(4))
            }
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Account` (r:2 w:2)
            /// Proof: `Assets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn force_transfer() -> Weight {
                Weight::from_parts(44_003_000, 0)
                    .saturating_add(Weight::from_parts(0, 6208))
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(T::DbWeight::get().writes(4))
            }
            /// Storage: `Assets::Asset` (r:1 w:0)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Account` (r:1 w:1)
            /// Proof: `Assets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            fn freeze() -> Weight {
                Weight::from_parts(17_614_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Assets::Asset` (r:1 w:0)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Account` (r:1 w:1)
            /// Proof: `Assets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            fn thaw() -> Weight {
                Weight::from_parts(17_581_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn freeze_asset() -> Weight {
                Weight::from_parts(13_735_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn thaw_asset() -> Weight {
                Weight::from_parts(13_417_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Metadata` (r:1 w:0)
            /// Proof: `Assets::Metadata` (`max_values`: None, `max_size`: Some(140), added: 2615, mode: `MaxEncodedLen`)
            fn transfer_ownership() -> Weight {
                Weight::from_parts(14_660_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn set_team() -> Weight {
                Weight::from_parts(13_172_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Assets::Asset` (r:1 w:0)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Metadata` (r:1 w:1)
            /// Proof: `Assets::Metadata` (`max_values`: None, `max_size`: Some(140), added: 2615, mode: `MaxEncodedLen`)
            /// The range of component `n` is `[0, 50]`.
            /// The range of component `s` is `[0, 50]`.
            /// The range of component `n` is `[0, 50]`.
            /// The range of component `s` is `[0, 50]`.
            fn set_metadata(n: u32, s: u32) -> Weight {
                Weight::from_parts(29_036_880, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(
                        Weight::from_parts(2_426, 0).saturating_mul(n.into()),
                    )
                    .saturating_add(Weight::from_parts(776, 0).saturating_mul(s.into()))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Assets::Asset` (r:1 w:0)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Metadata` (r:1 w:1)
            /// Proof: `Assets::Metadata` (`max_values`: None, `max_size`: Some(140), added: 2615, mode: `MaxEncodedLen`)
            fn clear_metadata() -> Weight {
                Weight::from_parts(29_216_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Assets::Asset` (r:1 w:0)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Metadata` (r:1 w:1)
            /// Proof: `Assets::Metadata` (`max_values`: None, `max_size`: Some(140), added: 2615, mode: `MaxEncodedLen`)
            /// The range of component `n` is `[0, 50]`.
            /// The range of component `s` is `[0, 50]`.
            /// The range of component `n` is `[0, 50]`.
            /// The range of component `s` is `[0, 50]`.
            fn force_set_metadata(n: u32, s: u32) -> Weight {
                Weight::from_parts(13_095_356, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(Weight::from_parts(826, 0).saturating_mul(n.into()))
                    .saturating_add(Weight::from_parts(808, 0).saturating_mul(s.into()))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Assets::Asset` (r:1 w:0)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Metadata` (r:1 w:1)
            /// Proof: `Assets::Metadata` (`max_values`: None, `max_size`: Some(140), added: 2615, mode: `MaxEncodedLen`)
            fn force_clear_metadata() -> Weight {
                Weight::from_parts(29_050_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn force_asset_status() -> Weight {
                Weight::from_parts(12_545_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Approvals` (r:1 w:1)
            /// Proof: `Assets::Approvals` (`max_values`: None, `max_size`: Some(148), added: 2623, mode: `MaxEncodedLen`)
            fn approve_transfer() -> Weight {
                Weight::from_parts(32_052_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Approvals` (r:1 w:1)
            /// Proof: `Assets::Approvals` (`max_values`: None, `max_size`: Some(148), added: 2623, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Account` (r:2 w:2)
            /// Proof: `Assets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn transfer_approved() -> Weight {
                Weight::from_parts(62_740_000, 0)
                    .saturating_add(Weight::from_parts(0, 6208))
                    .saturating_add(T::DbWeight::get().reads(5))
                    .saturating_add(T::DbWeight::get().writes(5))
            }
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Approvals` (r:1 w:1)
            /// Proof: `Assets::Approvals` (`max_values`: None, `max_size`: Some(148), added: 2623, mode: `MaxEncodedLen`)
            fn cancel_approval() -> Weight {
                Weight::from_parts(34_127_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Approvals` (r:1 w:1)
            /// Proof: `Assets::Approvals` (`max_values`: None, `max_size`: Some(148), added: 2623, mode: `MaxEncodedLen`)
            fn force_cancel_approval() -> Weight {
                Weight::from_parts(34_613_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn set_min_balance() -> Weight {
                Weight::from_parts(13_997_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Assets::Account` (r:1 w:1)
            /// Proof: `Assets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn touch() -> Weight {
                Weight::from_parts(33_675_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(3))
                    .saturating_add(T::DbWeight::get().writes(3))
            }
            /// Storage: `Assets::Account` (r:1 w:1)
            /// Proof: `Assets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn touch_other() -> Weight {
                Weight::from_parts(31_710_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Assets::Account` (r:1 w:1)
            /// Proof: `Assets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn refund() -> Weight {
                Weight::from_parts(30_793_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(3))
                    .saturating_add(T::DbWeight::get().writes(3))
            }
            /// Storage: `Assets::Account` (r:1 w:1)
            /// Proof: `Assets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn refund_other() -> Weight {
                Weight::from_parts(29_097_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Assets::Asset` (r:1 w:0)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Account` (r:1 w:1)
            /// Proof: `Assets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            fn block() -> Weight {
                Weight::from_parts(17_433_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
        }
    }
    pub mod pallet_assets_pool {
        //! Autogenerated weights for `pallet_assets`
        //!
        //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
        //! DATE: 2023-07-27, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
        //! WORST CASE MAP SIZE: `1000000`
        //! HOSTNAME: `runner-ynta1nyy-project-238-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
        //! EXECUTION: ``, WASM-EXECUTION: `Compiled`, CHAIN: `Some("asset-hub-kusama-dev")`, DB CACHE: 1024
        #![allow(unused_parens)]
        #![allow(unused_imports)]
        #![allow(missing_docs)]
        use frame_support::{traits::Get, weights::Weight};
        use core::marker::PhantomData;
        /// Weight functions for `pallet_assets`.
        pub struct WeightInfo<T>(PhantomData<T>);
        impl<T: frame_system::Config> pallet_assets::WeightInfo for WeightInfo<T> {
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn create() -> Weight {
                Weight::from_parts(11_901_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn force_create() -> Weight {
                Weight::from_parts(11_640_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn start_destroy() -> Weight {
                Weight::from_parts(14_226_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Account` (r:1001 w:1000)
            /// Proof: `PoolAssets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1000 w:1000)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            /// The range of component `c` is `[0, 1000]`.
            /// The range of component `c` is `[0, 1000]`.
            /// The range of component `c` is `[0, 1000]`.
            fn destroy_accounts(c: u32) -> Weight {
                Weight::from_parts(16_743_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(
                        Weight::from_parts(14_463_991, 0).saturating_mul(c.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(
                        T::DbWeight::get().reads((2_u64).saturating_mul(c.into())),
                    )
                    .saturating_add(T::DbWeight::get().writes(1))
                    .saturating_add(
                        T::DbWeight::get().writes((2_u64).saturating_mul(c.into())),
                    )
                    .saturating_add(Weight::from_parts(0, 2609).saturating_mul(c.into()))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Approvals` (r:1001 w:1000)
            /// Proof: `PoolAssets::Approvals` (`max_values`: None, `max_size`: Some(148), added: 2623, mode: `MaxEncodedLen`)
            /// The range of component `a` is `[0, 1000]`.
            /// The range of component `a` is `[0, 1000]`.
            /// The range of component `a` is `[0, 1000]`.
            fn destroy_approvals(a: u32) -> Weight {
                Weight::from_parts(17_585_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(
                        Weight::from_parts(5_323_866, 0).saturating_mul(a.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(
                        T::DbWeight::get().reads((1_u64).saturating_mul(a.into())),
                    )
                    .saturating_add(T::DbWeight::get().writes(1))
                    .saturating_add(
                        T::DbWeight::get().writes((1_u64).saturating_mul(a.into())),
                    )
                    .saturating_add(Weight::from_parts(0, 2623).saturating_mul(a.into()))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Metadata` (r:1 w:0)
            /// Proof: `PoolAssets::Metadata` (`max_values`: None, `max_size`: Some(140), added: 2615, mode: `MaxEncodedLen`)
            fn finish_destroy() -> Weight {
                Weight::from_parts(14_325_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Account` (r:1 w:1)
            /// Proof: `PoolAssets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            fn mint() -> Weight {
                Weight::from_parts(25_607_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Account` (r:1 w:1)
            /// Proof: `PoolAssets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            fn burn() -> Weight {
                Weight::from_parts(32_338_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Account` (r:2 w:2)
            /// Proof: `PoolAssets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn transfer() -> Weight {
                Weight::from_parts(44_041_000, 0)
                    .saturating_add(Weight::from_parts(0, 6208))
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(T::DbWeight::get().writes(4))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Account` (r:2 w:2)
            /// Proof: `PoolAssets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn transfer_keep_alive() -> Weight {
                Weight::from_parts(38_648_000, 0)
                    .saturating_add(Weight::from_parts(0, 6208))
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(T::DbWeight::get().writes(4))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Account` (r:2 w:2)
            /// Proof: `PoolAssets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn force_transfer() -> Weight {
                Weight::from_parts(44_029_000, 0)
                    .saturating_add(Weight::from_parts(0, 6208))
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(T::DbWeight::get().writes(4))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:0)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Account` (r:1 w:1)
            /// Proof: `PoolAssets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            fn freeze() -> Weight {
                Weight::from_parts(17_782_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:0)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Account` (r:1 w:1)
            /// Proof: `PoolAssets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            fn thaw() -> Weight {
                Weight::from_parts(17_698_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn freeze_asset() -> Weight {
                Weight::from_parts(13_810_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn thaw_asset() -> Weight {
                Weight::from_parts(13_603_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Metadata` (r:1 w:0)
            /// Proof: `PoolAssets::Metadata` (`max_values`: None, `max_size`: Some(140), added: 2615, mode: `MaxEncodedLen`)
            fn transfer_ownership() -> Weight {
                Weight::from_parts(14_774_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn set_team() -> Weight {
                Weight::from_parts(13_616_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:0)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Metadata` (r:1 w:1)
            /// Proof: `PoolAssets::Metadata` (`max_values`: None, `max_size`: Some(140), added: 2615, mode: `MaxEncodedLen`)
            /// The range of component `n` is `[0, 50]`.
            /// The range of component `s` is `[0, 50]`.
            /// The range of component `n` is `[0, 50]`.
            /// The range of component `s` is `[0, 50]`.
            /// The range of component `n` is `[0, 50]`.
            /// The range of component `s` is `[0, 50]`.
            fn set_metadata(n: u32, s: u32) -> Weight {
                Weight::from_parts(16_096_881, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(
                        Weight::from_parts(1_631, 0).saturating_mul(n.into()),
                    )
                    .saturating_add(
                        Weight::from_parts(2_334, 0).saturating_mul(s.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:0)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Metadata` (r:1 w:1)
            /// Proof: `PoolAssets::Metadata` (`max_values`: None, `max_size`: Some(140), added: 2615, mode: `MaxEncodedLen`)
            fn clear_metadata() -> Weight {
                Weight::from_parts(16_526_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:0)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Metadata` (r:1 w:1)
            /// Proof: `PoolAssets::Metadata` (`max_values`: None, `max_size`: Some(140), added: 2615, mode: `MaxEncodedLen`)
            /// The range of component `n` is `[0, 50]`.
            /// The range of component `s` is `[0, 50]`.
            /// The range of component `n` is `[0, 50]`.
            /// The range of component `s` is `[0, 50]`.
            /// The range of component `n` is `[0, 50]`.
            /// The range of component `s` is `[0, 50]`.
            fn force_set_metadata(n: u32, s: u32) -> Weight {
                Weight::from_parts(14_047_176, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(
                        Weight::from_parts(2_617, 0).saturating_mul(n.into()),
                    )
                    .saturating_add(
                        Weight::from_parts(2_081, 0).saturating_mul(s.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:0)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Metadata` (r:1 w:1)
            /// Proof: `PoolAssets::Metadata` (`max_values`: None, `max_size`: Some(140), added: 2615, mode: `MaxEncodedLen`)
            fn force_clear_metadata() -> Weight {
                Weight::from_parts(16_279_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn force_asset_status() -> Weight {
                Weight::from_parts(13_080_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Approvals` (r:1 w:1)
            /// Proof: `PoolAssets::Approvals` (`max_values`: None, `max_size`: Some(148), added: 2623, mode: `MaxEncodedLen`)
            fn approve_transfer() -> Weight {
                Weight::from_parts(19_812_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Approvals` (r:1 w:1)
            /// Proof: `PoolAssets::Approvals` (`max_values`: None, `max_size`: Some(148), added: 2623, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Account` (r:2 w:2)
            /// Proof: `PoolAssets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn transfer_approved() -> Weight {
                Weight::from_parts(51_441_000, 0)
                    .saturating_add(Weight::from_parts(0, 6208))
                    .saturating_add(T::DbWeight::get().reads(5))
                    .saturating_add(T::DbWeight::get().writes(5))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Approvals` (r:1 w:1)
            /// Proof: `PoolAssets::Approvals` (`max_values`: None, `max_size`: Some(148), added: 2623, mode: `MaxEncodedLen`)
            fn cancel_approval() -> Weight {
                Weight::from_parts(21_946_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Approvals` (r:1 w:1)
            /// Proof: `PoolAssets::Approvals` (`max_values`: None, `max_size`: Some(148), added: 2623, mode: `MaxEncodedLen`)
            fn force_cancel_approval() -> Weight {
                Weight::from_parts(22_366_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn set_min_balance() -> Weight {
                Weight::from_parts(14_086_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `PoolAssets::Account` (r:1 w:1)
            /// Proof: `PoolAssets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn touch() -> Weight {
                Weight::from_parts(19_000_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `PoolAssets::Account` (r:1 w:1)
            /// Proof: `PoolAssets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn touch_other() -> Weight {
                Weight::from_parts(19_040_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `PoolAssets::Account` (r:1 w:1)
            /// Proof: `PoolAssets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn refund() -> Weight {
                Weight::from_parts(15_296_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `PoolAssets::Account` (r:1 w:1)
            /// Proof: `PoolAssets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Asset` (r:1 w:1)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            fn refund_other() -> Weight {
                Weight::from_parts(15_312_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `PoolAssets::Asset` (r:1 w:0)
            /// Proof: `PoolAssets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `PoolAssets::Account` (r:1 w:1)
            /// Proof: `PoolAssets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            fn block() -> Weight {
                Weight::from_parts(17_653_000, 0)
                    .saturating_add(Weight::from_parts(0, 3675))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
        }
    }
    pub mod pallet_balances {
        //! Autogenerated weights for `pallet_balances`
        //!
        //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
        //! DATE: 2023-07-31, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
        //! WORST CASE MAP SIZE: `1000000`
        //! HOSTNAME: `runner-ynta1nyy-project-238-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
        //! EXECUTION: ``, WASM-EXECUTION: `Compiled`, CHAIN: `Some("asset-hub-kusama-dev")`, DB CACHE: 1024
        #![allow(unused_parens)]
        #![allow(unused_imports)]
        #![allow(missing_docs)]
        use frame_support::{traits::Get, weights::Weight};
        use core::marker::PhantomData;
        /// Weight functions for `pallet_balances`.
        pub struct WeightInfo<T>(PhantomData<T>);
        impl<T: frame_system::Config> pallet_balances::WeightInfo for WeightInfo<T> {
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn transfer_allow_death() -> Weight {
                Weight::from_parts(56_106_000, 0)
                    .saturating_add(Weight::from_parts(0, 3593))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn transfer_keep_alive() -> Weight {
                Weight::from_parts(41_890_000, 0)
                    .saturating_add(Weight::from_parts(0, 3593))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn force_set_balance_creating() -> Weight {
                Weight::from_parts(15_182_000, 0)
                    .saturating_add(Weight::from_parts(0, 3593))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn force_set_balance_killing() -> Weight {
                Weight::from_parts(22_638_000, 0)
                    .saturating_add(Weight::from_parts(0, 3593))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `System::Account` (r:2 w:2)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn force_transfer() -> Weight {
                Weight::from_parts(58_222_000, 0)
                    .saturating_add(Weight::from_parts(0, 6196))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn transfer_all() -> Weight {
                Weight::from_parts(52_003_000, 0)
                    .saturating_add(Weight::from_parts(0, 3593))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            fn force_unreserve() -> Weight {
                Weight::from_parts(17_849_000, 0)
                    .saturating_add(Weight::from_parts(0, 3593))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `System::Account` (r:999 w:999)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            /// The range of component `u` is `[1, 1000]`.
            fn upgrade_accounts(u: u32) -> Weight {
                Weight::from_parts(17_478_000, 0)
                    .saturating_add(Weight::from_parts(0, 990))
                    .saturating_add(
                        Weight::from_parts(15_291_954, 0).saturating_mul(u.into()),
                    )
                    .saturating_add(
                        T::DbWeight::get().reads((1_u64).saturating_mul(u.into())),
                    )
                    .saturating_add(
                        T::DbWeight::get().writes((1_u64).saturating_mul(u.into())),
                    )
                    .saturating_add(Weight::from_parts(0, 2603).saturating_mul(u.into()))
            }
        }
    }
    pub mod pallet_collator_selection {
        //! Autogenerated weights for `pallet_collator_selection`
        //!
        //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
        //! DATE: 2023-07-31, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
        //! WORST CASE MAP SIZE: `1000000`
        //! HOSTNAME: `runner-ynta1nyy-project-238-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
        //! EXECUTION: ``, WASM-EXECUTION: `Compiled`, CHAIN: `Some("asset-hub-kusama-dev")`, DB CACHE: 1024
        #![allow(unused_parens)]
        #![allow(unused_imports)]
        #![allow(missing_docs)]
        use frame_support::{traits::Get, weights::Weight};
        use core::marker::PhantomData;
        /// Weight functions for `pallet_collator_selection`.
        pub struct WeightInfo<T>(PhantomData<T>);
        impl<T: frame_system::Config> pallet_collator_selection::WeightInfo
        for WeightInfo<T> {
            /// Storage: `Session::NextKeys` (r:20 w:0)
            /// Proof: `Session::NextKeys` (`max_values`: None, `max_size`: None, mode: `Measured`)
            /// Storage: `CollatorSelection::Invulnerables` (r:0 w:1)
            /// Proof: `CollatorSelection::Invulnerables` (`max_values`: Some(1), `max_size`: Some(641), added: 1136, mode: `MaxEncodedLen`)
            /// The range of component `b` is `[1, 20]`.
            fn set_invulnerables(b: u32) -> Weight {
                Weight::from_parts(13_068_592, 0)
                    .saturating_add(Weight::from_parts(0, 1154))
                    .saturating_add(
                        Weight::from_parts(3_219_916, 0).saturating_mul(b.into()),
                    )
                    .saturating_add(
                        T::DbWeight::get().reads((1_u64).saturating_mul(b.into())),
                    )
                    .saturating_add(T::DbWeight::get().writes(1))
                    .saturating_add(Weight::from_parts(0, 2555).saturating_mul(b.into()))
            }
            /// Storage: `Session::NextKeys` (r:1 w:0)
            /// Proof: `Session::NextKeys` (`max_values`: None, `max_size`: None, mode: `Measured`)
            /// Storage: `CollatorSelection::Invulnerables` (r:1 w:1)
            /// Proof: `CollatorSelection::Invulnerables` (`max_values`: Some(1), `max_size`: Some(641), added: 1136, mode: `MaxEncodedLen`)
            /// Storage: `CollatorSelection::Candidates` (r:1 w:1)
            /// Proof: `CollatorSelection::Candidates` (`max_values`: Some(1), `max_size`: Some(4802), added: 5297, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            /// The range of component `b` is `[1, 19]`.
            /// The range of component `c` is `[1, 99]`.
            fn add_invulnerable(b: u32, c: u32) -> Weight {
                Weight::from_parts(51_768_986, 0)
                    .saturating_add(Weight::from_parts(0, 6287))
                    .saturating_add(
                        Weight::from_parts(55_676, 0).saturating_mul(b.into()),
                    )
                    .saturating_add(
                        Weight::from_parts(184_343, 0).saturating_mul(c.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(T::DbWeight::get().writes(3))
                    .saturating_add(Weight::from_parts(0, 37).saturating_mul(b.into()))
                    .saturating_add(Weight::from_parts(0, 53).saturating_mul(c.into()))
            }
            /// Storage: `CollatorSelection::Candidates` (r:1 w:0)
            /// Proof: `CollatorSelection::Candidates` (`max_values`: Some(1), `max_size`: Some(4802), added: 5297, mode: `MaxEncodedLen`)
            /// Storage: `CollatorSelection::Invulnerables` (r:1 w:1)
            /// Proof: `CollatorSelection::Invulnerables` (`max_values`: Some(1), `max_size`: Some(641), added: 1136, mode: `MaxEncodedLen`)
            /// The range of component `b` is `[5, 20]`.
            fn remove_invulnerable(b: u32) -> Weight {
                Weight::from_parts(16_646_017, 0)
                    .saturating_add(Weight::from_parts(0, 6287))
                    .saturating_add(
                        Weight::from_parts(148_941, 0).saturating_mul(b.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `CollatorSelection::DesiredCandidates` (r:0 w:1)
            /// Proof: `CollatorSelection::DesiredCandidates` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
            fn set_desired_candidates() -> Weight {
                Weight::from_parts(8_002_000, 0)
                    .saturating_add(Weight::from_parts(0, 0))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `CollatorSelection::CandidacyBond` (r:0 w:1)
            /// Proof: `CollatorSelection::CandidacyBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
            fn set_candidacy_bond() -> Weight {
                Weight::from_parts(8_161_000, 0)
                    .saturating_add(Weight::from_parts(0, 0))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `CollatorSelection::Candidates` (r:1 w:1)
            /// Proof: `CollatorSelection::Candidates` (`max_values`: Some(1), `max_size`: Some(4802), added: 5297, mode: `MaxEncodedLen`)
            /// Storage: `CollatorSelection::DesiredCandidates` (r:1 w:0)
            /// Proof: `CollatorSelection::DesiredCandidates` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
            /// Storage: `CollatorSelection::Invulnerables` (r:1 w:0)
            /// Proof: `CollatorSelection::Invulnerables` (`max_values`: Some(1), `max_size`: Some(641), added: 1136, mode: `MaxEncodedLen`)
            /// Storage: `Session::NextKeys` (r:1 w:0)
            /// Proof: `Session::NextKeys` (`max_values`: None, `max_size`: None, mode: `Measured`)
            /// Storage: `CollatorSelection::CandidacyBond` (r:1 w:0)
            /// Proof: `CollatorSelection::CandidacyBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
            /// Storage: `CollatorSelection::LastAuthoredBlock` (r:0 w:1)
            /// Proof: `CollatorSelection::LastAuthoredBlock` (`max_values`: None, `max_size`: Some(44), added: 2519, mode: `MaxEncodedLen`)
            /// The range of component `c` is `[1, 99]`.
            fn register_as_candidate(c: u32) -> Weight {
                Weight::from_parts(45_979_502, 0)
                    .saturating_add(Weight::from_parts(0, 6287))
                    .saturating_add(
                        Weight::from_parts(221_049, 0).saturating_mul(c.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(5))
                    .saturating_add(T::DbWeight::get().writes(2))
                    .saturating_add(Weight::from_parts(0, 54).saturating_mul(c.into()))
            }
            /// Storage: `CollatorSelection::Candidates` (r:1 w:1)
            /// Proof: `CollatorSelection::Candidates` (`max_values`: Some(1), `max_size`: Some(4802), added: 5297, mode: `MaxEncodedLen`)
            /// Storage: `CollatorSelection::Invulnerables` (r:1 w:0)
            /// Proof: `CollatorSelection::Invulnerables` (`max_values`: Some(1), `max_size`: Some(641), added: 1136, mode: `MaxEncodedLen`)
            /// Storage: `CollatorSelection::LastAuthoredBlock` (r:0 w:1)
            /// Proof: `CollatorSelection::LastAuthoredBlock` (`max_values`: None, `max_size`: Some(44), added: 2519, mode: `MaxEncodedLen`)
            /// The range of component `c` is `[4, 100]`.
            fn leave_intent(c: u32) -> Weight {
                Weight::from_parts(36_371_520, 0)
                    .saturating_add(Weight::from_parts(0, 6287))
                    .saturating_add(
                        Weight::from_parts(201_700, 0).saturating_mul(c.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `System::Account` (r:2 w:2)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            /// Storage: `System::BlockWeight` (r:1 w:1)
            /// Proof: `System::BlockWeight` (`max_values`: Some(1), `max_size`: Some(48), added: 543, mode: `MaxEncodedLen`)
            /// Storage: `CollatorSelection::LastAuthoredBlock` (r:0 w:1)
            /// Proof: `CollatorSelection::LastAuthoredBlock` (`max_values`: None, `max_size`: Some(44), added: 2519, mode: `MaxEncodedLen`)
            fn note_author() -> Weight {
                Weight::from_parts(48_151_000, 0)
                    .saturating_add(Weight::from_parts(0, 6196))
                    .saturating_add(T::DbWeight::get().reads(3))
                    .saturating_add(T::DbWeight::get().writes(4))
            }
            /// Storage: `CollatorSelection::Candidates` (r:1 w:0)
            /// Proof: `CollatorSelection::Candidates` (`max_values`: Some(1), `max_size`: Some(4802), added: 5297, mode: `MaxEncodedLen`)
            /// Storage: `CollatorSelection::LastAuthoredBlock` (r:100 w:0)
            /// Proof: `CollatorSelection::LastAuthoredBlock` (`max_values`: None, `max_size`: Some(44), added: 2519, mode: `MaxEncodedLen`)
            /// Storage: `CollatorSelection::Invulnerables` (r:1 w:0)
            /// Proof: `CollatorSelection::Invulnerables` (`max_values`: Some(1), `max_size`: Some(641), added: 1136, mode: `MaxEncodedLen`)
            /// Storage: `System::BlockWeight` (r:1 w:1)
            /// Proof: `System::BlockWeight` (`max_values`: Some(1), `max_size`: Some(48), added: 543, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:97 w:97)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            /// The range of component `r` is `[1, 100]`.
            /// The range of component `c` is `[1, 100]`.
            fn new_session(r: u32, c: u32) -> Weight {
                Weight::from_parts(17_854_000, 0)
                    .saturating_add(Weight::from_parts(0, 6287))
                    .saturating_add(
                        Weight::from_parts(15_798_857, 0).saturating_mul(c.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(
                        T::DbWeight::get().reads((1_u64).saturating_mul(c.into())),
                    )
                    .saturating_add(T::DbWeight::get().writes(1))
                    .saturating_add(
                        T::DbWeight::get().writes((1_u64).saturating_mul(c.into())),
                    )
                    .saturating_add(Weight::from_parts(0, 2519).saturating_mul(c.into()))
                    .saturating_add(Weight::from_parts(0, 2603).saturating_mul(r.into()))
            }
        }
    }
    pub mod pallet_multisig {
        //! Autogenerated weights for `pallet_multisig`
        //!
        //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
        //! DATE: 2023-07-31, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
        //! WORST CASE MAP SIZE: `1000000`
        //! HOSTNAME: `runner-ynta1nyy-project-238-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
        //! EXECUTION: ``, WASM-EXECUTION: `Compiled`, CHAIN: `Some("asset-hub-kusama-dev")`, DB CACHE: 1024
        #![allow(unused_parens)]
        #![allow(unused_imports)]
        #![allow(missing_docs)]
        use frame_support::{traits::Get, weights::Weight};
        use core::marker::PhantomData;
        /// Weight functions for `pallet_multisig`.
        pub struct WeightInfo<T>(PhantomData<T>);
        impl<T: frame_system::Config> pallet_multisig::WeightInfo for WeightInfo<T> {
            /// The range of component `z` is `[0, 10000]`.
            fn as_multi_threshold_1(z: u32) -> Weight {
                Weight::from_parts(14_440_231, 0)
                    .saturating_add(Weight::from_parts(0, 0))
                    .saturating_add(Weight::from_parts(598, 0).saturating_mul(z.into()))
            }
            /// Storage: `Multisig::Multisigs` (r:1 w:1)
            /// Proof: `Multisig::Multisigs` (`max_values`: None, `max_size`: Some(3346), added: 5821, mode: `MaxEncodedLen`)
            /// The range of component `s` is `[2, 100]`.
            /// The range of component `z` is `[0, 10000]`.
            fn as_multi_create(s: u32, z: u32) -> Weight {
                Weight::from_parts(33_662_218, 0)
                    .saturating_add(Weight::from_parts(0, 6811))
                    .saturating_add(
                        Weight::from_parts(128_927, 0).saturating_mul(s.into()),
                    )
                    .saturating_add(
                        Weight::from_parts(1_543, 0).saturating_mul(z.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Multisig::Multisigs` (r:1 w:1)
            /// Proof: `Multisig::Multisigs` (`max_values`: None, `max_size`: Some(3346), added: 5821, mode: `MaxEncodedLen`)
            /// The range of component `s` is `[3, 100]`.
            /// The range of component `z` is `[0, 10000]`.
            fn as_multi_approve(s: u32, z: u32) -> Weight {
                Weight::from_parts(20_559_891, 0)
                    .saturating_add(Weight::from_parts(0, 6811))
                    .saturating_add(
                        Weight::from_parts(103_601, 0).saturating_mul(s.into()),
                    )
                    .saturating_add(
                        Weight::from_parts(1_504, 0).saturating_mul(z.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Multisig::Multisigs` (r:1 w:1)
            /// Proof: `Multisig::Multisigs` (`max_values`: None, `max_size`: Some(3346), added: 5821, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            /// The range of component `s` is `[2, 100]`.
            /// The range of component `z` is `[0, 10000]`.
            fn as_multi_complete(s: u32, z: u32) -> Weight {
                Weight::from_parts(36_510_777, 0)
                    .saturating_add(Weight::from_parts(0, 6811))
                    .saturating_add(
                        Weight::from_parts(183_764, 0).saturating_mul(s.into()),
                    )
                    .saturating_add(
                        Weight::from_parts(1_653, 0).saturating_mul(z.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Multisig::Multisigs` (r:1 w:1)
            /// Proof: `Multisig::Multisigs` (`max_values`: None, `max_size`: Some(3346), added: 5821, mode: `MaxEncodedLen`)
            /// The range of component `s` is `[2, 100]`.
            fn approve_as_multi_create(s: u32) -> Weight {
                Weight::from_parts(32_408_621, 0)
                    .saturating_add(Weight::from_parts(0, 6811))
                    .saturating_add(
                        Weight::from_parts(121_410, 0).saturating_mul(s.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Multisig::Multisigs` (r:1 w:1)
            /// Proof: `Multisig::Multisigs` (`max_values`: None, `max_size`: Some(3346), added: 5821, mode: `MaxEncodedLen`)
            /// The range of component `s` is `[2, 100]`.
            fn approve_as_multi_approve(s: u32) -> Weight {
                Weight::from_parts(18_223_547, 0)
                    .saturating_add(Weight::from_parts(0, 6811))
                    .saturating_add(
                        Weight::from_parts(114_584, 0).saturating_mul(s.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Multisig::Multisigs` (r:1 w:1)
            /// Proof: `Multisig::Multisigs` (`max_values`: None, `max_size`: Some(3346), added: 5821, mode: `MaxEncodedLen`)
            /// The range of component `s` is `[2, 100]`.
            fn cancel_as_multi(s: u32) -> Weight {
                Weight::from_parts(33_674_827, 0)
                    .saturating_add(Weight::from_parts(0, 6811))
                    .saturating_add(
                        Weight::from_parts(122_011, 0).saturating_mul(s.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
        }
    }
    pub mod pallet_nft_fractionalization {
        //! Autogenerated weights for `pallet_nft_fractionalization`
        //!
        //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
        //! DATE: 2023-07-31, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
        //! WORST CASE MAP SIZE: `1000000`
        //! HOSTNAME: `runner-ynta1nyy-project-238-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
        //! EXECUTION: ``, WASM-EXECUTION: `Compiled`, CHAIN: `Some("asset-hub-kusama-dev")`, DB CACHE: 1024
        #![allow(unused_parens)]
        #![allow(unused_imports)]
        #![allow(missing_docs)]
        use frame_support::{traits::Get, weights::Weight};
        use core::marker::PhantomData;
        /// Weight functions for `pallet_nft_fractionalization`.
        pub struct WeightInfo<T>(PhantomData<T>);
        impl<T: frame_system::Config> pallet_nft_fractionalization::WeightInfo
        for WeightInfo<T> {
            /// Storage: `Nfts::Item` (r:1 w:0)
            /// Proof: `Nfts::Item` (`max_values`: None, `max_size`: Some(861), added: 3336, mode: `MaxEncodedLen`)
            /// Storage: `Balances::Holds` (r:1 w:1)
            /// Proof: `Balances::Holds` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Attribute` (r:1 w:1)
            /// Proof: `Nfts::Attribute` (`max_values`: None, `max_size`: Some(479), added: 2954, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Collection` (r:1 w:1)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Account` (r:1 w:1)
            /// Proof: `Assets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Metadata` (r:1 w:1)
            /// Proof: `Assets::Metadata` (`max_values`: None, `max_size`: Some(140), added: 2615, mode: `MaxEncodedLen`)
            /// Storage: `NftFractionalization::NftToAsset` (r:0 w:1)
            /// Proof: `NftFractionalization::NftToAsset` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
            fn fractionalize() -> Weight {
                Weight::from_parts(180_912_000, 0)
                    .saturating_add(Weight::from_parts(0, 4326))
                    .saturating_add(T::DbWeight::get().reads(8))
                    .saturating_add(T::DbWeight::get().writes(8))
            }
            /// Storage: `NftFractionalization::NftToAsset` (r:1 w:1)
            /// Proof: `NftFractionalization::NftToAsset` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Asset` (r:1 w:1)
            /// Proof: `Assets::Asset` (`max_values`: None, `max_size`: Some(210), added: 2685, mode: `MaxEncodedLen`)
            /// Storage: `Assets::Account` (r:1 w:1)
            /// Proof: `Assets::Account` (`max_values`: None, `max_size`: Some(134), added: 2609, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Attribute` (r:1 w:1)
            /// Proof: `Nfts::Attribute` (`max_values`: None, `max_size`: Some(479), added: 2954, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Collection` (r:1 w:1)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionConfigOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemConfigOf` (r:1 w:0)
            /// Proof: `Nfts::ItemConfigOf` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Item` (r:1 w:1)
            /// Proof: `Nfts::Item` (`max_values`: None, `max_size`: Some(861), added: 3336, mode: `MaxEncodedLen`)
            /// Storage: `Balances::Holds` (r:1 w:1)
            /// Proof: `Balances::Holds` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Account` (r:0 w:1)
            /// Proof: `Nfts::Account` (`max_values`: None, `max_size`: Some(88), added: 2563, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemPriceOf` (r:0 w:1)
            /// Proof: `Nfts::ItemPriceOf` (`max_values`: None, `max_size`: Some(89), added: 2564, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::PendingSwapOf` (r:0 w:1)
            /// Proof: `Nfts::PendingSwapOf` (`max_values`: None, `max_size`: Some(71), added: 2546, mode: `MaxEncodedLen`)
            fn unify() -> Weight {
                Weight::from_parts(128_238_000, 0)
                    .saturating_add(Weight::from_parts(0, 4326))
                    .saturating_add(T::DbWeight::get().reads(9))
                    .saturating_add(T::DbWeight::get().writes(10))
            }
        }
    }
    pub mod pallet_nfts {
        //! Autogenerated weights for `pallet_nfts`
        //!
        //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
        //! DATE: 2023-07-31, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
        //! WORST CASE MAP SIZE: `1000000`
        //! HOSTNAME: `runner-ynta1nyy-project-238-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
        //! EXECUTION: ``, WASM-EXECUTION: `Compiled`, CHAIN: `Some("asset-hub-kusama-dev")`, DB CACHE: 1024
        #![allow(unused_parens)]
        #![allow(unused_imports)]
        #![allow(missing_docs)]
        use frame_support::{traits::Get, weights::Weight};
        use core::marker::PhantomData;
        /// Weight functions for `pallet_nfts`.
        pub struct WeightInfo<T>(PhantomData<T>);
        impl<T: frame_system::Config> pallet_nfts::WeightInfo for WeightInfo<T> {
            /// Storage: `Nfts::NextCollectionId` (r:1 w:1)
            /// Proof: `Nfts::NextCollectionId` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Collection` (r:1 w:1)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionRoleOf` (r:0 w:1)
            /// Proof: `Nfts::CollectionRoleOf` (`max_values`: None, `max_size`: Some(69), added: 2544, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionConfigOf` (r:0 w:1)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionAccount` (r:0 w:1)
            /// Proof: `Nfts::CollectionAccount` (`max_values`: None, `max_size`: Some(68), added: 2543, mode: `MaxEncodedLen`)
            fn create() -> Weight {
                Weight::from_parts(39_975_000, 0)
                    .saturating_add(Weight::from_parts(0, 3549))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(5))
            }
            /// Storage: `Nfts::NextCollectionId` (r:1 w:1)
            /// Proof: `Nfts::NextCollectionId` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Collection` (r:1 w:1)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionRoleOf` (r:0 w:1)
            /// Proof: `Nfts::CollectionRoleOf` (`max_values`: None, `max_size`: Some(69), added: 2544, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionConfigOf` (r:0 w:1)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionAccount` (r:0 w:1)
            /// Proof: `Nfts::CollectionAccount` (`max_values`: None, `max_size`: Some(68), added: 2543, mode: `MaxEncodedLen`)
            fn force_create() -> Weight {
                Weight::from_parts(23_857_000, 0)
                    .saturating_add(Weight::from_parts(0, 3549))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(5))
            }
            /// Storage: `Nfts::Collection` (r:1 w:1)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemMetadataOf` (r:1 w:0)
            /// Proof: `Nfts::ItemMetadataOf` (`max_values`: None, `max_size`: Some(347), added: 2822, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionRoleOf` (r:1 w:1)
            /// Proof: `Nfts::CollectionRoleOf` (`max_values`: None, `max_size`: Some(69), added: 2544, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Attribute` (r:1001 w:1000)
            /// Proof: `Nfts::Attribute` (`max_values`: None, `max_size`: Some(479), added: 2954, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemConfigOf` (r:1000 w:1000)
            /// Proof: `Nfts::ItemConfigOf` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionMetadataOf` (r:0 w:1)
            /// Proof: `Nfts::CollectionMetadataOf` (`max_values`: None, `max_size`: Some(294), added: 2769, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionConfigOf` (r:0 w:1)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionAccount` (r:0 w:1)
            /// Proof: `Nfts::CollectionAccount` (`max_values`: None, `max_size`: Some(68), added: 2543, mode: `MaxEncodedLen`)
            /// The range of component `m` is `[0, 1000]`.
            /// The range of component `c` is `[0, 1000]`.
            /// The range of component `a` is `[0, 1000]`.
            fn destroy(_m: u32, _c: u32, a: u32) -> Weight {
                Weight::from_parts(1_281_136_346, 0)
                    .saturating_add(Weight::from_parts(0, 2523990))
                    .saturating_add(
                        Weight::from_parts(6_910_740, 0).saturating_mul(a.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(1004))
                    .saturating_add(
                        T::DbWeight::get().reads((1_u64).saturating_mul(a.into())),
                    )
                    .saturating_add(T::DbWeight::get().writes(1005))
                    .saturating_add(
                        T::DbWeight::get().writes((1_u64).saturating_mul(a.into())),
                    )
                    .saturating_add(Weight::from_parts(0, 2954).saturating_mul(a.into()))
            }
            /// Storage: `Nfts::CollectionConfigOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Item` (r:1 w:1)
            /// Proof: `Nfts::Item` (`max_values`: None, `max_size`: Some(861), added: 3336, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Collection` (r:1 w:1)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionRoleOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionRoleOf` (`max_values`: None, `max_size`: Some(69), added: 2544, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemConfigOf` (r:1 w:1)
            /// Proof: `Nfts::ItemConfigOf` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Account` (r:0 w:1)
            /// Proof: `Nfts::Account` (`max_values`: None, `max_size`: Some(88), added: 2563, mode: `MaxEncodedLen`)
            fn mint() -> Weight {
                Weight::from_parts(51_045_000, 0)
                    .saturating_add(Weight::from_parts(0, 4326))
                    .saturating_add(T::DbWeight::get().reads(5))
                    .saturating_add(T::DbWeight::get().writes(4))
            }
            /// Storage: `Nfts::CollectionRoleOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionRoleOf` (`max_values`: None, `max_size`: Some(69), added: 2544, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Item` (r:1 w:1)
            /// Proof: `Nfts::Item` (`max_values`: None, `max_size`: Some(861), added: 3336, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Collection` (r:1 w:1)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionConfigOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemConfigOf` (r:1 w:1)
            /// Proof: `Nfts::ItemConfigOf` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Account` (r:0 w:1)
            /// Proof: `Nfts::Account` (`max_values`: None, `max_size`: Some(88), added: 2563, mode: `MaxEncodedLen`)
            fn force_mint() -> Weight {
                Weight::from_parts(49_756_000, 0)
                    .saturating_add(Weight::from_parts(0, 4326))
                    .saturating_add(T::DbWeight::get().reads(5))
                    .saturating_add(T::DbWeight::get().writes(4))
            }
            /// Storage: `Nfts::Attribute` (r:1 w:0)
            /// Proof: `Nfts::Attribute` (`max_values`: None, `max_size`: Some(479), added: 2954, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemConfigOf` (r:1 w:1)
            /// Proof: `Nfts::ItemConfigOf` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Collection` (r:1 w:1)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Item` (r:1 w:1)
            /// Proof: `Nfts::Item` (`max_values`: None, `max_size`: Some(861), added: 3336, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemMetadataOf` (r:1 w:0)
            /// Proof: `Nfts::ItemMetadataOf` (`max_values`: None, `max_size`: Some(347), added: 2822, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Account` (r:0 w:1)
            /// Proof: `Nfts::Account` (`max_values`: None, `max_size`: Some(88), added: 2563, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemPriceOf` (r:0 w:1)
            /// Proof: `Nfts::ItemPriceOf` (`max_values`: None, `max_size`: Some(89), added: 2564, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemAttributesApprovalsOf` (r:0 w:1)
            /// Proof: `Nfts::ItemAttributesApprovalsOf` (`max_values`: None, `max_size`: Some(1001), added: 3476, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::PendingSwapOf` (r:0 w:1)
            /// Proof: `Nfts::PendingSwapOf` (`max_values`: None, `max_size`: Some(71), added: 2546, mode: `MaxEncodedLen`)
            fn burn() -> Weight {
                Weight::from_parts(57_162_000, 0)
                    .saturating_add(Weight::from_parts(0, 4326))
                    .saturating_add(T::DbWeight::get().reads(5))
                    .saturating_add(T::DbWeight::get().writes(7))
            }
            /// Storage: `Nfts::Collection` (r:1 w:0)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Attribute` (r:1 w:0)
            /// Proof: `Nfts::Attribute` (`max_values`: None, `max_size`: Some(479), added: 2954, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionConfigOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemConfigOf` (r:1 w:0)
            /// Proof: `Nfts::ItemConfigOf` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Item` (r:1 w:1)
            /// Proof: `Nfts::Item` (`max_values`: None, `max_size`: Some(861), added: 3336, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Account` (r:0 w:2)
            /// Proof: `Nfts::Account` (`max_values`: None, `max_size`: Some(88), added: 2563, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemPriceOf` (r:0 w:1)
            /// Proof: `Nfts::ItemPriceOf` (`max_values`: None, `max_size`: Some(89), added: 2564, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::PendingSwapOf` (r:0 w:1)
            /// Proof: `Nfts::PendingSwapOf` (`max_values`: None, `max_size`: Some(71), added: 2546, mode: `MaxEncodedLen`)
            fn transfer() -> Weight {
                Weight::from_parts(43_187_000, 0)
                    .saturating_add(Weight::from_parts(0, 4326))
                    .saturating_add(T::DbWeight::get().reads(5))
                    .saturating_add(T::DbWeight::get().writes(5))
            }
            /// Storage: `Nfts::Collection` (r:1 w:0)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionConfigOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Item` (r:5000 w:5000)
            /// Proof: `Nfts::Item` (`max_values`: None, `max_size`: Some(861), added: 3336, mode: `MaxEncodedLen`)
            /// The range of component `i` is `[0, 5000]`.
            fn redeposit(i: u32) -> Weight {
                Weight::from_parts(17_167_000, 0)
                    .saturating_add(Weight::from_parts(0, 3549))
                    .saturating_add(
                        Weight::from_parts(18_046_970, 0).saturating_mul(i.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(
                        T::DbWeight::get().reads((1_u64).saturating_mul(i.into())),
                    )
                    .saturating_add(
                        T::DbWeight::get().writes((1_u64).saturating_mul(i.into())),
                    )
                    .saturating_add(Weight::from_parts(0, 3336).saturating_mul(i.into()))
            }
            /// Storage: `Nfts::CollectionRoleOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionRoleOf` (`max_values`: None, `max_size`: Some(69), added: 2544, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemConfigOf` (r:1 w:1)
            /// Proof: `Nfts::ItemConfigOf` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
            fn lock_item_transfer() -> Weight {
                Weight::from_parts(21_409_000, 0)
                    .saturating_add(Weight::from_parts(0, 3534))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Nfts::CollectionRoleOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionRoleOf` (`max_values`: None, `max_size`: Some(69), added: 2544, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemConfigOf` (r:1 w:1)
            /// Proof: `Nfts::ItemConfigOf` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
            fn unlock_item_transfer() -> Weight {
                Weight::from_parts(21_030_000, 0)
                    .saturating_add(Weight::from_parts(0, 3534))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Nfts::Collection` (r:1 w:0)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionConfigOf` (r:1 w:1)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            fn lock_collection() -> Weight {
                Weight::from_parts(17_804_000, 0)
                    .saturating_add(Weight::from_parts(0, 3549))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Nfts::OwnershipAcceptance` (r:1 w:1)
            /// Proof: `Nfts::OwnershipAcceptance` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Collection` (r:1 w:1)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionAccount` (r:0 w:2)
            /// Proof: `Nfts::CollectionAccount` (`max_values`: None, `max_size`: Some(68), added: 2543, mode: `MaxEncodedLen`)
            fn transfer_ownership() -> Weight {
                Weight::from_parts(23_499_000, 0)
                    .saturating_add(Weight::from_parts(0, 3549))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(4))
            }
            /// Storage: `Nfts::Collection` (r:1 w:1)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionRoleOf` (r:2 w:4)
            /// Proof: `Nfts::CollectionRoleOf` (`max_values`: None, `max_size`: Some(69), added: 2544, mode: `MaxEncodedLen`)
            fn set_team() -> Weight {
                Weight::from_parts(40_800_000, 0)
                    .saturating_add(Weight::from_parts(0, 6078))
                    .saturating_add(T::DbWeight::get().reads(3))
                    .saturating_add(T::DbWeight::get().writes(5))
            }
            /// Storage: `Nfts::Collection` (r:1 w:1)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionAccount` (r:0 w:2)
            /// Proof: `Nfts::CollectionAccount` (`max_values`: None, `max_size`: Some(68), added: 2543, mode: `MaxEncodedLen`)
            fn force_collection_owner() -> Weight {
                Weight::from_parts(18_297_000, 0)
                    .saturating_add(Weight::from_parts(0, 3549))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(3))
            }
            /// Storage: `Nfts::Collection` (r:1 w:0)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionConfigOf` (r:0 w:1)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            fn force_collection_config() -> Weight {
                Weight::from_parts(15_370_000, 0)
                    .saturating_add(Weight::from_parts(0, 3549))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Nfts::CollectionRoleOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionRoleOf` (`max_values`: None, `max_size`: Some(69), added: 2544, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemConfigOf` (r:1 w:1)
            /// Proof: `Nfts::ItemConfigOf` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
            fn lock_item_properties() -> Weight {
                Weight::from_parts(20_258_000, 0)
                    .saturating_add(Weight::from_parts(0, 3534))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Nfts::Collection` (r:1 w:1)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionRoleOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionRoleOf` (`max_values`: None, `max_size`: Some(69), added: 2544, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionConfigOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemConfigOf` (r:1 w:0)
            /// Proof: `Nfts::ItemConfigOf` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Attribute` (r:1 w:1)
            /// Proof: `Nfts::Attribute` (`max_values`: None, `max_size`: Some(479), added: 2954, mode: `MaxEncodedLen`)
            fn set_attribute() -> Weight {
                Weight::from_parts(50_971_000, 0)
                    .saturating_add(Weight::from_parts(0, 3944))
                    .saturating_add(T::DbWeight::get().reads(5))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Nfts::Collection` (r:1 w:1)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Attribute` (r:1 w:1)
            /// Proof: `Nfts::Attribute` (`max_values`: None, `max_size`: Some(479), added: 2954, mode: `MaxEncodedLen`)
            fn force_set_attribute() -> Weight {
                Weight::from_parts(27_086_000, 0)
                    .saturating_add(Weight::from_parts(0, 3944))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Nfts::Attribute` (r:1 w:1)
            /// Proof: `Nfts::Attribute` (`max_values`: None, `max_size`: Some(479), added: 2954, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionRoleOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionRoleOf` (`max_values`: None, `max_size`: Some(69), added: 2544, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemConfigOf` (r:1 w:0)
            /// Proof: `Nfts::ItemConfigOf` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Collection` (r:1 w:1)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            fn clear_attribute() -> Weight {
                Weight::from_parts(47_107_000, 0)
                    .saturating_add(Weight::from_parts(0, 3944))
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Nfts::Item` (r:1 w:0)
            /// Proof: `Nfts::Item` (`max_values`: None, `max_size`: Some(861), added: 3336, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemAttributesApprovalsOf` (r:1 w:1)
            /// Proof: `Nfts::ItemAttributesApprovalsOf` (`max_values`: None, `max_size`: Some(1001), added: 3476, mode: `MaxEncodedLen`)
            fn approve_item_attributes() -> Weight {
                Weight::from_parts(18_371_000, 0)
                    .saturating_add(Weight::from_parts(0, 4466))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Nfts::Item` (r:1 w:0)
            /// Proof: `Nfts::Item` (`max_values`: None, `max_size`: Some(861), added: 3336, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemAttributesApprovalsOf` (r:1 w:1)
            /// Proof: `Nfts::ItemAttributesApprovalsOf` (`max_values`: None, `max_size`: Some(1001), added: 3476, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Attribute` (r:1001 w:1000)
            /// Proof: `Nfts::Attribute` (`max_values`: None, `max_size`: Some(479), added: 2954, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            /// The range of component `n` is `[0, 1000]`.
            fn cancel_item_attributes_approval(n: u32) -> Weight {
                Weight::from_parts(27_010_000, 0)
                    .saturating_add(Weight::from_parts(0, 4466))
                    .saturating_add(
                        Weight::from_parts(6_584_290, 0).saturating_mul(n.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(
                        T::DbWeight::get().reads((1_u64).saturating_mul(n.into())),
                    )
                    .saturating_add(T::DbWeight::get().writes(2))
                    .saturating_add(
                        T::DbWeight::get().writes((1_u64).saturating_mul(n.into())),
                    )
                    .saturating_add(Weight::from_parts(0, 2954).saturating_mul(n.into()))
            }
            /// Storage: `Nfts::CollectionRoleOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionRoleOf` (`max_values`: None, `max_size`: Some(69), added: 2544, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Collection` (r:1 w:1)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemConfigOf` (r:1 w:0)
            /// Proof: `Nfts::ItemConfigOf` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionConfigOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemMetadataOf` (r:1 w:1)
            /// Proof: `Nfts::ItemMetadataOf` (`max_values`: None, `max_size`: Some(347), added: 2822, mode: `MaxEncodedLen`)
            fn set_metadata() -> Weight {
                Weight::from_parts(42_758_000, 0)
                    .saturating_add(Weight::from_parts(0, 3812))
                    .saturating_add(T::DbWeight::get().reads(5))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Nfts::CollectionRoleOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionRoleOf` (`max_values`: None, `max_size`: Some(69), added: 2544, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemMetadataOf` (r:1 w:1)
            /// Proof: `Nfts::ItemMetadataOf` (`max_values`: None, `max_size`: Some(347), added: 2822, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Collection` (r:1 w:1)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemConfigOf` (r:1 w:0)
            /// Proof: `Nfts::ItemConfigOf` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
            fn clear_metadata() -> Weight {
                Weight::from_parts(41_026_000, 0)
                    .saturating_add(Weight::from_parts(0, 3812))
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Nfts::CollectionRoleOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionRoleOf` (`max_values`: None, `max_size`: Some(69), added: 2544, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionConfigOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Collection` (r:1 w:1)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionMetadataOf` (r:1 w:1)
            /// Proof: `Nfts::CollectionMetadataOf` (`max_values`: None, `max_size`: Some(294), added: 2769, mode: `MaxEncodedLen`)
            fn set_collection_metadata() -> Weight {
                Weight::from_parts(38_561_000, 0)
                    .saturating_add(Weight::from_parts(0, 3759))
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Nfts::CollectionRoleOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionRoleOf` (`max_values`: None, `max_size`: Some(69), added: 2544, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Collection` (r:1 w:0)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionConfigOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionMetadataOf` (r:1 w:1)
            /// Proof: `Nfts::CollectionMetadataOf` (`max_values`: None, `max_size`: Some(294), added: 2769, mode: `MaxEncodedLen`)
            fn clear_collection_metadata() -> Weight {
                Weight::from_parts(38_215_000, 0)
                    .saturating_add(Weight::from_parts(0, 3759))
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Nfts::Item` (r:1 w:1)
            /// Proof: `Nfts::Item` (`max_values`: None, `max_size`: Some(861), added: 3336, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionConfigOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            fn approve_transfer() -> Weight {
                Weight::from_parts(21_803_000, 0)
                    .saturating_add(Weight::from_parts(0, 4326))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Nfts::Item` (r:1 w:1)
            /// Proof: `Nfts::Item` (`max_values`: None, `max_size`: Some(861), added: 3336, mode: `MaxEncodedLen`)
            fn cancel_approval() -> Weight {
                Weight::from_parts(19_185_000, 0)
                    .saturating_add(Weight::from_parts(0, 4326))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Nfts::Item` (r:1 w:1)
            /// Proof: `Nfts::Item` (`max_values`: None, `max_size`: Some(861), added: 3336, mode: `MaxEncodedLen`)
            fn clear_all_transfer_approvals() -> Weight {
                Weight::from_parts(18_270_000, 0)
                    .saturating_add(Weight::from_parts(0, 4326))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Nfts::OwnershipAcceptance` (r:1 w:1)
            /// Proof: `Nfts::OwnershipAcceptance` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
            fn set_accept_ownership() -> Weight {
                Weight::from_parts(16_700_000, 0)
                    .saturating_add(Weight::from_parts(0, 3517))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Nfts::CollectionConfigOf` (r:1 w:1)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Collection` (r:1 w:0)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            fn set_collection_max_supply() -> Weight {
                Weight::from_parts(19_785_000, 0)
                    .saturating_add(Weight::from_parts(0, 3549))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Nfts::CollectionRoleOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionRoleOf` (`max_values`: None, `max_size`: Some(69), added: 2544, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionConfigOf` (r:1 w:1)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            fn update_mint_settings() -> Weight {
                Weight::from_parts(19_292_000, 0)
                    .saturating_add(Weight::from_parts(0, 3538))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Nfts::Item` (r:1 w:0)
            /// Proof: `Nfts::Item` (`max_values`: None, `max_size`: Some(861), added: 3336, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionConfigOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemConfigOf` (r:1 w:0)
            /// Proof: `Nfts::ItemConfigOf` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemPriceOf` (r:0 w:1)
            /// Proof: `Nfts::ItemPriceOf` (`max_values`: None, `max_size`: Some(89), added: 2564, mode: `MaxEncodedLen`)
            fn set_price() -> Weight {
                Weight::from_parts(25_257_000, 0)
                    .saturating_add(Weight::from_parts(0, 4326))
                    .saturating_add(T::DbWeight::get().reads(3))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Nfts::Item` (r:1 w:1)
            /// Proof: `Nfts::Item` (`max_values`: None, `max_size`: Some(861), added: 3336, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemPriceOf` (r:1 w:1)
            /// Proof: `Nfts::ItemPriceOf` (`max_values`: None, `max_size`: Some(89), added: 2564, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Collection` (r:1 w:0)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Attribute` (r:1 w:0)
            /// Proof: `Nfts::Attribute` (`max_values`: None, `max_size`: Some(479), added: 2954, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionConfigOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemConfigOf` (r:1 w:0)
            /// Proof: `Nfts::ItemConfigOf` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Account` (r:0 w:2)
            /// Proof: `Nfts::Account` (`max_values`: None, `max_size`: Some(88), added: 2563, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::PendingSwapOf` (r:0 w:1)
            /// Proof: `Nfts::PendingSwapOf` (`max_values`: None, `max_size`: Some(71), added: 2546, mode: `MaxEncodedLen`)
            fn buy_item() -> Weight {
                Weight::from_parts(52_161_000, 0)
                    .saturating_add(Weight::from_parts(0, 4326))
                    .saturating_add(T::DbWeight::get().reads(6))
                    .saturating_add(T::DbWeight::get().writes(5))
            }
            /// The range of component `n` is `[0, 10]`.
            fn pay_tips(n: u32) -> Weight {
                Weight::from_parts(3_476_001, 0)
                    .saturating_add(Weight::from_parts(0, 0))
                    .saturating_add(
                        Weight::from_parts(3_844_820, 0).saturating_mul(n.into()),
                    )
            }
            /// Storage: `Nfts::Item` (r:2 w:0)
            /// Proof: `Nfts::Item` (`max_values`: None, `max_size`: Some(861), added: 3336, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::PendingSwapOf` (r:0 w:1)
            /// Proof: `Nfts::PendingSwapOf` (`max_values`: None, `max_size`: Some(71), added: 2546, mode: `MaxEncodedLen`)
            fn create_swap() -> Weight {
                Weight::from_parts(22_746_000, 0)
                    .saturating_add(Weight::from_parts(0, 7662))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Nfts::PendingSwapOf` (r:1 w:1)
            /// Proof: `Nfts::PendingSwapOf` (`max_values`: None, `max_size`: Some(71), added: 2546, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Item` (r:1 w:0)
            /// Proof: `Nfts::Item` (`max_values`: None, `max_size`: Some(861), added: 3336, mode: `MaxEncodedLen`)
            fn cancel_swap() -> Weight {
                Weight::from_parts(21_465_000, 0)
                    .saturating_add(Weight::from_parts(0, 4326))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Nfts::Item` (r:2 w:2)
            /// Proof: `Nfts::Item` (`max_values`: None, `max_size`: Some(861), added: 3336, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::PendingSwapOf` (r:1 w:2)
            /// Proof: `Nfts::PendingSwapOf` (`max_values`: None, `max_size`: Some(71), added: 2546, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Collection` (r:1 w:0)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Attribute` (r:2 w:0)
            /// Proof: `Nfts::Attribute` (`max_values`: None, `max_size`: Some(479), added: 2954, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionConfigOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemConfigOf` (r:2 w:0)
            /// Proof: `Nfts::ItemConfigOf` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Account` (r:0 w:4)
            /// Proof: `Nfts::Account` (`max_values`: None, `max_size`: Some(88), added: 2563, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemPriceOf` (r:0 w:2)
            /// Proof: `Nfts::ItemPriceOf` (`max_values`: None, `max_size`: Some(89), added: 2564, mode: `MaxEncodedLen`)
            fn claim_swap() -> Weight {
                Weight::from_parts(86_078_000, 0)
                    .saturating_add(Weight::from_parts(0, 7662))
                    .saturating_add(T::DbWeight::get().reads(9))
                    .saturating_add(T::DbWeight::get().writes(10))
            }
            /// Storage: `Nfts::CollectionRoleOf` (r:2 w:0)
            /// Proof: `Nfts::CollectionRoleOf` (`max_values`: None, `max_size`: Some(69), added: 2544, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionConfigOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Item` (r:1 w:1)
            /// Proof: `Nfts::Item` (`max_values`: None, `max_size`: Some(861), added: 3336, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Collection` (r:1 w:1)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemConfigOf` (r:1 w:1)
            /// Proof: `Nfts::ItemConfigOf` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Attribute` (r:10 w:10)
            /// Proof: `Nfts::Attribute` (`max_values`: None, `max_size`: Some(479), added: 2954, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemMetadataOf` (r:1 w:1)
            /// Proof: `Nfts::ItemMetadataOf` (`max_values`: None, `max_size`: Some(347), added: 2822, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Account` (r:0 w:1)
            /// Proof: `Nfts::Account` (`max_values`: None, `max_size`: Some(88), added: 2563, mode: `MaxEncodedLen`)
            /// The range of component `n` is `[0, 10]`.
            fn mint_pre_signed(n: u32) -> Weight {
                Weight::from_parts(150_978_773, 0)
                    .saturating_add(Weight::from_parts(0, 6078))
                    .saturating_add(
                        Weight::from_parts(31_888_255, 0).saturating_mul(n.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(8))
                    .saturating_add(
                        T::DbWeight::get().reads((1_u64).saturating_mul(n.into())),
                    )
                    .saturating_add(T::DbWeight::get().writes(6))
                    .saturating_add(
                        T::DbWeight::get().writes((1_u64).saturating_mul(n.into())),
                    )
                    .saturating_add(Weight::from_parts(0, 2954).saturating_mul(n.into()))
            }
            /// Storage: `Nfts::Item` (r:1 w:0)
            /// Proof: `Nfts::Item` (`max_values`: None, `max_size`: Some(861), added: 3336, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::ItemAttributesApprovalsOf` (r:1 w:1)
            /// Proof: `Nfts::ItemAttributesApprovalsOf` (`max_values`: None, `max_size`: Some(1001), added: 3476, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::CollectionConfigOf` (r:1 w:0)
            /// Proof: `Nfts::CollectionConfigOf` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Collection` (r:1 w:1)
            /// Proof: `Nfts::Collection` (`max_values`: None, `max_size`: Some(84), added: 2559, mode: `MaxEncodedLen`)
            /// Storage: `Nfts::Attribute` (r:10 w:10)
            /// Proof: `Nfts::Attribute` (`max_values`: None, `max_size`: Some(479), added: 2954, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            /// The range of component `n` is `[0, 10]`.
            fn set_attributes_pre_signed(n: u32) -> Weight {
                Weight::from_parts(96_685_026, 0)
                    .saturating_add(Weight::from_parts(0, 4466))
                    .saturating_add(
                        Weight::from_parts(30_914_858, 0).saturating_mul(n.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(
                        T::DbWeight::get().reads((1_u64).saturating_mul(n.into())),
                    )
                    .saturating_add(T::DbWeight::get().writes(2))
                    .saturating_add(
                        T::DbWeight::get().writes((1_u64).saturating_mul(n.into())),
                    )
                    .saturating_add(Weight::from_parts(0, 2954).saturating_mul(n.into()))
            }
        }
    }
    pub mod pallet_proxy {
        //! Autogenerated weights for `pallet_proxy`
        //!
        //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
        //! DATE: 2023-07-31, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
        //! WORST CASE MAP SIZE: `1000000`
        //! HOSTNAME: `runner-ynta1nyy-project-238-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
        //! EXECUTION: ``, WASM-EXECUTION: `Compiled`, CHAIN: `Some("asset-hub-kusama-dev")`, DB CACHE: 1024
        #![allow(unused_parens)]
        #![allow(unused_imports)]
        #![allow(missing_docs)]
        use frame_support::{traits::Get, weights::Weight};
        use core::marker::PhantomData;
        /// Weight functions for `pallet_proxy`.
        pub struct WeightInfo<T>(PhantomData<T>);
        impl<T: frame_system::Config> pallet_proxy::WeightInfo for WeightInfo<T> {
            /// Storage: `Proxy::Proxies` (r:1 w:0)
            /// Proof: `Proxy::Proxies` (`max_values`: None, `max_size`: Some(1241), added: 3716, mode: `MaxEncodedLen`)
            /// The range of component `p` is `[1, 31]`.
            fn proxy(p: u32) -> Weight {
                Weight::from_parts(17_283_443, 0)
                    .saturating_add(Weight::from_parts(0, 4706))
                    .saturating_add(
                        Weight::from_parts(32_123, 0).saturating_mul(p.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(1))
            }
            /// Storage: `Proxy::Proxies` (r:1 w:0)
            /// Proof: `Proxy::Proxies` (`max_values`: None, `max_size`: Some(1241), added: 3716, mode: `MaxEncodedLen`)
            /// Storage: `Proxy::Announcements` (r:1 w:1)
            /// Proof: `Proxy::Announcements` (`max_values`: None, `max_size`: Some(2233), added: 4708, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            /// The range of component `a` is `[0, 31]`.
            /// The range of component `p` is `[1, 31]`.
            fn proxy_announced(a: u32, p: u32) -> Weight {
                Weight::from_parts(37_045_756, 0)
                    .saturating_add(Weight::from_parts(0, 5698))
                    .saturating_add(
                        Weight::from_parts(139_561, 0).saturating_mul(a.into()),
                    )
                    .saturating_add(
                        Weight::from_parts(73_270, 0).saturating_mul(p.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(3))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Proxy::Announcements` (r:1 w:1)
            /// Proof: `Proxy::Announcements` (`max_values`: None, `max_size`: Some(2233), added: 4708, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            /// The range of component `a` is `[0, 31]`.
            /// The range of component `p` is `[1, 31]`.
            fn remove_announcement(a: u32, p: u32) -> Weight {
                Weight::from_parts(24_711_403, 0)
                    .saturating_add(Weight::from_parts(0, 5698))
                    .saturating_add(
                        Weight::from_parts(128_391, 0).saturating_mul(a.into()),
                    )
                    .saturating_add(
                        Weight::from_parts(23_124, 0).saturating_mul(p.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Proxy::Announcements` (r:1 w:1)
            /// Proof: `Proxy::Announcements` (`max_values`: None, `max_size`: Some(2233), added: 4708, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            /// The range of component `a` is `[0, 31]`.
            /// The range of component `p` is `[1, 31]`.
            fn reject_announcement(a: u32, p: u32) -> Weight {
                Weight::from_parts(23_928_058, 0)
                    .saturating_add(Weight::from_parts(0, 5698))
                    .saturating_add(
                        Weight::from_parts(152_299, 0).saturating_mul(a.into()),
                    )
                    .saturating_add(
                        Weight::from_parts(39_775, 0).saturating_mul(p.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Proxy::Proxies` (r:1 w:0)
            /// Proof: `Proxy::Proxies` (`max_values`: None, `max_size`: Some(1241), added: 3716, mode: `MaxEncodedLen`)
            /// Storage: `Proxy::Announcements` (r:1 w:1)
            /// Proof: `Proxy::Announcements` (`max_values`: None, `max_size`: Some(2233), added: 4708, mode: `MaxEncodedLen`)
            /// Storage: `System::Account` (r:1 w:1)
            /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
            /// The range of component `a` is `[0, 31]`.
            /// The range of component `p` is `[1, 31]`.
            fn announce(a: u32, p: u32) -> Weight {
                Weight::from_parts(33_568_059, 0)
                    .saturating_add(Weight::from_parts(0, 5698))
                    .saturating_add(
                        Weight::from_parts(134_400, 0).saturating_mul(a.into()),
                    )
                    .saturating_add(
                        Weight::from_parts(57_028, 0).saturating_mul(p.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(3))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Proxy::Proxies` (r:1 w:1)
            /// Proof: `Proxy::Proxies` (`max_values`: None, `max_size`: Some(1241), added: 3716, mode: `MaxEncodedLen`)
            /// The range of component `p` is `[1, 31]`.
            fn add_proxy(p: u32) -> Weight {
                Weight::from_parts(26_235_199, 0)
                    .saturating_add(Weight::from_parts(0, 4706))
                    .saturating_add(
                        Weight::from_parts(41_435, 0).saturating_mul(p.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Proxy::Proxies` (r:1 w:1)
            /// Proof: `Proxy::Proxies` (`max_values`: None, `max_size`: Some(1241), added: 3716, mode: `MaxEncodedLen`)
            /// The range of component `p` is `[1, 31]`.
            fn remove_proxy(p: u32) -> Weight {
                Weight::from_parts(26_823_133, 0)
                    .saturating_add(Weight::from_parts(0, 4706))
                    .saturating_add(
                        Weight::from_parts(34_224, 0).saturating_mul(p.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Proxy::Proxies` (r:1 w:1)
            /// Proof: `Proxy::Proxies` (`max_values`: None, `max_size`: Some(1241), added: 3716, mode: `MaxEncodedLen`)
            /// The range of component `p` is `[1, 31]`.
            fn remove_proxies(p: u32) -> Weight {
                Weight::from_parts(23_304_060, 0)
                    .saturating_add(Weight::from_parts(0, 4706))
                    .saturating_add(
                        Weight::from_parts(39_612, 0).saturating_mul(p.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Proxy::Proxies` (r:1 w:1)
            /// Proof: `Proxy::Proxies` (`max_values`: None, `max_size`: Some(1241), added: 3716, mode: `MaxEncodedLen`)
            /// The range of component `p` is `[1, 31]`.
            fn create_pure(p: u32) -> Weight {
                Weight::from_parts(28_009_062, 0)
                    .saturating_add(Weight::from_parts(0, 4706))
                    .saturating_add(
                        Weight::from_parts(12_255, 0).saturating_mul(p.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Proxy::Proxies` (r:1 w:1)
            /// Proof: `Proxy::Proxies` (`max_values`: None, `max_size`: Some(1241), added: 3716, mode: `MaxEncodedLen`)
            /// The range of component `p` is `[0, 30]`.
            fn kill_pure(p: u32) -> Weight {
                Weight::from_parts(24_392_989, 0)
                    .saturating_add(Weight::from_parts(0, 4706))
                    .saturating_add(
                        Weight::from_parts(30_287, 0).saturating_mul(p.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
        }
    }
    pub mod pallet_session {
        //! Autogenerated weights for `pallet_session`
        //!
        //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
        //! DATE: 2023-07-31, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
        //! WORST CASE MAP SIZE: `1000000`
        //! HOSTNAME: `runner-ynta1nyy-project-238-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
        //! EXECUTION: ``, WASM-EXECUTION: `Compiled`, CHAIN: `Some("asset-hub-kusama-dev")`, DB CACHE: 1024
        #![allow(unused_parens)]
        #![allow(unused_imports)]
        #![allow(missing_docs)]
        use frame_support::{traits::Get, weights::Weight};
        use core::marker::PhantomData;
        /// Weight functions for `pallet_session`.
        pub struct WeightInfo<T>(PhantomData<T>);
        impl<T: frame_system::Config> pallet_session::WeightInfo for WeightInfo<T> {
            /// Storage: `Session::NextKeys` (r:1 w:1)
            /// Proof: `Session::NextKeys` (`max_values`: None, `max_size`: None, mode: `Measured`)
            /// Storage: `Session::KeyOwner` (r:1 w:1)
            /// Proof: `Session::KeyOwner` (`max_values`: None, `max_size`: None, mode: `Measured`)
            fn set_keys() -> Weight {
                Weight::from_parts(17_357_000, 0)
                    .saturating_add(Weight::from_parts(0, 3735))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Session::NextKeys` (r:1 w:1)
            /// Proof: `Session::NextKeys` (`max_values`: None, `max_size`: None, mode: `Measured`)
            /// Storage: `Session::KeyOwner` (r:0 w:1)
            /// Proof: `Session::KeyOwner` (`max_values`: None, `max_size`: None, mode: `Measured`)
            fn purge_keys() -> Weight {
                Weight::from_parts(12_770_000, 0)
                    .saturating_add(Weight::from_parts(0, 3707))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
        }
    }
    pub mod pallet_timestamp {
        //! Autogenerated weights for `pallet_timestamp`
        //!
        //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
        //! DATE: 2023-07-31, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
        //! WORST CASE MAP SIZE: `1000000`
        //! HOSTNAME: `runner-ynta1nyy-project-238-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
        //! EXECUTION: ``, WASM-EXECUTION: `Compiled`, CHAIN: `Some("asset-hub-kusama-dev")`, DB CACHE: 1024
        #![allow(unused_parens)]
        #![allow(unused_imports)]
        #![allow(missing_docs)]
        use frame_support::{traits::Get, weights::Weight};
        use core::marker::PhantomData;
        /// Weight functions for `pallet_timestamp`.
        pub struct WeightInfo<T>(PhantomData<T>);
        impl<T: frame_system::Config> pallet_timestamp::WeightInfo for WeightInfo<T> {
            /// Storage: `Timestamp::Now` (r:1 w:1)
            /// Proof: `Timestamp::Now` (`max_values`: Some(1), `max_size`: Some(8), added: 503, mode: `MaxEncodedLen`)
            /// Storage: `Aura::CurrentSlot` (r:1 w:0)
            /// Proof: `Aura::CurrentSlot` (`max_values`: Some(1), `max_size`: Some(8), added: 503, mode: `MaxEncodedLen`)
            fn set() -> Weight {
                Weight::from_parts(9_775_000, 0)
                    .saturating_add(Weight::from_parts(0, 1493))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            fn on_finalize() -> Weight {
                Weight::from_parts(3_577_000, 0).saturating_add(Weight::from_parts(0, 0))
            }
        }
    }
    pub mod pallet_uniques {
        //! Autogenerated weights for `pallet_uniques`
        //!
        //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
        //! DATE: 2023-07-31, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
        //! WORST CASE MAP SIZE: `1000000`
        //! HOSTNAME: `runner-ynta1nyy-project-238-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
        //! EXECUTION: ``, WASM-EXECUTION: `Compiled`, CHAIN: `Some("asset-hub-kusama-dev")`, DB CACHE: 1024
        #![allow(unused_parens)]
        #![allow(unused_imports)]
        #![allow(missing_docs)]
        use frame_support::{traits::Get, weights::Weight};
        use core::marker::PhantomData;
        /// Weight functions for `pallet_uniques`.
        pub struct WeightInfo<T>(PhantomData<T>);
        impl<T: frame_system::Config> pallet_uniques::WeightInfo for WeightInfo<T> {
            /// Storage: `Uniques::Class` (r:1 w:1)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::ClassAccount` (r:0 w:1)
            /// Proof: `Uniques::ClassAccount` (`max_values`: None, `max_size`: Some(68), added: 2543, mode: `MaxEncodedLen`)
            fn create() -> Weight {
                Weight::from_parts(29_675_000, 0)
                    .saturating_add(Weight::from_parts(0, 3643))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Uniques::Class` (r:1 w:1)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::ClassAccount` (r:0 w:1)
            /// Proof: `Uniques::ClassAccount` (`max_values`: None, `max_size`: Some(68), added: 2543, mode: `MaxEncodedLen`)
            fn force_create() -> Weight {
                Weight::from_parts(14_049_000, 0)
                    .saturating_add(Weight::from_parts(0, 3643))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Uniques::Class` (r:1 w:1)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::Asset` (r:1001 w:1000)
            /// Proof: `Uniques::Asset` (`max_values`: None, `max_size`: Some(122), added: 2597, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::InstanceMetadataOf` (r:1000 w:1000)
            /// Proof: `Uniques::InstanceMetadataOf` (`max_values`: None, `max_size`: Some(187), added: 2662, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::Attribute` (r:1000 w:1000)
            /// Proof: `Uniques::Attribute` (`max_values`: None, `max_size`: Some(172), added: 2647, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::ClassAccount` (r:0 w:1)
            /// Proof: `Uniques::ClassAccount` (`max_values`: None, `max_size`: Some(68), added: 2543, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::ClassMetadataOf` (r:0 w:1)
            /// Proof: `Uniques::ClassMetadataOf` (`max_values`: None, `max_size`: Some(167), added: 2642, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::Account` (r:0 w:1000)
            /// Proof: `Uniques::Account` (`max_values`: None, `max_size`: Some(88), added: 2563, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::CollectionMaxSupply` (r:0 w:1)
            /// Proof: `Uniques::CollectionMaxSupply` (`max_values`: None, `max_size`: Some(24), added: 2499, mode: `MaxEncodedLen`)
            /// The range of component `n` is `[0, 1000]`.
            /// The range of component `m` is `[0, 1000]`.
            /// The range of component `a` is `[0, 1000]`.
            fn destroy(n: u32, m: u32, a: u32) -> Weight {
                Weight::from_parts(2_983_862_000, 0)
                    .saturating_add(Weight::from_parts(0, 3643))
                    .saturating_add(
                        Weight::from_parts(7_589_778, 0).saturating_mul(n.into()),
                    )
                    .saturating_add(
                        Weight::from_parts(479_496, 0).saturating_mul(m.into()),
                    )
                    .saturating_add(
                        Weight::from_parts(562_056, 0).saturating_mul(a.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(
                        T::DbWeight::get().reads((1_u64).saturating_mul(n.into())),
                    )
                    .saturating_add(
                        T::DbWeight::get().reads((1_u64).saturating_mul(m.into())),
                    )
                    .saturating_add(
                        T::DbWeight::get().reads((1_u64).saturating_mul(a.into())),
                    )
                    .saturating_add(T::DbWeight::get().writes(4))
                    .saturating_add(
                        T::DbWeight::get().writes((2_u64).saturating_mul(n.into())),
                    )
                    .saturating_add(
                        T::DbWeight::get().writes((1_u64).saturating_mul(m.into())),
                    )
                    .saturating_add(
                        T::DbWeight::get().writes((1_u64).saturating_mul(a.into())),
                    )
                    .saturating_add(Weight::from_parts(0, 2647).saturating_mul(a.into()))
                    .saturating_add(Weight::from_parts(0, 2662).saturating_mul(m.into()))
                    .saturating_add(Weight::from_parts(0, 2597).saturating_mul(n.into()))
            }
            /// Storage: `Uniques::Asset` (r:1 w:1)
            /// Proof: `Uniques::Asset` (`max_values`: None, `max_size`: Some(122), added: 2597, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::Class` (r:1 w:1)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::CollectionMaxSupply` (r:1 w:0)
            /// Proof: `Uniques::CollectionMaxSupply` (`max_values`: None, `max_size`: Some(24), added: 2499, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::Account` (r:0 w:1)
            /// Proof: `Uniques::Account` (`max_values`: None, `max_size`: Some(88), added: 2563, mode: `MaxEncodedLen`)
            fn mint() -> Weight {
                Weight::from_parts(36_019_000, 0)
                    .saturating_add(Weight::from_parts(0, 3643))
                    .saturating_add(T::DbWeight::get().reads(3))
                    .saturating_add(T::DbWeight::get().writes(3))
            }
            /// Storage: `Uniques::Class` (r:1 w:1)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::Asset` (r:1 w:1)
            /// Proof: `Uniques::Asset` (`max_values`: None, `max_size`: Some(122), added: 2597, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::Account` (r:0 w:1)
            /// Proof: `Uniques::Account` (`max_values`: None, `max_size`: Some(88), added: 2563, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::ItemPriceOf` (r:0 w:1)
            /// Proof: `Uniques::ItemPriceOf` (`max_values`: None, `max_size`: Some(89), added: 2564, mode: `MaxEncodedLen`)
            fn burn() -> Weight {
                Weight::from_parts(37_190_000, 0)
                    .saturating_add(Weight::from_parts(0, 3643))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(4))
            }
            /// Storage: `Uniques::Class` (r:1 w:0)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::Asset` (r:1 w:1)
            /// Proof: `Uniques::Asset` (`max_values`: None, `max_size`: Some(122), added: 2597, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::Account` (r:0 w:2)
            /// Proof: `Uniques::Account` (`max_values`: None, `max_size`: Some(88), added: 2563, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::ItemPriceOf` (r:0 w:1)
            /// Proof: `Uniques::ItemPriceOf` (`max_values`: None, `max_size`: Some(89), added: 2564, mode: `MaxEncodedLen`)
            fn transfer() -> Weight {
                Weight::from_parts(27_400_000, 0)
                    .saturating_add(Weight::from_parts(0, 3643))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(4))
            }
            /// Storage: `Uniques::Class` (r:1 w:1)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::Asset` (r:5000 w:5000)
            /// Proof: `Uniques::Asset` (`max_values`: None, `max_size`: Some(122), added: 2597, mode: `MaxEncodedLen`)
            /// The range of component `i` is `[0, 5000]`.
            fn redeposit(i: u32) -> Weight {
                Weight::from_parts(14_831_000, 0)
                    .saturating_add(Weight::from_parts(0, 3643))
                    .saturating_add(
                        Weight::from_parts(17_972_938, 0).saturating_mul(i.into()),
                    )
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(
                        T::DbWeight::get().reads((1_u64).saturating_mul(i.into())),
                    )
                    .saturating_add(T::DbWeight::get().writes(1))
                    .saturating_add(
                        T::DbWeight::get().writes((1_u64).saturating_mul(i.into())),
                    )
                    .saturating_add(Weight::from_parts(0, 2597).saturating_mul(i.into()))
            }
            /// Storage: `Uniques::Asset` (r:1 w:1)
            /// Proof: `Uniques::Asset` (`max_values`: None, `max_size`: Some(122), added: 2597, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::Class` (r:1 w:0)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            fn freeze() -> Weight {
                Weight::from_parts(19_547_000, 0)
                    .saturating_add(Weight::from_parts(0, 3643))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Uniques::Asset` (r:1 w:1)
            /// Proof: `Uniques::Asset` (`max_values`: None, `max_size`: Some(122), added: 2597, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::Class` (r:1 w:0)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            fn thaw() -> Weight {
                Weight::from_parts(19_000_000, 0)
                    .saturating_add(Weight::from_parts(0, 3643))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Uniques::Class` (r:1 w:1)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            fn freeze_collection() -> Weight {
                Weight::from_parts(14_165_000, 0)
                    .saturating_add(Weight::from_parts(0, 3643))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Uniques::Class` (r:1 w:1)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            fn thaw_collection() -> Weight {
                Weight::from_parts(14_055_000, 0)
                    .saturating_add(Weight::from_parts(0, 3643))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Uniques::OwnershipAcceptance` (r:1 w:1)
            /// Proof: `Uniques::OwnershipAcceptance` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::Class` (r:1 w:1)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::ClassAccount` (r:0 w:2)
            /// Proof: `Uniques::ClassAccount` (`max_values`: None, `max_size`: Some(68), added: 2543, mode: `MaxEncodedLen`)
            fn transfer_ownership() -> Weight {
                Weight::from_parts(22_628_000, 0)
                    .saturating_add(Weight::from_parts(0, 3643))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(4))
            }
            /// Storage: `Uniques::Class` (r:1 w:1)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            fn set_team() -> Weight {
                Weight::from_parts(14_408_000, 0)
                    .saturating_add(Weight::from_parts(0, 3643))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Uniques::Class` (r:1 w:1)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::ClassAccount` (r:0 w:1)
            /// Proof: `Uniques::ClassAccount` (`max_values`: None, `max_size`: Some(68), added: 2543, mode: `MaxEncodedLen`)
            fn force_item_status() -> Weight {
                Weight::from_parts(17_482_000, 0)
                    .saturating_add(Weight::from_parts(0, 3643))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Uniques::Class` (r:1 w:1)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::InstanceMetadataOf` (r:1 w:0)
            /// Proof: `Uniques::InstanceMetadataOf` (`max_values`: None, `max_size`: Some(187), added: 2662, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::Attribute` (r:1 w:1)
            /// Proof: `Uniques::Attribute` (`max_values`: None, `max_size`: Some(172), added: 2647, mode: `MaxEncodedLen`)
            fn set_attribute() -> Weight {
                Weight::from_parts(39_513_000, 0)
                    .saturating_add(Weight::from_parts(0, 3652))
                    .saturating_add(T::DbWeight::get().reads(3))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Uniques::Class` (r:1 w:1)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::InstanceMetadataOf` (r:1 w:0)
            /// Proof: `Uniques::InstanceMetadataOf` (`max_values`: None, `max_size`: Some(187), added: 2662, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::Attribute` (r:1 w:1)
            /// Proof: `Uniques::Attribute` (`max_values`: None, `max_size`: Some(172), added: 2647, mode: `MaxEncodedLen`)
            fn clear_attribute() -> Weight {
                Weight::from_parts(38_666_000, 0)
                    .saturating_add(Weight::from_parts(0, 3652))
                    .saturating_add(T::DbWeight::get().reads(3))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Uniques::Class` (r:1 w:1)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::InstanceMetadataOf` (r:1 w:1)
            /// Proof: `Uniques::InstanceMetadataOf` (`max_values`: None, `max_size`: Some(187), added: 2662, mode: `MaxEncodedLen`)
            fn set_metadata() -> Weight {
                Weight::from_parts(30_363_000, 0)
                    .saturating_add(Weight::from_parts(0, 3652))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Uniques::Class` (r:1 w:1)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::InstanceMetadataOf` (r:1 w:1)
            /// Proof: `Uniques::InstanceMetadataOf` (`max_values`: None, `max_size`: Some(187), added: 2662, mode: `MaxEncodedLen`)
            fn clear_metadata() -> Weight {
                Weight::from_parts(31_430_000, 0)
                    .saturating_add(Weight::from_parts(0, 3652))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Uniques::Class` (r:1 w:1)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::ClassMetadataOf` (r:1 w:1)
            /// Proof: `Uniques::ClassMetadataOf` (`max_values`: None, `max_size`: Some(167), added: 2642, mode: `MaxEncodedLen`)
            fn set_collection_metadata() -> Weight {
                Weight::from_parts(31_065_000, 0)
                    .saturating_add(Weight::from_parts(0, 3643))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `Uniques::Class` (r:1 w:0)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::ClassMetadataOf` (r:1 w:1)
            /// Proof: `Uniques::ClassMetadataOf` (`max_values`: None, `max_size`: Some(167), added: 2642, mode: `MaxEncodedLen`)
            fn clear_collection_metadata() -> Weight {
                Weight::from_parts(30_160_000, 0)
                    .saturating_add(Weight::from_parts(0, 3643))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Uniques::Class` (r:1 w:0)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::Asset` (r:1 w:1)
            /// Proof: `Uniques::Asset` (`max_values`: None, `max_size`: Some(122), added: 2597, mode: `MaxEncodedLen`)
            fn approve_transfer() -> Weight {
                Weight::from_parts(19_866_000, 0)
                    .saturating_add(Weight::from_parts(0, 3643))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Uniques::Class` (r:1 w:0)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::Asset` (r:1 w:1)
            /// Proof: `Uniques::Asset` (`max_values`: None, `max_size`: Some(122), added: 2597, mode: `MaxEncodedLen`)
            fn cancel_approval() -> Weight {
                Weight::from_parts(19_569_000, 0)
                    .saturating_add(Weight::from_parts(0, 3643))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Uniques::OwnershipAcceptance` (r:1 w:1)
            /// Proof: `Uniques::OwnershipAcceptance` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
            fn set_accept_ownership() -> Weight {
                Weight::from_parts(15_691_000, 0)
                    .saturating_add(Weight::from_parts(0, 3517))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Uniques::CollectionMaxSupply` (r:1 w:1)
            /// Proof: `Uniques::CollectionMaxSupply` (`max_values`: None, `max_size`: Some(24), added: 2499, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::Class` (r:1 w:0)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            fn set_collection_max_supply() -> Weight {
                Weight::from_parts(16_654_000, 0)
                    .saturating_add(Weight::from_parts(0, 3643))
                    .saturating_add(T::DbWeight::get().reads(2))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Uniques::Asset` (r:1 w:0)
            /// Proof: `Uniques::Asset` (`max_values`: None, `max_size`: Some(122), added: 2597, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::ItemPriceOf` (r:0 w:1)
            /// Proof: `Uniques::ItemPriceOf` (`max_values`: None, `max_size`: Some(89), added: 2564, mode: `MaxEncodedLen`)
            fn set_price() -> Weight {
                Weight::from_parts(16_555_000, 0)
                    .saturating_add(Weight::from_parts(0, 3587))
                    .saturating_add(T::DbWeight::get().reads(1))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `Uniques::Asset` (r:1 w:1)
            /// Proof: `Uniques::Asset` (`max_values`: None, `max_size`: Some(122), added: 2597, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::ItemPriceOf` (r:1 w:1)
            /// Proof: `Uniques::ItemPriceOf` (`max_values`: None, `max_size`: Some(89), added: 2564, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::Class` (r:1 w:0)
            /// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(178), added: 2653, mode: `MaxEncodedLen`)
            /// Storage: `Uniques::Account` (r:0 w:2)
            /// Proof: `Uniques::Account` (`max_values`: None, `max_size`: Some(88), added: 2563, mode: `MaxEncodedLen`)
            fn buy_item() -> Weight {
                Weight::from_parts(36_305_000, 0)
                    .saturating_add(Weight::from_parts(0, 3643))
                    .saturating_add(T::DbWeight::get().reads(3))
                    .saturating_add(T::DbWeight::get().writes(4))
            }
        }
    }
    pub mod pallet_utility {
        //! Autogenerated weights for `pallet_utility`
        //!
        //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
        //! DATE: 2023-07-31, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
        //! WORST CASE MAP SIZE: `1000000`
        //! HOSTNAME: `runner-ynta1nyy-project-238-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
        //! EXECUTION: ``, WASM-EXECUTION: `Compiled`, CHAIN: `Some("asset-hub-kusama-dev")`, DB CACHE: 1024
        #![allow(unused_parens)]
        #![allow(unused_imports)]
        #![allow(missing_docs)]
        use frame_support::{traits::Get, weights::Weight};
        use core::marker::PhantomData;
        /// Weight functions for `pallet_utility`.
        pub struct WeightInfo<T>(PhantomData<T>);
        impl<T: frame_system::Config> pallet_utility::WeightInfo for WeightInfo<T> {
            /// The range of component `c` is `[0, 1000]`.
            fn batch(c: u32) -> Weight {
                Weight::from_parts(7_226_000, 0)
                    .saturating_add(Weight::from_parts(0, 0))
                    .saturating_add(
                        Weight::from_parts(6_560_347, 0).saturating_mul(c.into()),
                    )
            }
            fn as_derivative() -> Weight {
                Weight::from_parts(5_480_000, 0).saturating_add(Weight::from_parts(0, 0))
            }
            /// The range of component `c` is `[0, 1000]`.
            fn batch_all(c: u32) -> Weight {
                Weight::from_parts(1_321_270, 0)
                    .saturating_add(Weight::from_parts(0, 0))
                    .saturating_add(
                        Weight::from_parts(6_864_640, 0).saturating_mul(c.into()),
                    )
            }
            fn dispatch_as() -> Weight {
                Weight::from_parts(9_683_000, 0).saturating_add(Weight::from_parts(0, 0))
            }
            /// The range of component `c` is `[0, 1000]`.
            fn force_batch(c: u32) -> Weight {
                Weight::from_parts(7_007_000, 0)
                    .saturating_add(Weight::from_parts(0, 0))
                    .saturating_add(
                        Weight::from_parts(6_562_902, 0).saturating_mul(c.into()),
                    )
            }
        }
    }
    pub mod pallet_xcm {
        //! Autogenerated weights for `pallet_xcm`
        //!
        //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
        //! DATE: 2023-07-31, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
        //! WORST CASE MAP SIZE: `1000000`
        //! HOSTNAME: `runner-ynta1nyy-project-238-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
        //! EXECUTION: ``, WASM-EXECUTION: `Compiled`, CHAIN: `Some("asset-hub-kusama-dev")`, DB CACHE: 1024
        #![allow(unused_parens)]
        #![allow(unused_imports)]
        #![allow(missing_docs)]
        use frame_support::{traits::Get, weights::Weight};
        use core::marker::PhantomData;
        /// Weight functions for `pallet_xcm`.
        pub struct WeightInfo<T>(PhantomData<T>);
        impl<T: frame_system::Config> pallet_xcm::WeightInfo for WeightInfo<T> {
            /// Storage: `PolkadotXcm::SupportedVersion` (r:1 w:0)
            /// Proof: `PolkadotXcm::SupportedVersion` (`max_values`: None, `max_size`: None, mode: `Measured`)
            /// Storage: `PolkadotXcm::VersionDiscoveryQueue` (r:1 w:1)
            /// Proof: `PolkadotXcm::VersionDiscoveryQueue` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `PolkadotXcm::SafeXcmVersion` (r:1 w:0)
            /// Proof: `PolkadotXcm::SafeXcmVersion` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `ParachainSystem::HostConfiguration` (r:1 w:0)
            /// Proof: `ParachainSystem::HostConfiguration` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `ParachainSystem::PendingUpwardMessages` (r:1 w:1)
            /// Proof: `ParachainSystem::PendingUpwardMessages` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            fn send() -> Weight {
                Weight::from_parts(30_576_000, 0)
                    .saturating_add(Weight::from_parts(0, 3574))
                    .saturating_add(T::DbWeight::get().reads(5))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `ParachainInfo::ParachainId` (r:1 w:0)
            /// Proof: `ParachainInfo::ParachainId` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
            fn teleport_assets() -> Weight {
                Weight::from_parts(25_097_000, 0)
                    .saturating_add(Weight::from_parts(0, 1489))
                    .saturating_add(T::DbWeight::get().reads(1))
            }
            /// Storage: `ParachainInfo::ParachainId` (r:1 w:0)
            /// Proof: `ParachainInfo::ParachainId` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
            fn reserve_transfer_assets() -> Weight {
                Weight::from_parts(19_121_000, 0)
                    .saturating_add(Weight::from_parts(0, 1489))
                    .saturating_add(T::DbWeight::get().reads(1))
            }
            /// Storage: `Benchmark::Override` (r:0 w:0)
            /// Proof: `Benchmark::Override` (`max_values`: None, `max_size`: None, mode: `Measured`)
            fn execute() -> Weight {
                Weight::from_parts(18_446_744_073_709_551_000, 0)
                    .saturating_add(Weight::from_parts(0, 0))
            }
            /// Storage: `PolkadotXcm::SupportedVersion` (r:0 w:1)
            /// Proof: `PolkadotXcm::SupportedVersion` (`max_values`: None, `max_size`: None, mode: `Measured`)
            fn force_xcm_version() -> Weight {
                Weight::from_parts(9_721_000, 0)
                    .saturating_add(Weight::from_parts(0, 0))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `PolkadotXcm::SafeXcmVersion` (r:0 w:1)
            /// Proof: `PolkadotXcm::SafeXcmVersion` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            fn force_default_xcm_version() -> Weight {
                Weight::from_parts(3_262_000, 0)
                    .saturating_add(Weight::from_parts(0, 0))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `PolkadotXcm::VersionNotifiers` (r:1 w:1)
            /// Proof: `PolkadotXcm::VersionNotifiers` (`max_values`: None, `max_size`: None, mode: `Measured`)
            /// Storage: `PolkadotXcm::QueryCounter` (r:1 w:1)
            /// Proof: `PolkadotXcm::QueryCounter` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `PolkadotXcm::SupportedVersion` (r:1 w:0)
            /// Proof: `PolkadotXcm::SupportedVersion` (`max_values`: None, `max_size`: None, mode: `Measured`)
            /// Storage: `PolkadotXcm::VersionDiscoveryQueue` (r:1 w:1)
            /// Proof: `PolkadotXcm::VersionDiscoveryQueue` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `PolkadotXcm::SafeXcmVersion` (r:1 w:0)
            /// Proof: `PolkadotXcm::SafeXcmVersion` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `ParachainSystem::HostConfiguration` (r:1 w:0)
            /// Proof: `ParachainSystem::HostConfiguration` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `ParachainSystem::PendingUpwardMessages` (r:1 w:1)
            /// Proof: `ParachainSystem::PendingUpwardMessages` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `PolkadotXcm::Queries` (r:0 w:1)
            /// Proof: `PolkadotXcm::Queries` (`max_values`: None, `max_size`: None, mode: `Measured`)
            fn force_subscribe_version_notify() -> Weight {
                Weight::from_parts(36_317_000, 0)
                    .saturating_add(Weight::from_parts(0, 3574))
                    .saturating_add(T::DbWeight::get().reads(7))
                    .saturating_add(T::DbWeight::get().writes(5))
            }
            /// Storage: `PolkadotXcm::VersionNotifiers` (r:1 w:1)
            /// Proof: `PolkadotXcm::VersionNotifiers` (`max_values`: None, `max_size`: None, mode: `Measured`)
            /// Storage: `PolkadotXcm::SupportedVersion` (r:1 w:0)
            /// Proof: `PolkadotXcm::SupportedVersion` (`max_values`: None, `max_size`: None, mode: `Measured`)
            /// Storage: `PolkadotXcm::VersionDiscoveryQueue` (r:1 w:1)
            /// Proof: `PolkadotXcm::VersionDiscoveryQueue` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `PolkadotXcm::SafeXcmVersion` (r:1 w:0)
            /// Proof: `PolkadotXcm::SafeXcmVersion` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `ParachainSystem::HostConfiguration` (r:1 w:0)
            /// Proof: `ParachainSystem::HostConfiguration` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `ParachainSystem::PendingUpwardMessages` (r:1 w:1)
            /// Proof: `ParachainSystem::PendingUpwardMessages` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `PolkadotXcm::Queries` (r:0 w:1)
            /// Proof: `PolkadotXcm::Queries` (`max_values`: None, `max_size`: None, mode: `Measured`)
            fn force_unsubscribe_version_notify() -> Weight {
                Weight::from_parts(37_983_000, 0)
                    .saturating_add(Weight::from_parts(0, 3791))
                    .saturating_add(T::DbWeight::get().reads(6))
                    .saturating_add(T::DbWeight::get().writes(4))
            }
            /// Storage: `PolkadotXcm::XcmExecutionSuspended` (r:0 w:1)
            /// Proof: `PolkadotXcm::XcmExecutionSuspended` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            fn force_suspension() -> Weight {
                Weight::from_parts(3_085_000, 0)
                    .saturating_add(Weight::from_parts(0, 0))
                    .saturating_add(T::DbWeight::get().writes(1))
            }
            /// Storage: `PolkadotXcm::SupportedVersion` (r:4 w:2)
            /// Proof: `PolkadotXcm::SupportedVersion` (`max_values`: None, `max_size`: None, mode: `Measured`)
            fn migrate_supported_version() -> Weight {
                Weight::from_parts(17_759_000, 0)
                    .saturating_add(Weight::from_parts(0, 11052))
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `PolkadotXcm::VersionNotifiers` (r:4 w:2)
            /// Proof: `PolkadotXcm::VersionNotifiers` (`max_values`: None, `max_size`: None, mode: `Measured`)
            fn migrate_version_notifiers() -> Weight {
                Weight::from_parts(17_678_000, 0)
                    .saturating_add(Weight::from_parts(0, 11056))
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `PolkadotXcm::VersionNotifyTargets` (r:5 w:0)
            /// Proof: `PolkadotXcm::VersionNotifyTargets` (`max_values`: None, `max_size`: None, mode: `Measured`)
            fn already_notified_target() -> Weight {
                Weight::from_parts(19_285_000, 0)
                    .saturating_add(Weight::from_parts(0, 13538))
                    .saturating_add(T::DbWeight::get().reads(5))
            }
            /// Storage: `PolkadotXcm::VersionNotifyTargets` (r:2 w:1)
            /// Proof: `PolkadotXcm::VersionNotifyTargets` (`max_values`: None, `max_size`: None, mode: `Measured`)
            /// Storage: `PolkadotXcm::SupportedVersion` (r:1 w:0)
            /// Proof: `PolkadotXcm::SupportedVersion` (`max_values`: None, `max_size`: None, mode: `Measured`)
            /// Storage: `PolkadotXcm::VersionDiscoveryQueue` (r:1 w:1)
            /// Proof: `PolkadotXcm::VersionDiscoveryQueue` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `PolkadotXcm::SafeXcmVersion` (r:1 w:0)
            /// Proof: `PolkadotXcm::SafeXcmVersion` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `ParachainSystem::HostConfiguration` (r:1 w:0)
            /// Proof: `ParachainSystem::HostConfiguration` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `ParachainSystem::PendingUpwardMessages` (r:1 w:1)
            /// Proof: `ParachainSystem::PendingUpwardMessages` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            fn notify_current_targets() -> Weight {
                Weight::from_parts(33_533_000, 0)
                    .saturating_add(Weight::from_parts(0, 6116))
                    .saturating_add(T::DbWeight::get().reads(7))
                    .saturating_add(T::DbWeight::get().writes(3))
            }
            /// Storage: `PolkadotXcm::VersionNotifyTargets` (r:3 w:0)
            /// Proof: `PolkadotXcm::VersionNotifyTargets` (`max_values`: None, `max_size`: None, mode: `Measured`)
            fn notify_target_migration_fail() -> Weight {
                Weight::from_parts(9_498_000, 0)
                    .saturating_add(Weight::from_parts(0, 8621))
                    .saturating_add(T::DbWeight::get().reads(3))
            }
            /// Storage: `PolkadotXcm::VersionNotifyTargets` (r:4 w:2)
            /// Proof: `PolkadotXcm::VersionNotifyTargets` (`max_values`: None, `max_size`: None, mode: `Measured`)
            fn migrate_version_notify_targets() -> Weight {
                Weight::from_parts(17_943_000, 0)
                    .saturating_add(Weight::from_parts(0, 11063))
                    .saturating_add(T::DbWeight::get().reads(4))
                    .saturating_add(T::DbWeight::get().writes(2))
            }
            /// Storage: `PolkadotXcm::VersionNotifyTargets` (r:4 w:2)
            /// Proof: `PolkadotXcm::VersionNotifyTargets` (`max_values`: None, `max_size`: None, mode: `Measured`)
            /// Storage: `PolkadotXcm::SupportedVersion` (r:1 w:0)
            /// Proof: `PolkadotXcm::SupportedVersion` (`max_values`: None, `max_size`: None, mode: `Measured`)
            /// Storage: `PolkadotXcm::VersionDiscoveryQueue` (r:1 w:1)
            /// Proof: `PolkadotXcm::VersionDiscoveryQueue` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `PolkadotXcm::SafeXcmVersion` (r:1 w:0)
            /// Proof: `PolkadotXcm::SafeXcmVersion` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `ParachainSystem::HostConfiguration` (r:1 w:0)
            /// Proof: `ParachainSystem::HostConfiguration` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            /// Storage: `ParachainSystem::PendingUpwardMessages` (r:1 w:1)
            /// Proof: `ParachainSystem::PendingUpwardMessages` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
            fn migrate_and_notify_old_targets() -> Weight {
                Weight::from_parts(39_984_000, 0)
                    .saturating_add(Weight::from_parts(0, 11069))
                    .saturating_add(T::DbWeight::get().reads(9))
                    .saturating_add(T::DbWeight::get().writes(4))
            }
        }
    }
    pub mod paritydb_weights {
        pub mod constants {
            use frame_support::{parameter_types, weights::{constants, RuntimeDbWeight}};
            /// `ParityDB` can be enabled with a feature flag, but is still experimental. These weights
            /// are available for brave runtime engineers who may want to try this out as default.
            pub struct ParityDbWeight;
            impl ParityDbWeight {
                /// Returns the value of this parameter type.
                pub const fn get() -> RuntimeDbWeight {
                    RuntimeDbWeight {
                        read: 8_000 * constants::WEIGHT_REF_TIME_PER_NANOS,
                        write: 50_000 * constants::WEIGHT_REF_TIME_PER_NANOS,
                    }
                }
            }
            impl<_I: From<RuntimeDbWeight>> ::frame_support::traits::Get<_I>
            for ParityDbWeight {
                fn get() -> _I {
                    _I::from(Self::get())
                }
            }
            impl ::frame_support::traits::TypedGet for ParityDbWeight {
                type Type = RuntimeDbWeight;
                fn get() -> RuntimeDbWeight {
                    Self::get()
                }
            }
        }
    }
    pub mod rocksdb_weights {
        pub mod constants {
            use frame_support::{parameter_types, weights::{constants, RuntimeDbWeight}};
            /// By default, Substrate uses `RocksDB`, so this will be the weight used throughout
            /// the runtime.
            pub struct RocksDbWeight;
            impl RocksDbWeight {
                /// Returns the value of this parameter type.
                pub const fn get() -> RuntimeDbWeight {
                    RuntimeDbWeight {
                        read: 25_000 * constants::WEIGHT_REF_TIME_PER_NANOS,
                        write: 100_000 * constants::WEIGHT_REF_TIME_PER_NANOS,
                    }
                }
            }
            impl<_I: From<RuntimeDbWeight>> ::frame_support::traits::Get<_I>
            for RocksDbWeight {
                fn get() -> _I {
                    _I::from(Self::get())
                }
            }
            impl ::frame_support::traits::TypedGet for RocksDbWeight {
                type Type = RuntimeDbWeight;
                fn get() -> RuntimeDbWeight {
                    Self::get()
                }
            }
        }
    }
    pub mod xcm {
        mod pallet_xcm_benchmarks_fungible {
            //! Autogenerated weights for `pallet_xcm_benchmarks::fungible`
            //!
            //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
            //! DATE: 2023-09-28, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
            //! WORST CASE MAP SIZE: `1000000`
            //! HOSTNAME: `runner-nbnwcyh-project-674-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
            //! WASM-EXECUTION: Compiled, CHAIN: Some("asset-hub-kusama-dev"), DB CACHE: 1024
            #![allow(unused_parens)]
            #![allow(unused_imports)]
            use frame_support::{traits::Get, weights::Weight};
            use sp_std::marker::PhantomData;
            /// Weights for `pallet_xcm_benchmarks::fungible`.
            pub struct WeightInfo<T>(PhantomData<T>);
            impl<T: frame_system::Config> WeightInfo<T> {
                pub fn withdraw_asset() -> Weight {
                    Weight::from_parts(26_312_000, 3593)
                        .saturating_add(T::DbWeight::get().reads(1))
                        .saturating_add(T::DbWeight::get().writes(1))
                }
                pub fn transfer_asset() -> Weight {
                    Weight::from_parts(52_221_000, 6196)
                        .saturating_add(T::DbWeight::get().reads(2))
                        .saturating_add(T::DbWeight::get().writes(2))
                }
                pub fn transfer_reserve_asset() -> Weight {
                    Weight::from_parts(76_500_000, 6196)
                        .saturating_add(T::DbWeight::get().reads(8))
                        .saturating_add(T::DbWeight::get().writes(4))
                }
                pub fn reserve_asset_deposited() -> Weight {
                    Weight::from_parts(18_446_744_073_709_551_000, 0)
                }
                pub fn initiate_reserve_withdraw() -> Weight {
                    Weight::from_parts(470_470_000, 3610)
                        .saturating_add(T::DbWeight::get().reads(6))
                        .saturating_add(T::DbWeight::get().writes(2))
                }
                pub fn receive_teleported_asset() -> Weight {
                    Weight::from_parts(3_887_000, 0)
                }
                pub fn deposit_asset() -> Weight {
                    Weight::from_parts(26_320_000, 3593)
                        .saturating_add(T::DbWeight::get().reads(1))
                        .saturating_add(T::DbWeight::get().writes(1))
                }
                pub fn deposit_reserve_asset() -> Weight {
                    Weight::from_parts(52_538_000, 3610)
                        .saturating_add(T::DbWeight::get().reads(7))
                        .saturating_add(T::DbWeight::get().writes(3))
                }
                pub fn initiate_teleport() -> Weight {
                    Weight::from_parts(32_834_000, 3610)
                        .saturating_add(T::DbWeight::get().reads(6))
                        .saturating_add(T::DbWeight::get().writes(2))
                }
            }
        }
        mod pallet_xcm_benchmarks_generic {
            //! Autogenerated weights for `pallet_xcm_benchmarks::generic`
            //!
            //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
            //! DATE: 2023-07-31, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
            //! WORST CASE MAP SIZE: `1000000`
            //! HOSTNAME: `runner-ynta1nyy-project-238-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
            //! EXECUTION: , WASM-EXECUTION: Compiled, CHAIN: Some("asset-hub-kusama-dev"), DB CACHE: 1024
            #![allow(unused_parens)]
            #![allow(unused_imports)]
            use frame_support::{traits::Get, weights::Weight};
            use sp_std::marker::PhantomData;
            /// Weights for `pallet_xcm_benchmarks::generic`.
            pub struct WeightInfo<T>(PhantomData<T>);
            impl<T: frame_system::Config> WeightInfo<T> {
                pub fn report_holding() -> Weight {
                    Weight::from_parts(438_017_000, 3574)
                        .saturating_add(T::DbWeight::get().reads(6))
                        .saturating_add(T::DbWeight::get().writes(2))
                }
                pub fn buy_execution() -> Weight {
                    Weight::from_parts(4_412_000, 0)
                }
                pub fn query_response() -> Weight {
                    Weight::from_parts(11_830_000, 3568)
                        .saturating_add(T::DbWeight::get().reads(1))
                }
                pub fn transact() -> Weight {
                    Weight::from_parts(14_320_000, 0)
                }
                pub fn refund_surplus() -> Weight {
                    Weight::from_parts(4_709_000, 0)
                }
                pub fn set_error_handler() -> Weight {
                    Weight::from_parts(3_151_000, 0)
                }
                pub fn set_appendix() -> Weight {
                    Weight::from_parts(3_076_000, 0)
                }
                pub fn clear_error() -> Weight {
                    Weight::from_parts(3_119_000, 0)
                }
                pub fn descend_origin() -> Weight {
                    Weight::from_parts(3_853_000, 0)
                }
                pub fn clear_origin() -> Weight {
                    Weight::from_parts(3_050_000, 0)
                }
                pub fn report_error() -> Weight {
                    Weight::from_parts(28_351_000, 3574)
                        .saturating_add(T::DbWeight::get().reads(6))
                        .saturating_add(T::DbWeight::get().writes(2))
                }
                pub fn claim_asset() -> Weight {
                    Weight::from_parts(16_846_000, 3625)
                        .saturating_add(T::DbWeight::get().reads(1))
                        .saturating_add(T::DbWeight::get().writes(1))
                }
                pub fn trap() -> Weight {
                    Weight::from_parts(3_108_000, 0)
                }
                pub fn subscribe_version() -> Weight {
                    Weight::from_parts(30_776_000, 3574)
                        .saturating_add(T::DbWeight::get().reads(6))
                        .saturating_add(T::DbWeight::get().writes(3))
                }
                pub fn unsubscribe_version() -> Weight {
                    Weight::from_parts(5_157_000, 0)
                        .saturating_add(T::DbWeight::get().writes(1))
                }
                pub fn burn_asset() -> Weight {
                    Weight::from_parts(144_925_000, 0)
                }
                pub fn expect_asset() -> Weight {
                    Weight::from_parts(13_420_000, 0)
                }
                pub fn expect_origin() -> Weight {
                    Weight::from_parts(3_161_000, 0)
                }
                pub fn expect_error() -> Weight {
                    Weight::from_parts(3_077_000, 0)
                }
                pub fn expect_transact_status() -> Weight {
                    Weight::from_parts(3_299_000, 0)
                }
                pub fn query_pallet() -> Weight {
                    Weight::from_parts(32_462_000, 3574)
                        .saturating_add(T::DbWeight::get().reads(6))
                        .saturating_add(T::DbWeight::get().writes(2))
                }
                pub fn expect_pallet() -> Weight {
                    Weight::from_parts(5_756_000, 0)
                }
                pub fn report_transact_status() -> Weight {
                    Weight::from_parts(28_240_000, 3574)
                        .saturating_add(T::DbWeight::get().reads(6))
                        .saturating_add(T::DbWeight::get().writes(2))
                }
                pub fn clear_transact_status() -> Weight {
                    Weight::from_parts(3_097_000, 0)
                }
                pub fn set_topic() -> Weight {
                    Weight::from_parts(2_957_000, 0)
                }
                pub fn clear_topic() -> Weight {
                    Weight::from_parts(3_015_000, 0)
                }
                pub fn set_fees_mode() -> Weight {
                    Weight::from_parts(3_060_000, 0)
                }
                pub fn unpaid_execution() -> Weight {
                    Weight::from_parts(3_158_000, 0)
                }
            }
        }
        use crate::{xcm_config::MaxAssetsIntoHolding, Runtime};
        use frame_support::weights::Weight;
        use pallet_xcm_benchmarks_fungible::WeightInfo as XcmFungibleWeight;
        use pallet_xcm_benchmarks_generic::WeightInfo as XcmGeneric;
        use sp_std::prelude::*;
        use xcm::{latest::prelude::*, DoubleEncoded};
        trait WeighMultiAssets {
            fn weigh_multi_assets(&self, weight: Weight) -> Weight;
        }
        const MAX_ASSETS: u64 = 100;
        impl WeighMultiAssets for MultiAssetFilter {
            fn weigh_multi_assets(&self, weight: Weight) -> Weight {
                match self {
                    Self::Definite(assets) => {
                        weight.saturating_mul(assets.inner().iter().count() as u64)
                    }
                    Self::Wild(asset) => {
                        match asset {
                            All => weight.saturating_mul(MAX_ASSETS),
                            AllOf { fun, .. } => {
                                match fun {
                                    WildFungibility::Fungible => weight,
                                    WildFungibility::NonFungible => {
                                        weight
                                            .saturating_mul((MaxAssetsIntoHolding::get() * 2) as u64)
                                    }
                                }
                            }
                            AllCounted(count) => {
                                weight.saturating_mul(MAX_ASSETS.min(*count as u64))
                            }
                            AllOfCounted { count, .. } => {
                                weight.saturating_mul(MAX_ASSETS.min(*count as u64))
                            }
                        }
                    }
                }
            }
        }
        impl WeighMultiAssets for MultiAssets {
            fn weigh_multi_assets(&self, weight: Weight) -> Weight {
                weight.saturating_mul(self.inner().iter().count() as u64)
            }
        }
        pub struct AssetHubKusamaXcmWeight<Call>(core::marker::PhantomData<Call>);
        impl<Call> XcmWeightInfo<Call> for AssetHubKusamaXcmWeight<Call> {
            fn withdraw_asset(assets: &MultiAssets) -> Weight {
                assets.weigh_multi_assets(XcmFungibleWeight::<Runtime>::withdraw_asset())
            }
            fn reserve_asset_deposited(assets: &MultiAssets) -> Weight {
                assets
                    .weigh_multi_assets(
                        XcmFungibleWeight::<Runtime>::reserve_asset_deposited(),
                    )
            }
            fn receive_teleported_asset(assets: &MultiAssets) -> Weight {
                assets
                    .weigh_multi_assets(
                        XcmFungibleWeight::<Runtime>::receive_teleported_asset(),
                    )
            }
            fn query_response(
                _query_id: &u64,
                _response: &Response,
                _max_weight: &Weight,
                _querier: &Option<MultiLocation>,
            ) -> Weight {
                XcmGeneric::<Runtime>::query_response()
            }
            fn transfer_asset(assets: &MultiAssets, _dest: &MultiLocation) -> Weight {
                assets.weigh_multi_assets(XcmFungibleWeight::<Runtime>::transfer_asset())
            }
            fn transfer_reserve_asset(
                assets: &MultiAssets,
                _dest: &MultiLocation,
                _xcm: &Xcm<()>,
            ) -> Weight {
                assets
                    .weigh_multi_assets(
                        XcmFungibleWeight::<Runtime>::transfer_reserve_asset(),
                    )
            }
            fn transact(
                _origin_type: &OriginKind,
                _require_weight_at_most: &Weight,
                _call: &DoubleEncoded<Call>,
            ) -> Weight {
                XcmGeneric::<Runtime>::transact()
            }
            fn hrmp_new_channel_open_request(
                _sender: &u32,
                _max_message_size: &u32,
                _max_capacity: &u32,
            ) -> Weight {
                Weight::MAX
            }
            fn hrmp_channel_accepted(_recipient: &u32) -> Weight {
                Weight::MAX
            }
            fn hrmp_channel_closing(
                _initiator: &u32,
                _sender: &u32,
                _recipient: &u32,
            ) -> Weight {
                Weight::MAX
            }
            fn clear_origin() -> Weight {
                XcmGeneric::<Runtime>::clear_origin()
            }
            fn descend_origin(_who: &InteriorMultiLocation) -> Weight {
                XcmGeneric::<Runtime>::descend_origin()
            }
            fn report_error(_query_response_info: &QueryResponseInfo) -> Weight {
                XcmGeneric::<Runtime>::report_error()
            }
            fn deposit_asset(
                assets: &MultiAssetFilter,
                _dest: &MultiLocation,
            ) -> Weight {
                assets.weigh_multi_assets(XcmFungibleWeight::<Runtime>::deposit_asset())
            }
            fn deposit_reserve_asset(
                assets: &MultiAssetFilter,
                _dest: &MultiLocation,
                _xcm: &Xcm<()>,
            ) -> Weight {
                assets
                    .weigh_multi_assets(
                        XcmFungibleWeight::<Runtime>::deposit_reserve_asset(),
                    )
            }
            fn exchange_asset(
                _give: &MultiAssetFilter,
                _receive: &MultiAssets,
                _maximal: &bool,
            ) -> Weight {
                Weight::MAX
            }
            fn initiate_reserve_withdraw(
                assets: &MultiAssetFilter,
                _reserve: &MultiLocation,
                _xcm: &Xcm<()>,
            ) -> Weight {
                assets
                    .weigh_multi_assets(
                        XcmFungibleWeight::<Runtime>::initiate_reserve_withdraw(),
                    )
            }
            fn initiate_teleport(
                assets: &MultiAssetFilter,
                _dest: &MultiLocation,
                _xcm: &Xcm<()>,
            ) -> Weight {
                assets
                    .weigh_multi_assets(
                        XcmFungibleWeight::<Runtime>::initiate_teleport(),
                    )
            }
            fn report_holding(
                _response_info: &QueryResponseInfo,
                _assets: &MultiAssetFilter,
            ) -> Weight {
                XcmGeneric::<Runtime>::report_holding()
            }
            fn buy_execution(_fees: &MultiAsset, _weight_limit: &WeightLimit) -> Weight {
                XcmGeneric::<Runtime>::buy_execution()
            }
            fn refund_surplus() -> Weight {
                XcmGeneric::<Runtime>::refund_surplus()
            }
            fn set_error_handler(_xcm: &Xcm<Call>) -> Weight {
                XcmGeneric::<Runtime>::set_error_handler()
            }
            fn set_appendix(_xcm: &Xcm<Call>) -> Weight {
                XcmGeneric::<Runtime>::set_appendix()
            }
            fn clear_error() -> Weight {
                XcmGeneric::<Runtime>::clear_error()
            }
            fn claim_asset(_assets: &MultiAssets, _ticket: &MultiLocation) -> Weight {
                XcmGeneric::<Runtime>::claim_asset()
            }
            fn trap(_code: &u64) -> Weight {
                XcmGeneric::<Runtime>::trap()
            }
            fn subscribe_version(
                _query_id: &QueryId,
                _max_response_weight: &Weight,
            ) -> Weight {
                XcmGeneric::<Runtime>::subscribe_version()
            }
            fn unsubscribe_version() -> Weight {
                XcmGeneric::<Runtime>::unsubscribe_version()
            }
            fn burn_asset(assets: &MultiAssets) -> Weight {
                assets.weigh_multi_assets(XcmGeneric::<Runtime>::burn_asset())
            }
            fn expect_asset(assets: &MultiAssets) -> Weight {
                assets.weigh_multi_assets(XcmGeneric::<Runtime>::expect_asset())
            }
            fn expect_origin(_origin: &Option<MultiLocation>) -> Weight {
                XcmGeneric::<Runtime>::expect_origin()
            }
            fn expect_error(_error: &Option<(u32, XcmError)>) -> Weight {
                XcmGeneric::<Runtime>::expect_error()
            }
            fn expect_transact_status(_transact_status: &MaybeErrorCode) -> Weight {
                XcmGeneric::<Runtime>::expect_transact_status()
            }
            fn query_pallet(
                _module_name: &Vec<u8>,
                _response_info: &QueryResponseInfo,
            ) -> Weight {
                XcmGeneric::<Runtime>::query_pallet()
            }
            fn expect_pallet(
                _index: &u32,
                _name: &Vec<u8>,
                _module_name: &Vec<u8>,
                _crate_major: &u32,
                _min_crate_minor: &u32,
            ) -> Weight {
                XcmGeneric::<Runtime>::expect_pallet()
            }
            fn report_transact_status(_response_info: &QueryResponseInfo) -> Weight {
                XcmGeneric::<Runtime>::report_transact_status()
            }
            fn clear_transact_status() -> Weight {
                XcmGeneric::<Runtime>::clear_transact_status()
            }
            fn universal_origin(_: &Junction) -> Weight {
                Weight::MAX
            }
            fn export_message(_: &NetworkId, _: &Junctions, _: &Xcm<()>) -> Weight {
                Weight::MAX
            }
            fn lock_asset(_: &MultiAsset, _: &MultiLocation) -> Weight {
                Weight::MAX
            }
            fn unlock_asset(_: &MultiAsset, _: &MultiLocation) -> Weight {
                Weight::MAX
            }
            fn note_unlockable(_: &MultiAsset, _: &MultiLocation) -> Weight {
                Weight::MAX
            }
            fn request_unlock(_: &MultiAsset, _: &MultiLocation) -> Weight {
                Weight::MAX
            }
            fn set_fees_mode(_: &bool) -> Weight {
                XcmGeneric::<Runtime>::set_fees_mode()
            }
            fn set_topic(_topic: &[u8; 32]) -> Weight {
                XcmGeneric::<Runtime>::set_topic()
            }
            fn clear_topic() -> Weight {
                XcmGeneric::<Runtime>::clear_topic()
            }
            fn alias_origin(_: &MultiLocation) -> Weight {
                Weight::MAX
            }
            fn unpaid_execution(_: &WeightLimit, _: &Option<MultiLocation>) -> Weight {
                XcmGeneric::<Runtime>::unpaid_execution()
            }
        }
    }
    pub use block_weights::constants::BlockExecutionWeight;
    pub use extrinsic_weights::constants::ExtrinsicBaseWeight;
    pub use paritydb_weights::constants::ParityDbWeight;
    pub use rocksdb_weights::constants::RocksDbWeight;
}
pub mod xcm_config {
    use super::{
        AccountId, AllPalletsWithSystem, Assets, Authorship, Balance, Balances,
        ParachainInfo, ParachainSystem, PolkadotXcm, PoolAssets, Runtime, RuntimeCall,
        RuntimeEvent, RuntimeOrigin, TrustBackedAssetsInstance, WeightToFee, XcmpQueue,
    };
    use crate::ForeignAssets;
    use assets_common::{
        local_and_foreign_assets::MatchesLocalAndForeignAssetsMultiLocation,
        matching::{FromSiblingParachain, IsForeignConcreteAsset},
    };
    use frame_support::{
        match_types, parameter_types,
        traits::{ConstU32, Contains, Everything, Nothing, PalletInfoAccess},
    };
    use frame_system::EnsureRoot;
    use pallet_xcm::XcmPassthrough;
    use parachains_common::{
        impls::ToStakingPot,
        xcm_config::{AssetFeeAsExistentialDepositMultiplier, ConcreteAssetFromSystem},
    };
    use polkadot_parachain_primitives::primitives::Sibling;
    use sp_runtime::traits::ConvertInto;
    use xcm::latest::prelude::*;
    use xcm_builder::{
        AccountId32Aliases, AllowExplicitUnpaidExecutionFrom, AllowKnownQueryResponses,
        AllowSubscriptionsFrom, AllowTopLevelPaidExecutionFrom, CurrencyAdapter,
        DenyReserveTransferToRelayChain, DenyThenTry, DescribeAllTerminal,
        DescribeFamily, EnsureXcmOrigin, FungiblesAdapter, HashedDescription, IsConcrete,
        LocalMint, NoChecking, ParentAsSuperuser, ParentIsPreset, RelayChainAsNative,
        SiblingParachainAsNative, SiblingParachainConvertsVia, SignedAccountId32AsNative,
        SignedToAccountId32, SovereignSignedViaLocation, StartsWith,
        StartsWithExplicitGlobalConsensus, TakeWeightCredit, TrailingSetTopicAsId,
        UsingComponents, WeightInfoBounds, WithComputedOrigin, WithUniqueTopic,
    };
    use xcm_executor::{traits::WithOriginFilter, XcmExecutor};
    pub struct KsmLocation;
    impl KsmLocation {
        /// Returns the value of this parameter type.
        pub const fn get() -> MultiLocation {
            MultiLocation::parent()
        }
    }
    impl<_I: From<MultiLocation>> ::frame_support::traits::Get<_I> for KsmLocation {
        fn get() -> _I {
            _I::from(Self::get())
        }
    }
    impl ::frame_support::traits::TypedGet for KsmLocation {
        type Type = MultiLocation;
        fn get() -> MultiLocation {
            Self::get()
        }
    }
    pub struct RelayNetwork;
    impl RelayNetwork {
        /// Returns the value of this parameter type.
        pub const fn get() -> Option<NetworkId> {
            Some(NetworkId::Kusama)
        }
    }
    impl<_I: From<Option<NetworkId>>> ::frame_support::traits::Get<_I> for RelayNetwork {
        fn get() -> _I {
            _I::from(Self::get())
        }
    }
    impl ::frame_support::traits::TypedGet for RelayNetwork {
        type Type = Option<NetworkId>;
        fn get() -> Option<NetworkId> {
            Self::get()
        }
    }
    pub struct RelayChainOrigin;
    impl RelayChainOrigin {
        /// Returns the value of this parameter type.
        pub fn get() -> RuntimeOrigin {
            cumulus_pallet_xcm::Origin::Relay.into()
        }
    }
    impl<_I: From<RuntimeOrigin>> ::frame_support::traits::Get<_I> for RelayChainOrigin {
        fn get() -> _I {
            _I::from(Self::get())
        }
    }
    impl ::frame_support::traits::TypedGet for RelayChainOrigin {
        type Type = RuntimeOrigin;
        fn get() -> RuntimeOrigin {
            Self::get()
        }
    }
    pub struct UniversalLocation;
    impl UniversalLocation {
        /// Returns the value of this parameter type.
        pub fn get() -> InteriorMultiLocation {
            X2(
                GlobalConsensus(RelayNetwork::get().unwrap()),
                Parachain(ParachainInfo::parachain_id().into()),
            )
        }
    }
    impl<_I: From<InteriorMultiLocation>> ::frame_support::traits::Get<_I>
    for UniversalLocation {
        fn get() -> _I {
            _I::from(Self::get())
        }
    }
    impl ::frame_support::traits::TypedGet for UniversalLocation {
        type Type = InteriorMultiLocation;
        fn get() -> InteriorMultiLocation {
            Self::get()
        }
    }
    pub struct UniversalLocationNetworkId;
    impl UniversalLocationNetworkId {
        /// Returns the value of this parameter type.
        pub fn get() -> NetworkId {
            UniversalLocation::get().global_consensus().unwrap()
        }
    }
    impl<_I: From<NetworkId>> ::frame_support::traits::Get<_I>
    for UniversalLocationNetworkId {
        fn get() -> _I {
            _I::from(Self::get())
        }
    }
    impl ::frame_support::traits::TypedGet for UniversalLocationNetworkId {
        type Type = NetworkId;
        fn get() -> NetworkId {
            Self::get()
        }
    }
    pub struct TrustBackedAssetsPalletLocation;
    impl TrustBackedAssetsPalletLocation {
        /// Returns the value of this parameter type.
        pub fn get() -> MultiLocation {
            PalletInstance(<Assets as PalletInfoAccess>::index() as u8).into()
        }
    }
    impl<_I: From<MultiLocation>> ::frame_support::traits::Get<_I>
    for TrustBackedAssetsPalletLocation {
        fn get() -> _I {
            _I::from(Self::get())
        }
    }
    impl ::frame_support::traits::TypedGet for TrustBackedAssetsPalletLocation {
        type Type = MultiLocation;
        fn get() -> MultiLocation {
            Self::get()
        }
    }
    pub struct ForeignAssetsPalletLocation;
    impl ForeignAssetsPalletLocation {
        /// Returns the value of this parameter type.
        pub fn get() -> MultiLocation {
            PalletInstance(<ForeignAssets as PalletInfoAccess>::index() as u8).into()
        }
    }
    impl<_I: From<MultiLocation>> ::frame_support::traits::Get<_I>
    for ForeignAssetsPalletLocation {
        fn get() -> _I {
            _I::from(Self::get())
        }
    }
    impl ::frame_support::traits::TypedGet for ForeignAssetsPalletLocation {
        type Type = MultiLocation;
        fn get() -> MultiLocation {
            Self::get()
        }
    }
    pub struct PoolAssetsPalletLocation;
    impl PoolAssetsPalletLocation {
        /// Returns the value of this parameter type.
        pub fn get() -> MultiLocation {
            PalletInstance(<PoolAssets as PalletInfoAccess>::index() as u8).into()
        }
    }
    impl<_I: From<MultiLocation>> ::frame_support::traits::Get<_I>
    for PoolAssetsPalletLocation {
        fn get() -> _I {
            _I::from(Self::get())
        }
    }
    impl ::frame_support::traits::TypedGet for PoolAssetsPalletLocation {
        type Type = MultiLocation;
        fn get() -> MultiLocation {
            Self::get()
        }
    }
    pub struct CheckingAccount;
    impl CheckingAccount {
        /// Returns the value of this parameter type.
        pub fn get() -> AccountId {
            PolkadotXcm::check_account()
        }
    }
    impl<_I: From<AccountId>> ::frame_support::traits::Get<_I> for CheckingAccount {
        fn get() -> _I {
            _I::from(Self::get())
        }
    }
    impl ::frame_support::traits::TypedGet for CheckingAccount {
        type Type = AccountId;
        fn get() -> AccountId {
            Self::get()
        }
    }
    pub struct GovernanceLocation;
    impl GovernanceLocation {
        /// Returns the value of this parameter type.
        pub const fn get() -> MultiLocation {
            MultiLocation::parent()
        }
    }
    impl<_I: From<MultiLocation>> ::frame_support::traits::Get<_I>
    for GovernanceLocation {
        fn get() -> _I {
            _I::from(Self::get())
        }
    }
    impl ::frame_support::traits::TypedGet for GovernanceLocation {
        type Type = MultiLocation;
        fn get() -> MultiLocation {
            Self::get()
        }
    }
    pub struct FellowshipLocation;
    impl FellowshipLocation {
        /// Returns the value of this parameter type.
        pub const fn get() -> MultiLocation {
            MultiLocation::parent()
        }
    }
    impl<_I: From<MultiLocation>> ::frame_support::traits::Get<_I>
    for FellowshipLocation {
        fn get() -> _I {
            _I::from(Self::get())
        }
    }
    impl ::frame_support::traits::TypedGet for FellowshipLocation {
        type Type = MultiLocation;
        fn get() -> MultiLocation {
            Self::get()
        }
    }
    /// Type for specifying how a `MultiLocation` can be converted into an `AccountId`. This is used
    /// when determining ownership of accounts for asset transacting and when attempting to use XCM
    /// `Transact` in order to determine the dispatch Origin.
    pub type LocationToAccountId = (
        ParentIsPreset<AccountId>,
        SiblingParachainConvertsVia<Sibling, AccountId>,
        AccountId32Aliases<RelayNetwork, AccountId>,
        HashedDescription<AccountId, DescribeFamily<DescribeAllTerminal>>,
    );
    /// Means for transacting the native currency on this chain.
    pub type CurrencyTransactor = CurrencyAdapter<
        Balances,
        IsConcrete<KsmLocation>,
        LocationToAccountId,
        AccountId,
        (),
    >;
    /// `AssetId`/`Balance` converter for `PoolAssets`.
    pub type TrustBackedAssetsConvertedConcreteId = assets_common::TrustBackedAssetsConvertedConcreteId<
        TrustBackedAssetsPalletLocation,
        Balance,
    >;
    /// Means for transacting assets besides the native currency on this chain.
    pub type FungiblesTransactor = FungiblesAdapter<
        Assets,
        TrustBackedAssetsConvertedConcreteId,
        LocationToAccountId,
        AccountId,
        LocalMint<parachains_common::impls::NonZeroIssuance<AccountId, Assets>>,
        CheckingAccount,
    >;
    /// `AssetId/Balance` converter for `TrustBackedAssets`
    pub type ForeignAssetsConvertedConcreteId = assets_common::ForeignAssetsConvertedConcreteId<
        (
            StartsWith<TrustBackedAssetsPalletLocation>,
            StartsWithExplicitGlobalConsensus<UniversalLocationNetworkId>,
        ),
        Balance,
    >;
    /// Means for transacting foreign assets from different global consensus.
    pub type ForeignFungiblesTransactor = FungiblesAdapter<
        ForeignAssets,
        ForeignAssetsConvertedConcreteId,
        LocationToAccountId,
        AccountId,
        NoChecking,
        CheckingAccount,
    >;
    /// `AssetId`/`Balance` converter for `PoolAssets`.
    pub type PoolAssetsConvertedConcreteId = assets_common::PoolAssetsConvertedConcreteId<
        PoolAssetsPalletLocation,
        Balance,
    >;
    /// Means for transacting asset conversion pool assets on this chain.
    pub type PoolFungiblesTransactor = FungiblesAdapter<
        PoolAssets,
        PoolAssetsConvertedConcreteId,
        LocationToAccountId,
        AccountId,
        LocalMint<parachains_common::impls::NonZeroIssuance<AccountId, PoolAssets>>,
        CheckingAccount,
    >;
    /// Means for transacting assets on this chain.
    pub type AssetTransactors = (
        CurrencyTransactor,
        FungiblesTransactor,
        ForeignFungiblesTransactor,
        PoolFungiblesTransactor,
    );
    /// Simple `MultiLocation` matcher for Local and Foreign asset `MultiLocation`.
    pub struct LocalAndForeignAssetsMultiLocationMatcher;
    impl MatchesLocalAndForeignAssetsMultiLocation
    for LocalAndForeignAssetsMultiLocationMatcher {
        fn is_local(location: &MultiLocation) -> bool {
            use assets_common::fungible_conversion::MatchesMultiLocation;
            TrustBackedAssetsConvertedConcreteId::contains(location)
        }
        fn is_foreign(location: &MultiLocation) -> bool {
            use assets_common::fungible_conversion::MatchesMultiLocation;
            ForeignAssetsConvertedConcreteId::contains(location)
        }
    }
    impl Contains<MultiLocation> for LocalAndForeignAssetsMultiLocationMatcher {
        fn contains(location: &MultiLocation) -> bool {
            Self::is_local(location) || Self::is_foreign(location)
        }
    }
    /// This is the type we use to convert an (incoming) XCM origin into a local `Origin` instance,
    /// ready for dispatching a transaction with Xcm's `Transact`. There is an `OriginKind` which can
    /// biases the kind of local `Origin` it will become.
    pub type XcmOriginToTransactDispatchOrigin = (
        SovereignSignedViaLocation<LocationToAccountId, RuntimeOrigin>,
        RelayChainAsNative<RelayChainOrigin, RuntimeOrigin>,
        SiblingParachainAsNative<cumulus_pallet_xcm::Origin, RuntimeOrigin>,
        ParentAsSuperuser<RuntimeOrigin>,
        SignedAccountId32AsNative<RelayNetwork, RuntimeOrigin>,
        XcmPassthrough<RuntimeOrigin>,
    );
    pub struct MaxInstructions;
    impl MaxInstructions {
        /// Returns the value of this parameter type.
        pub const fn get() -> u32 {
            100
        }
    }
    impl<_I: From<u32>> ::frame_support::traits::Get<_I> for MaxInstructions {
        fn get() -> _I {
            _I::from(Self::get())
        }
    }
    impl ::frame_support::traits::TypedGet for MaxInstructions {
        type Type = u32;
        fn get() -> u32 {
            Self::get()
        }
    }
    pub struct MaxAssetsIntoHolding;
    impl MaxAssetsIntoHolding {
        /// Returns the value of this parameter type.
        pub const fn get() -> u32 {
            64
        }
    }
    impl<_I: From<u32>> ::frame_support::traits::Get<_I> for MaxAssetsIntoHolding {
        fn get() -> _I {
            _I::from(Self::get())
        }
    }
    impl ::frame_support::traits::TypedGet for MaxAssetsIntoHolding {
        type Type = u32;
        fn get() -> u32 {
            Self::get()
        }
    }
    pub struct XcmAssetFeesReceiver;
    impl XcmAssetFeesReceiver {
        /// Returns the value of this parameter type.
        pub fn get() -> Option<AccountId> {
            Authorship::author()
        }
    }
    impl<_I: From<Option<AccountId>>> ::frame_support::traits::Get<_I>
    for XcmAssetFeesReceiver {
        fn get() -> _I {
            _I::from(Self::get())
        }
    }
    impl ::frame_support::traits::TypedGet for XcmAssetFeesReceiver {
        type Type = Option<AccountId>;
        fn get() -> Option<AccountId> {
            Self::get()
        }
    }
    pub struct ParentOrParentsPlurality;
    impl ::frame_support::traits::Contains<MultiLocation> for ParentOrParentsPlurality {
        fn contains(l: &MultiLocation) -> bool {
            match l {
                MultiLocation { parents: 1, interior: Here }
                | MultiLocation { parents: 1, interior: X1(Plurality { .. }) } => true,
                _ => false,
            }
        }
    }
    pub struct ParentOrSiblings;
    impl ::frame_support::traits::Contains<MultiLocation> for ParentOrSiblings {
        fn contains(l: &MultiLocation) -> bool {
            match l {
                MultiLocation { parents: 1, interior: Here }
                | MultiLocation { parents: 1, interior: X1(_) } => true,
                _ => false,
            }
        }
    }
    /// A call filter for the XCM Transact instruction. This is a temporary measure until we properly
    /// account for proof size weights.
    ///
    /// Calls that are allowed through this filter must:
    /// 1. Have a fixed weight;
    /// 2. Cannot lead to another call being made;
    /// 3. Have a defined proof size weight, e.g. no unbounded vecs in call parameters.
    pub struct SafeCallFilter;
    impl Contains<RuntimeCall> for SafeCallFilter {
        fn contains(call: &RuntimeCall) -> bool {
            match call {
                RuntimeCall::PolkadotXcm(pallet_xcm::Call::force_xcm_version { .. })
                | RuntimeCall::System(
                    frame_system::Call::set_heap_pages { .. }
                    | frame_system::Call::set_code { .. }
                    | frame_system::Call::set_code_without_checks { .. }
                    | frame_system::Call::kill_prefix { .. },
                )
                | RuntimeCall::ParachainSystem(..)
                | RuntimeCall::Timestamp(..)
                | RuntimeCall::Balances(..)
                | RuntimeCall::CollatorSelection(
                    pallet_collator_selection::Call::set_desired_candidates { .. }
                    | pallet_collator_selection::Call::set_candidacy_bond { .. }
                    | pallet_collator_selection::Call::register_as_candidate { .. }
                    | pallet_collator_selection::Call::leave_intent { .. }
                    | pallet_collator_selection::Call::set_invulnerables { .. }
                    | pallet_collator_selection::Call::add_invulnerable { .. }
                    | pallet_collator_selection::Call::remove_invulnerable { .. },
                )
                | RuntimeCall::Session(pallet_session::Call::purge_keys { .. })
                | RuntimeCall::XcmpQueue(..)
                | RuntimeCall::DmpQueue(..)
                | RuntimeCall::Assets(
                    pallet_assets::Call::create { .. }
                    | pallet_assets::Call::force_create { .. }
                    | pallet_assets::Call::start_destroy { .. }
                    | pallet_assets::Call::destroy_accounts { .. }
                    | pallet_assets::Call::destroy_approvals { .. }
                    | pallet_assets::Call::finish_destroy { .. }
                    | pallet_assets::Call::block { .. }
                    | pallet_assets::Call::mint { .. }
                    | pallet_assets::Call::burn { .. }
                    | pallet_assets::Call::transfer { .. }
                    | pallet_assets::Call::transfer_keep_alive { .. }
                    | pallet_assets::Call::force_transfer { .. }
                    | pallet_assets::Call::freeze { .. }
                    | pallet_assets::Call::thaw { .. }
                    | pallet_assets::Call::freeze_asset { .. }
                    | pallet_assets::Call::thaw_asset { .. }
                    | pallet_assets::Call::transfer_ownership { .. }
                    | pallet_assets::Call::set_team { .. }
                    | pallet_assets::Call::set_metadata { .. }
                    | pallet_assets::Call::clear_metadata { .. }
                    | pallet_assets::Call::force_set_metadata { .. }
                    | pallet_assets::Call::force_clear_metadata { .. }
                    | pallet_assets::Call::force_asset_status { .. }
                    | pallet_assets::Call::approve_transfer { .. }
                    | pallet_assets::Call::cancel_approval { .. }
                    | pallet_assets::Call::force_cancel_approval { .. }
                    | pallet_assets::Call::transfer_approved { .. }
                    | pallet_assets::Call::touch { .. }
                    | pallet_assets::Call::touch_other { .. }
                    | pallet_assets::Call::refund { .. }
                    | pallet_assets::Call::refund_other { .. },
                )
                | RuntimeCall::ForeignAssets(
                    pallet_assets::Call::create { .. }
                    | pallet_assets::Call::force_create { .. }
                    | pallet_assets::Call::start_destroy { .. }
                    | pallet_assets::Call::destroy_accounts { .. }
                    | pallet_assets::Call::destroy_approvals { .. }
                    | pallet_assets::Call::finish_destroy { .. }
                    | pallet_assets::Call::block { .. }
                    | pallet_assets::Call::mint { .. }
                    | pallet_assets::Call::burn { .. }
                    | pallet_assets::Call::transfer { .. }
                    | pallet_assets::Call::transfer_keep_alive { .. }
                    | pallet_assets::Call::force_transfer { .. }
                    | pallet_assets::Call::freeze { .. }
                    | pallet_assets::Call::thaw { .. }
                    | pallet_assets::Call::freeze_asset { .. }
                    | pallet_assets::Call::thaw_asset { .. }
                    | pallet_assets::Call::transfer_ownership { .. }
                    | pallet_assets::Call::set_team { .. }
                    | pallet_assets::Call::set_metadata { .. }
                    | pallet_assets::Call::clear_metadata { .. }
                    | pallet_assets::Call::force_set_metadata { .. }
                    | pallet_assets::Call::force_clear_metadata { .. }
                    | pallet_assets::Call::force_asset_status { .. }
                    | pallet_assets::Call::approve_transfer { .. }
                    | pallet_assets::Call::cancel_approval { .. }
                    | pallet_assets::Call::force_cancel_approval { .. }
                    | pallet_assets::Call::transfer_approved { .. }
                    | pallet_assets::Call::touch { .. }
                    | pallet_assets::Call::touch_other { .. }
                    | pallet_assets::Call::refund { .. }
                    | pallet_assets::Call::refund_other { .. },
                )
                | RuntimeCall::PoolAssets(
                    pallet_assets::Call::force_create { .. }
                    | pallet_assets::Call::block { .. }
                    | pallet_assets::Call::burn { .. }
                    | pallet_assets::Call::transfer { .. }
                    | pallet_assets::Call::transfer_keep_alive { .. }
                    | pallet_assets::Call::force_transfer { .. }
                    | pallet_assets::Call::freeze { .. }
                    | pallet_assets::Call::thaw { .. }
                    | pallet_assets::Call::freeze_asset { .. }
                    | pallet_assets::Call::thaw_asset { .. }
                    | pallet_assets::Call::transfer_ownership { .. }
                    | pallet_assets::Call::set_team { .. }
                    | pallet_assets::Call::set_metadata { .. }
                    | pallet_assets::Call::clear_metadata { .. }
                    | pallet_assets::Call::force_set_metadata { .. }
                    | pallet_assets::Call::force_clear_metadata { .. }
                    | pallet_assets::Call::force_asset_status { .. }
                    | pallet_assets::Call::approve_transfer { .. }
                    | pallet_assets::Call::cancel_approval { .. }
                    | pallet_assets::Call::force_cancel_approval { .. }
                    | pallet_assets::Call::transfer_approved { .. }
                    | pallet_assets::Call::touch { .. }
                    | pallet_assets::Call::touch_other { .. }
                    | pallet_assets::Call::refund { .. }
                    | pallet_assets::Call::refund_other { .. },
                )
                | RuntimeCall::AssetConversion(
                    pallet_asset_conversion::Call::create_pool { .. }
                    | pallet_asset_conversion::Call::add_liquidity { .. }
                    | pallet_asset_conversion::Call::remove_liquidity { .. }
                    | pallet_asset_conversion::Call::swap_tokens_for_exact_tokens { .. }
                    | pallet_asset_conversion::Call::swap_exact_tokens_for_tokens { .. },
                )
                | RuntimeCall::NftFractionalization(
                    pallet_nft_fractionalization::Call::fractionalize { .. }
                    | pallet_nft_fractionalization::Call::unify { .. },
                )
                | RuntimeCall::Nfts(
                    pallet_nfts::Call::create { .. }
                    | pallet_nfts::Call::force_create { .. }
                    | pallet_nfts::Call::destroy { .. }
                    | pallet_nfts::Call::mint { .. }
                    | pallet_nfts::Call::force_mint { .. }
                    | pallet_nfts::Call::burn { .. }
                    | pallet_nfts::Call::transfer { .. }
                    | pallet_nfts::Call::lock_item_transfer { .. }
                    | pallet_nfts::Call::unlock_item_transfer { .. }
                    | pallet_nfts::Call::lock_collection { .. }
                    | pallet_nfts::Call::transfer_ownership { .. }
                    | pallet_nfts::Call::set_team { .. }
                    | pallet_nfts::Call::force_collection_owner { .. }
                    | pallet_nfts::Call::force_collection_config { .. }
                    | pallet_nfts::Call::approve_transfer { .. }
                    | pallet_nfts::Call::cancel_approval { .. }
                    | pallet_nfts::Call::clear_all_transfer_approvals { .. }
                    | pallet_nfts::Call::lock_item_properties { .. }
                    | pallet_nfts::Call::set_attribute { .. }
                    | pallet_nfts::Call::force_set_attribute { .. }
                    | pallet_nfts::Call::clear_attribute { .. }
                    | pallet_nfts::Call::approve_item_attributes { .. }
                    | pallet_nfts::Call::cancel_item_attributes_approval { .. }
                    | pallet_nfts::Call::set_metadata { .. }
                    | pallet_nfts::Call::clear_metadata { .. }
                    | pallet_nfts::Call::set_collection_metadata { .. }
                    | pallet_nfts::Call::clear_collection_metadata { .. }
                    | pallet_nfts::Call::set_accept_ownership { .. }
                    | pallet_nfts::Call::set_collection_max_supply { .. }
                    | pallet_nfts::Call::update_mint_settings { .. }
                    | pallet_nfts::Call::set_price { .. }
                    | pallet_nfts::Call::buy_item { .. }
                    | pallet_nfts::Call::pay_tips { .. }
                    | pallet_nfts::Call::create_swap { .. }
                    | pallet_nfts::Call::cancel_swap { .. }
                    | pallet_nfts::Call::claim_swap { .. },
                )
                | RuntimeCall::Uniques(
                    pallet_uniques::Call::create { .. }
                    | pallet_uniques::Call::force_create { .. }
                    | pallet_uniques::Call::destroy { .. }
                    | pallet_uniques::Call::mint { .. }
                    | pallet_uniques::Call::burn { .. }
                    | pallet_uniques::Call::transfer { .. }
                    | pallet_uniques::Call::freeze { .. }
                    | pallet_uniques::Call::thaw { .. }
                    | pallet_uniques::Call::freeze_collection { .. }
                    | pallet_uniques::Call::thaw_collection { .. }
                    | pallet_uniques::Call::transfer_ownership { .. }
                    | pallet_uniques::Call::set_team { .. }
                    | pallet_uniques::Call::approve_transfer { .. }
                    | pallet_uniques::Call::cancel_approval { .. }
                    | pallet_uniques::Call::force_item_status { .. }
                    | pallet_uniques::Call::set_attribute { .. }
                    | pallet_uniques::Call::clear_attribute { .. }
                    | pallet_uniques::Call::set_metadata { .. }
                    | pallet_uniques::Call::clear_metadata { .. }
                    | pallet_uniques::Call::set_collection_metadata { .. }
                    | pallet_uniques::Call::clear_collection_metadata { .. }
                    | pallet_uniques::Call::set_accept_ownership { .. }
                    | pallet_uniques::Call::set_collection_max_supply { .. }
                    | pallet_uniques::Call::set_price { .. }
                    | pallet_uniques::Call::buy_item { .. },
                ) => true,
                _ => false,
            }
        }
    }
    pub type Barrier = TrailingSetTopicAsId<
        DenyThenTry<
            DenyReserveTransferToRelayChain,
            (
                TakeWeightCredit,
                AllowKnownQueryResponses<PolkadotXcm>,
                WithComputedOrigin<
                    (
                        AllowTopLevelPaidExecutionFrom<Everything>,
                        AllowExplicitUnpaidExecutionFrom<ParentOrParentsPlurality>,
                        AllowSubscriptionsFrom<ParentOrSiblings>,
                    ),
                    UniversalLocation,
                    ConstU32<8>,
                >,
            ),
        >,
    >;
    pub type AssetFeeAsExistentialDepositMultiplierFeeCharger = AssetFeeAsExistentialDepositMultiplier<
        Runtime,
        WeightToFee,
        pallet_assets::BalanceToAssetBalance<
            Balances,
            Runtime,
            ConvertInto,
            TrustBackedAssetsInstance,
        >,
        TrustBackedAssetsInstance,
    >;
    /// Cases where a remote origin is accepted as trusted Teleporter for a given asset:
    ///
    /// - KSM with the parent Relay Chain and sibling system parachains; and
    /// - Sibling parachains' assets from where they originate (as `ForeignCreators`).
    pub type TrustedTeleporters = (
        ConcreteAssetFromSystem<KsmLocation>,
        IsForeignConcreteAsset<FromSiblingParachain<parachain_info::Pallet<Runtime>>>,
    );
    pub struct XcmConfig;
    impl xcm_executor::Config for XcmConfig {
        type RuntimeCall = RuntimeCall;
        type XcmSender = XcmRouter;
        type AssetTransactor = AssetTransactors;
        type OriginConverter = XcmOriginToTransactDispatchOrigin;
        type IsReserve = ();
        type IsTeleporter = TrustedTeleporters;
        type UniversalLocation = UniversalLocation;
        type Barrier = Barrier;
        type Weigher = WeightInfoBounds<
            crate::weights::xcm::AssetHubKusamaXcmWeight<RuntimeCall>,
            RuntimeCall,
            MaxInstructions,
        >;
        type Trader = (
            UsingComponents<
                WeightToFee,
                KsmLocation,
                AccountId,
                Balances,
                ToStakingPot<Runtime>,
            >,
            cumulus_primitives_utility::TakeFirstAssetTrader<
                AccountId,
                AssetFeeAsExistentialDepositMultiplierFeeCharger,
                TrustBackedAssetsConvertedConcreteId,
                Assets,
                cumulus_primitives_utility::XcmFeesTo32ByteAccount<
                    FungiblesTransactor,
                    AccountId,
                    XcmAssetFeesReceiver,
                >,
            >,
        );
        type ResponseHandler = PolkadotXcm;
        type AssetTrap = PolkadotXcm;
        type AssetClaims = PolkadotXcm;
        type SubscriptionService = PolkadotXcm;
        type PalletInstancesInfo = AllPalletsWithSystem;
        type MaxAssetsIntoHolding = MaxAssetsIntoHolding;
        type AssetLocker = ();
        type AssetExchanger = ();
        type FeeManager = ();
        type MessageExporter = ();
        type UniversalAliases = Nothing;
        type CallDispatcher = WithOriginFilter<SafeCallFilter>;
        type SafeCallFilter = SafeCallFilter;
        type Aliasers = Nothing;
    }
    /// Converts a local signed origin into an XCM multilocation.
    /// Forms the basis for local origins sending/executing XCMs.
    pub type LocalOriginToLocation = SignedToAccountId32<
        RuntimeOrigin,
        AccountId,
        RelayNetwork,
    >;
    /// The means for routing XCM messages which are not for local execution into the right message
    /// queues.
    pub type XcmRouter = WithUniqueTopic<
        (
            cumulus_primitives_utility::ParentAsUmp<ParachainSystem, PolkadotXcm, ()>,
            XcmpQueue,
        ),
    >;
    impl pallet_xcm::Config for Runtime {
        type RuntimeEvent = RuntimeEvent;
        type SendXcmOrigin = EnsureXcmOrigin<RuntimeOrigin, ()>;
        type XcmRouter = XcmRouter;
        type ExecuteXcmOrigin = EnsureXcmOrigin<RuntimeOrigin, LocalOriginToLocation>;
        type XcmExecuteFilter = Nothing;
        type XcmExecutor = XcmExecutor<XcmConfig>;
        type XcmTeleportFilter = Everything;
        type XcmReserveTransferFilter = Everything;
        type Weigher = WeightInfoBounds<
            crate::weights::xcm::AssetHubKusamaXcmWeight<RuntimeCall>,
            RuntimeCall,
            MaxInstructions,
        >;
        type UniversalLocation = UniversalLocation;
        type RuntimeOrigin = RuntimeOrigin;
        type RuntimeCall = RuntimeCall;
        const VERSION_DISCOVERY_QUEUE_SIZE: u32 = 100;
        type AdvertisedXcmVersion = pallet_xcm::CurrentXcmVersion;
        type Currency = Balances;
        type CurrencyMatcher = ();
        type TrustedLockers = ();
        type SovereignAccountOf = LocationToAccountId;
        type MaxLockers = ConstU32<8>;
        type WeightInfo = crate::weights::pallet_xcm::WeightInfo<Runtime>;
        type AdminOrigin = EnsureRoot<AccountId>;
        type MaxRemoteLockConsumers = ConstU32<0>;
        type RemoteLockConsumerIdentifier = ();
    }
    impl cumulus_pallet_xcm::Config for Runtime {
        type RuntimeEvent = RuntimeEvent;
        type XcmExecutor = XcmExecutor<XcmConfig>;
    }
    pub type ForeignCreatorsSovereignAccountOf = (
        SiblingParachainConvertsVia<Sibling, AccountId>,
        AccountId32Aliases<RelayNetwork, AccountId>,
        ParentIsPreset<AccountId>,
    );
    /// Simple conversion of `u32` into an `AssetId` for use in benchmarking.
    pub struct XcmBenchmarkHelper;
}
use assets_common::{
    foreign_creators::ForeignCreators,
    local_and_foreign_assets::{LocalAndForeignAssets, MultiLocationConverter},
    matching::FromSiblingParachain, AssetIdForTrustBackedAssetsConvert,
    MultiLocationForAssetId,
};
use cumulus_pallet_parachain_system::RelayNumberStrictlyIncreases;
use sp_api::impl_runtime_apis;
use sp_core::{crypto::KeyTypeId, OpaqueMetadata};
use sp_runtime::{
    create_runtime_str, generic, impl_opaque_keys,
    traits::{AccountIdConversion, AccountIdLookup, BlakeTwo256, Block as BlockT, Verify},
    transaction_validity::{TransactionSource, TransactionValidity},
    ApplyExtrinsicResult, Permill,
};
use sp_std::prelude::*;
#[cfg(feature = "std")]
use sp_version::NativeVersion;
use sp_version::RuntimeVersion;
use codec::{Decode, Encode, MaxEncodedLen};
use frame_support::{
    construct_runtime, dispatch::DispatchClass,
    genesis_builder_helper::{build_config, create_default_config},
    ord_parameter_types, parameter_types,
    traits::{
        AsEnsureOriginWithArg, ConstBool, ConstU128, ConstU32, ConstU64, ConstU8,
        EitherOfDiverse, InstanceFilter,
    },
    weights::{ConstantMultiplier, Weight},
    BoundedVec, PalletId,
};
use frame_system::{
    limits::{BlockLength, BlockWeights},
    EnsureRoot, EnsureSigned, EnsureSignedBy,
};
use pallet_asset_conversion_tx_payment::AssetConversionAdapter;
use pallet_nfts::PalletFeatures;
pub use parachains_common as common;
use parachains_common::{
    impls::DealWithFees, kusama::{consensus::*, currency::*, fee::WeightToFee},
    AccountId, AssetIdForTrustBackedAssets, AuraId, Balance, BlockNumber, Hash, Header,
    Nonce, Signature, AVERAGE_ON_INITIALIZE_RATIO, DAYS, HOURS, MAXIMUM_BLOCK_WEIGHT,
    NORMAL_DISPATCH_RATIO, SLOT_DURATION,
};
use sp_runtime::RuntimeDebug;
use xcm::opaque::v3::MultiLocation;
use xcm_config::{
    FellowshipLocation, ForeignAssetsConvertedConcreteId, GovernanceLocation,
    KsmLocation, PoolAssetsConvertedConcreteId, TrustBackedAssetsConvertedConcreteId,
    XcmConfig,
};
#[cfg(any(feature = "std", test))]
pub use sp_runtime::BuildStorage;
use pallet_xcm::{EnsureXcm, IsVoiceOfBody};
use polkadot_runtime_common::{BlockHashCount, SlowAdjustingFeeUpdate};
use xcm::latest::BodyId;
use xcm_executor::XcmExecutor;
use crate::xcm_config::{
    ForeignCreatorsSovereignAccountOf, LocalAndForeignAssetsMultiLocationMatcher,
    TrustBackedAssetsPalletLocation,
};
use weights::{BlockExecutionWeight, ExtrinsicBaseWeight, RocksDbWeight};
use ::sp_runtime::serde as __opaque_keys_serde_import__SessionKeys;
#[serde(crate = "__opaque_keys_serde_import__SessionKeys")]
pub struct SessionKeys {
    pub aura: <Aura as ::sp_runtime::BoundToRuntimeAppPublic>::Public,
}
#[automatically_derived]
impl ::core::clone::Clone for SessionKeys {
    #[inline]
    fn clone(&self) -> SessionKeys {
        SessionKeys {
            aura: ::core::clone::Clone::clone(&self.aura),
        }
    }
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for SessionKeys {}
#[automatically_derived]
impl ::core::cmp::PartialEq for SessionKeys {
    #[inline]
    fn eq(&self, other: &SessionKeys) -> bool {
        self.aura == other.aura
    }
}
#[automatically_derived]
impl ::core::marker::StructuralEq for SessionKeys {}
#[automatically_derived]
impl ::core::cmp::Eq for SessionKeys {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<
            <Aura as ::sp_runtime::BoundToRuntimeAppPublic>::Public,
        >;
    }
}
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Encode for SessionKeys {
        fn size_hint(&self) -> usize {
            ::codec::Encode::size_hint(&&self.aura)
        }
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            ::codec::Encode::encode_to(&&self.aura, __codec_dest_edqy)
        }
        fn encode(&self) -> ::codec::alloc::vec::Vec<::core::primitive::u8> {
            ::codec::Encode::encode(&&self.aura)
        }
        fn using_encoded<R, F: ::core::ops::FnOnce(&[::core::primitive::u8]) -> R>(
            &self,
            f: F,
        ) -> R {
            ::codec::Encode::using_encoded(&&self.aura, f)
        }
    }
    #[automatically_derived]
    impl ::codec::EncodeLike for SessionKeys {}
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Decode for SessionKeys {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            ::core::result::Result::Ok(SessionKeys {
                aura: {
                    let __codec_res_edqy = <<Aura as ::sp_runtime::BoundToRuntimeAppPublic>::Public as ::codec::Decode>::decode(
                        __codec_input_edqy,
                    );
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `SessionKeys::aura`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
            })
        }
    }
};
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl ::scale_info::TypeInfo for SessionKeys {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(::scale_info::Path::new("SessionKeys", "asset_hub_kusama_runtime"))
                .type_params(::alloc::vec::Vec::new())
                .composite(
                    ::scale_info::build::Fields::named()
                        .field(|f| {
                            f
                                .ty::<
                                    <Aura as ::sp_runtime::BoundToRuntimeAppPublic>::Public,
                                >()
                                .name("aura")
                                .type_name(
                                    "<Aura as $crate::BoundToRuntimeAppPublic>::Public",
                                )
                        }),
                )
        }
    }
};
impl core::fmt::Debug for SessionKeys {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        fmt.debug_struct("SessionKeys").field("aura", &self.aura).finish()
    }
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    use __opaque_keys_serde_import__SessionKeys as _serde;
    #[automatically_derived]
    impl __opaque_keys_serde_import__SessionKeys::Serialize for SessionKeys {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> __opaque_keys_serde_import__SessionKeys::__private::Result<
            __S::Ok,
            __S::Error,
        >
        where
            __S: __opaque_keys_serde_import__SessionKeys::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "SessionKeys",
                false as usize + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "aura",
                &self.aura,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    use __opaque_keys_serde_import__SessionKeys as _serde;
    #[automatically_derived]
    impl<'de> __opaque_keys_serde_import__SessionKeys::Deserialize<'de> for SessionKeys {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> __opaque_keys_serde_import__SessionKeys::__private::Result<Self, __D::Error>
        where
            __D: __opaque_keys_serde_import__SessionKeys::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "aura" => _serde::__private::Ok(__Field::__field0),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"aura" => _serde::__private::Ok(__Field::__field0),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<SessionKeys>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = SessionKeys;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct SessionKeys",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        <Aura as ::sp_runtime::BoundToRuntimeAppPublic>::Public,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct SessionKeys with 1 element",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(SessionKeys { aura: __field0 })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<
                        <Aura as ::sp_runtime::BoundToRuntimeAppPublic>::Public,
                    > = _serde::__private::None;
                    while let _serde::__private::Some(__key)
                        = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("aura"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        <Aura as ::sp_runtime::BoundToRuntimeAppPublic>::Public,
                                    >(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("aura")?
                        }
                    };
                    _serde::__private::Ok(SessionKeys { aura: __field0 })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["aura"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "SessionKeys",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<SessionKeys>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
impl SessionKeys {
    /// Generate a set of keys with optionally using the given seed.
    ///
    /// The generated key pairs are stored in the keystore.
    ///
    /// Returns the concatenated SCALE encoded public keys.
    pub fn generate(
        seed: Option<::sp_runtime::sp_std::vec::Vec<u8>>,
    ) -> ::sp_runtime::sp_std::vec::Vec<u8> {
        let keys = Self {
            aura: <<Aura as ::sp_runtime::BoundToRuntimeAppPublic>::Public as ::sp_runtime::RuntimeAppPublic>::generate_pair(
                seed.clone(),
            ),
        };
        ::sp_runtime::codec::Encode::encode(&keys)
    }
    /// Converts `Self` into a `Vec` of `(raw public key, KeyTypeId)`.
    pub fn into_raw_public_keys(
        self,
    ) -> ::sp_runtime::sp_std::vec::Vec<
        (::sp_runtime::sp_std::vec::Vec<u8>, ::sp_runtime::KeyTypeId),
    > {
        let mut keys = Vec::new();
        keys.push((
            ::sp_runtime::RuntimeAppPublic::to_raw_vec(&self.aura),
            <<Aura as ::sp_runtime::BoundToRuntimeAppPublic>::Public as ::sp_runtime::RuntimeAppPublic>::ID,
        ));
        keys
    }
    /// Decode `Self` from the given `encoded` slice and convert `Self` into the raw public
    /// keys (see [`Self::into_raw_public_keys`]).
    ///
    /// Returns `None` when the decoding failed, otherwise `Some(_)`.
    pub fn decode_into_raw_public_keys(
        encoded: &[u8],
    ) -> Option<
        ::sp_runtime::sp_std::vec::Vec<
            (::sp_runtime::sp_std::vec::Vec<u8>, ::sp_runtime::KeyTypeId),
        >,
    > {
        <Self as ::sp_runtime::codec::Decode>::decode(&mut &encoded[..])
            .ok()
            .map(|s| s.into_raw_public_keys())
    }
}
impl ::sp_runtime::traits::OpaqueKeys for SessionKeys {
    type KeyTypeIdProviders = (Aura,);
    fn key_ids() -> &'static [::sp_runtime::KeyTypeId] {
        &[
            <<Aura as ::sp_runtime::BoundToRuntimeAppPublic>::Public as ::sp_runtime::RuntimeAppPublic>::ID,
        ]
    }
    fn get_raw(&self, i: ::sp_runtime::KeyTypeId) -> &[u8] {
        match i {
            i if i
                == <<Aura as ::sp_runtime::BoundToRuntimeAppPublic>::Public as ::sp_runtime::RuntimeAppPublic>::ID => {
                self.aura.as_ref()
            }
            _ => &[],
        }
    }
}
#[cfg(not(feature = "state-trie-version-1"))]
pub const VERSION: RuntimeVersion = RuntimeVersion {
    spec_name: { ::sp_runtime::RuntimeString::Borrowed("statemine") },
    impl_name: { ::sp_runtime::RuntimeString::Borrowed("statemine") },
    authoring_version: 1,
    spec_version: 10000,
    impl_version: 0,
    apis: RUNTIME_API_VERSIONS,
    transaction_version: 13,
    state_version: 0,
};
const _: () = {};
/// The version information used to identify this runtime when compiled natively.
#[cfg(feature = "std")]
pub fn native_version() -> NativeVersion {
    NativeVersion {
        runtime_version: VERSION,
        can_author_with: Default::default(),
    }
}
pub struct Version;
impl Version {
    /// Returns the value of this parameter type.
    pub const fn get() -> RuntimeVersion {
        VERSION
    }
}
impl<_I: From<RuntimeVersion>> ::frame_support::traits::Get<_I> for Version {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for Version {
    type Type = RuntimeVersion;
    fn get() -> RuntimeVersion {
        Self::get()
    }
}
pub struct RuntimeBlockLength;
impl RuntimeBlockLength {
    /// Returns the value of this parameter type.
    pub fn get() -> BlockLength {
        BlockLength::max_with_normal_ratio(5 * 1024 * 1024, NORMAL_DISPATCH_RATIO)
    }
}
impl<_I: From<BlockLength>> ::frame_support::traits::Get<_I> for RuntimeBlockLength {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for RuntimeBlockLength {
    type Type = BlockLength;
    fn get() -> BlockLength {
        Self::get()
    }
}
pub struct RuntimeBlockWeights;
impl RuntimeBlockWeights {
    /// Returns the value of this parameter type.
    pub fn get() -> BlockWeights {
        BlockWeights::builder()
            .base_block(BlockExecutionWeight::get())
            .for_class(
                DispatchClass::all(),
                |weights| {
                    weights.base_extrinsic = ExtrinsicBaseWeight::get();
                },
            )
            .for_class(
                DispatchClass::Normal,
                |weights| {
                    weights
                        .max_total = Some(NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT);
                },
            )
            .for_class(
                DispatchClass::Operational,
                |weights| {
                    weights.max_total = Some(MAXIMUM_BLOCK_WEIGHT);
                    weights
                        .reserved = Some(
                        MAXIMUM_BLOCK_WEIGHT
                            - NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT,
                    );
                },
            )
            .avg_block_initialization(AVERAGE_ON_INITIALIZE_RATIO)
            .build_or_panic()
    }
}
impl<_I: From<BlockWeights>> ::frame_support::traits::Get<_I> for RuntimeBlockWeights {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for RuntimeBlockWeights {
    type Type = BlockWeights;
    fn get() -> BlockWeights {
        Self::get()
    }
}
pub struct SS58Prefix;
impl SS58Prefix {
    /// Returns the value of this parameter type.
    pub const fn get() -> u8 {
        2
    }
}
impl<_I: From<u8>> ::frame_support::traits::Get<_I> for SS58Prefix {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for SS58Prefix {
    type Type = u8;
    fn get() -> u8 {
        Self::get()
    }
}
impl frame_system::Config for Runtime {
    type BaseCallFilter = frame_support::traits::Everything;
    type BlockWeights = RuntimeBlockWeights;
    type BlockLength = RuntimeBlockLength;
    type AccountId = AccountId;
    type RuntimeCall = RuntimeCall;
    type Lookup = AccountIdLookup<AccountId, ()>;
    type Nonce = Nonce;
    type Hash = Hash;
    type Hashing = BlakeTwo256;
    type Block = Block;
    type RuntimeEvent = RuntimeEvent;
    type RuntimeOrigin = RuntimeOrigin;
    type BlockHashCount = BlockHashCount;
    type DbWeight = RocksDbWeight;
    type Version = Version;
    type PalletInfo = PalletInfo;
    type OnNewAccount = ();
    type OnKilledAccount = ();
    type AccountData = pallet_balances::AccountData<Balance>;
    type SystemWeightInfo = weights::frame_system::WeightInfo<Runtime>;
    type SS58Prefix = SS58Prefix;
    type OnSetCode = cumulus_pallet_parachain_system::ParachainSetCode<Self>;
    type MaxConsumers = frame_support::traits::ConstU32<16>;
}
impl pallet_timestamp::Config for Runtime {
    /// A timestamp: milliseconds since the unix epoch.
    type Moment = u64;
    type OnTimestampSet = Aura;
    type MinimumPeriod = ConstU64<{ SLOT_DURATION / 2 }>;
    type WeightInfo = weights::pallet_timestamp::WeightInfo<Runtime>;
}
impl pallet_authorship::Config for Runtime {
    type FindAuthor = pallet_session::FindAccountFromAuthorIndex<Self, Aura>;
    type EventHandler = (CollatorSelection,);
}
pub struct ExistentialDeposit;
impl ExistentialDeposit {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        EXISTENTIAL_DEPOSIT
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for ExistentialDeposit {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for ExistentialDeposit {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
impl pallet_balances::Config for Runtime {
    type MaxLocks = ConstU32<50>;
    /// The type for recording an account's balance.
    type Balance = Balance;
    /// The ubiquitous event type.
    type RuntimeEvent = RuntimeEvent;
    type DustRemoval = ();
    type ExistentialDeposit = ExistentialDeposit;
    type AccountStore = System;
    type WeightInfo = weights::pallet_balances::WeightInfo<Runtime>;
    type MaxReserves = ConstU32<50>;
    type ReserveIdentifier = [u8; 8];
    type RuntimeHoldReason = RuntimeHoldReason;
    type FreezeIdentifier = ();
    type MaxHolds = ConstU32<1>;
    type MaxFreezes = ConstU32<0>;
}
/// Relay Chain `TransactionByteFee` / 10
pub struct TransactionByteFee;
impl TransactionByteFee {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        MILLICENTS
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for TransactionByteFee {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for TransactionByteFee {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
impl pallet_transaction_payment::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type OnChargeTransaction = pallet_transaction_payment::CurrencyAdapter<
        Balances,
        DealWithFees<Runtime>,
    >;
    type WeightToFee = WeightToFee;
    type LengthToFee = ConstantMultiplier<Balance, TransactionByteFee>;
    type FeeMultiplierUpdate = SlowAdjustingFeeUpdate<Self>;
    type OperationalFeeMultiplier = ConstU8<5>;
}
pub struct AssetDeposit;
impl AssetDeposit {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        UNITS / 10
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for AssetDeposit {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for AssetDeposit {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct AssetAccountDeposit;
impl AssetAccountDeposit {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        deposit(1, 16)
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for AssetAccountDeposit {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for AssetAccountDeposit {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct ApprovalDeposit;
impl ApprovalDeposit {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        EXISTENTIAL_DEPOSIT
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for ApprovalDeposit {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for ApprovalDeposit {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct AssetsStringLimit;
impl AssetsStringLimit {
    /// Returns the value of this parameter type.
    pub const fn get() -> u32 {
        50
    }
}
impl<_I: From<u32>> ::frame_support::traits::Get<_I> for AssetsStringLimit {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for AssetsStringLimit {
    type Type = u32;
    fn get() -> u32 {
        Self::get()
    }
}
/// Key = 32 bytes, Value = 36 bytes (32+1+1+1+1)
pub struct MetadataDepositBase;
impl MetadataDepositBase {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        deposit(1, 68)
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for MetadataDepositBase {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for MetadataDepositBase {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct MetadataDepositPerByte;
impl MetadataDepositPerByte {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        deposit(0, 1)
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for MetadataDepositPerByte {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for MetadataDepositPerByte {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
/// We allow root to execute privileged asset operations.
pub type AssetsForceOrigin = EnsureRoot<AccountId>;
pub type TrustBackedAssetsInstance = pallet_assets::Instance1;
type TrustBackedAssetsCall = pallet_assets::Call<Runtime, TrustBackedAssetsInstance>;
impl pallet_assets::Config<TrustBackedAssetsInstance> for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type RuntimeHoldReason = RuntimeHoldReason;
    type Balance = Balance;
    type AssetId = AssetIdForTrustBackedAssets;
    type AssetIdParameter = codec::Compact<AssetIdForTrustBackedAssets>;
    type NativeToken = Balances;
    type CreateOrigin = AsEnsureOriginWithArg<EnsureSigned<AccountId>>;
    type ForceOrigin = AssetsForceOrigin;
    type AssetDeposit = AssetDeposit;
    type MetadataDepositBase = MetadataDepositBase;
    type MetadataDepositPerByte = MetadataDepositPerByte;
    type ApprovalDeposit = ApprovalDeposit;
    type StringLimit = AssetsStringLimit;
    type Freezer = ();
    type Extra = ();
    type WeightInfo = weights::pallet_assets_local::WeightInfo<Runtime>;
    type CallbackHandle = ();
    type AssetAccountDeposit = AssetAccountDeposit;
    type RemoveItemsLimit = frame_support::traits::ConstU32<1000>;
}
pub struct AssetConversionPalletId;
impl AssetConversionPalletId {
    /// Returns the value of this parameter type.
    pub const fn get() -> PalletId {
        PalletId(*b"py/ascon")
    }
}
impl<_I: From<PalletId>> ::frame_support::traits::Get<_I> for AssetConversionPalletId {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for AssetConversionPalletId {
    type Type = PalletId;
    fn get() -> PalletId {
        Self::get()
    }
}
pub struct AllowMultiAssetPools;
impl AllowMultiAssetPools {
    /// Returns the value of this parameter type.
    pub const fn get() -> bool {
        false
    }
}
impl<_I: From<bool>> ::frame_support::traits::Get<_I> for AllowMultiAssetPools {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for AllowMultiAssetPools {
    type Type = bool;
    fn get() -> bool {
        Self::get()
    }
}
pub struct LiquidityWithdrawalFee;
impl LiquidityWithdrawalFee {
    /// Returns the value of this parameter type.
    pub const fn get() -> Permill {
        Permill::from_percent(0)
    }
}
impl<_I: From<Permill>> ::frame_support::traits::Get<_I> for LiquidityWithdrawalFee {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for LiquidityWithdrawalFee {
    type Type = Permill;
    fn get() -> Permill {
        Self::get()
    }
}
pub struct AssetConversionOrigin;
impl AssetConversionOrigin {
    /// Returns the value of this parameter type.
    pub fn get() -> sp_runtime::AccountId32 {
        AccountIdConversion::<
            sp_runtime::AccountId32,
        >::into_account_truncating(&AssetConversionPalletId::get())
    }
}
impl<_I: From<sp_runtime::AccountId32>> ::frame_support::traits::Get<_I>
for AssetConversionOrigin {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for AssetConversionOrigin {
    type Type = sp_runtime::AccountId32;
    fn get() -> sp_runtime::AccountId32 {
        Self::get()
    }
}
impl ::frame_support::traits::SortedMembers<sp_runtime::AccountId32>
for AssetConversionOrigin {
    fn contains(t: &sp_runtime::AccountId32) -> bool {
        &AccountIdConversion::<
            sp_runtime::AccountId32,
        >::into_account_truncating(&AssetConversionPalletId::get()) == t
    }
    fn sorted_members() -> ::frame_support::__private::sp_std::prelude::Vec<
        sp_runtime::AccountId32,
    > {
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                AccountIdConversion::<
                    sp_runtime::AccountId32,
                >::into_account_truncating(&AssetConversionPalletId::get()),
            ]),
        )
    }
    fn count() -> usize {
        1
    }
}
impl ::frame_support::traits::Contains<sp_runtime::AccountId32>
for AssetConversionOrigin {
    fn contains(t: &sp_runtime::AccountId32) -> bool {
        &AccountIdConversion::<
            sp_runtime::AccountId32,
        >::into_account_truncating(&AssetConversionPalletId::get()) == t
    }
}
pub type PoolAssetsInstance = pallet_assets::Instance3;
impl pallet_assets::Config<PoolAssetsInstance> for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type RuntimeHoldReason = RuntimeHoldReason;
    type Balance = Balance;
    type RemoveItemsLimit = ConstU32<1000>;
    type AssetId = u32;
    type AssetIdParameter = u32;
    type NativeToken = Balances;
    type CreateOrigin = AsEnsureOriginWithArg<
        EnsureSignedBy<AssetConversionOrigin, sp_runtime::AccountId32>,
    >;
    type ForceOrigin = AssetsForceOrigin;
    type AssetDeposit = ConstU128<0>;
    type AssetAccountDeposit = ConstU128<0>;
    type MetadataDepositBase = ConstU128<0>;
    type MetadataDepositPerByte = ConstU128<0>;
    type ApprovalDeposit = ApprovalDeposit;
    type StringLimit = ConstU32<50>;
    type Freezer = ();
    type Extra = ();
    type WeightInfo = weights::pallet_assets_pool::WeightInfo<Runtime>;
    type CallbackHandle = ();
}
impl pallet_asset_conversion::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type Balance = Balance;
    type HigherPrecisionBalance = sp_core::U256;
    type Currency = Balances;
    type AssetBalance = Balance;
    type AssetId = MultiLocation;
    type Assets = LocalAndForeignAssets<
        Assets,
        AssetIdForTrustBackedAssetsConvert<TrustBackedAssetsPalletLocation>,
        ForeignAssets,
    >;
    type PoolAssets = PoolAssets;
    type PoolAssetId = u32;
    type PoolSetupFee = ConstU128<0>;
    type PoolSetupFeeReceiver = AssetConversionOrigin;
    type LiquidityWithdrawalFee = LiquidityWithdrawalFee;
    type LPFee = ConstU32<3>;
    type PalletId = AssetConversionPalletId;
    type AllowMultiAssetPools = AllowMultiAssetPools;
    type MaxSwapPathLength = ConstU32<4>;
    type MultiAssetId = Box<MultiLocation>;
    type MultiAssetIdConverter = MultiLocationConverter<
        KsmLocation,
        LocalAndForeignAssetsMultiLocationMatcher,
    >;
    type MintMinLiquidity = ConstU128<100>;
    type WeightInfo = weights::pallet_asset_conversion::WeightInfo<Runtime>;
}
pub struct ForeignAssetsAssetDeposit;
impl ForeignAssetsAssetDeposit {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        AssetDeposit::get()
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for ForeignAssetsAssetDeposit {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for ForeignAssetsAssetDeposit {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct ForeignAssetsAssetAccountDeposit;
impl ForeignAssetsAssetAccountDeposit {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        AssetAccountDeposit::get()
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I>
for ForeignAssetsAssetAccountDeposit {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for ForeignAssetsAssetAccountDeposit {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct ForeignAssetsApprovalDeposit;
impl ForeignAssetsApprovalDeposit {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        ApprovalDeposit::get()
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I>
for ForeignAssetsApprovalDeposit {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for ForeignAssetsApprovalDeposit {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct ForeignAssetsAssetsStringLimit;
impl ForeignAssetsAssetsStringLimit {
    /// Returns the value of this parameter type.
    pub const fn get() -> u32 {
        AssetsStringLimit::get()
    }
}
impl<_I: From<u32>> ::frame_support::traits::Get<_I> for ForeignAssetsAssetsStringLimit {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for ForeignAssetsAssetsStringLimit {
    type Type = u32;
    fn get() -> u32 {
        Self::get()
    }
}
pub struct ForeignAssetsMetadataDepositBase;
impl ForeignAssetsMetadataDepositBase {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        MetadataDepositBase::get()
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I>
for ForeignAssetsMetadataDepositBase {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for ForeignAssetsMetadataDepositBase {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct ForeignAssetsMetadataDepositPerByte;
impl ForeignAssetsMetadataDepositPerByte {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        MetadataDepositPerByte::get()
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I>
for ForeignAssetsMetadataDepositPerByte {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for ForeignAssetsMetadataDepositPerByte {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
/// Assets managed by some foreign location. Note: we do not declare a `ForeignAssetsCall` type, as
/// this type is used in proxy definitions. We assume that a foreign location would not want to set
/// an individual, local account as a proxy for the issuance of their assets. This issuance should
/// be managed by the foreign location's governance.
pub type ForeignAssetsInstance = pallet_assets::Instance2;
impl pallet_assets::Config<ForeignAssetsInstance> for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type RuntimeHoldReason = RuntimeHoldReason;
    type Balance = Balance;
    type AssetId = MultiLocationForAssetId;
    type AssetIdParameter = MultiLocationForAssetId;
    type NativeToken = Balances;
    type CreateOrigin = ForeignCreators<
        (FromSiblingParachain<parachain_info::Pallet<Runtime>>,),
        ForeignCreatorsSovereignAccountOf,
        AccountId,
    >;
    type ForceOrigin = AssetsForceOrigin;
    type AssetDeposit = ForeignAssetsAssetDeposit;
    type MetadataDepositBase = ForeignAssetsMetadataDepositBase;
    type MetadataDepositPerByte = ForeignAssetsMetadataDepositPerByte;
    type ApprovalDeposit = ForeignAssetsApprovalDeposit;
    type StringLimit = ForeignAssetsAssetsStringLimit;
    type Freezer = ();
    type Extra = ();
    type WeightInfo = weights::pallet_assets_foreign::WeightInfo<Runtime>;
    type CallbackHandle = ();
    type AssetAccountDeposit = ForeignAssetsAssetAccountDeposit;
    type RemoveItemsLimit = frame_support::traits::ConstU32<1000>;
}
pub struct DepositBase;
impl DepositBase {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        deposit(1, 88)
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for DepositBase {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for DepositBase {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct DepositFactor;
impl DepositFactor {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        deposit(0, 32)
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for DepositFactor {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for DepositFactor {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct MaxSignatories;
impl MaxSignatories {
    /// Returns the value of this parameter type.
    pub const fn get() -> u32 {
        100
    }
}
impl<_I: From<u32>> ::frame_support::traits::Get<_I> for MaxSignatories {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for MaxSignatories {
    type Type = u32;
    fn get() -> u32 {
        Self::get()
    }
}
impl pallet_multisig::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type RuntimeCall = RuntimeCall;
    type Currency = Balances;
    type DepositBase = DepositBase;
    type DepositFactor = DepositFactor;
    type MaxSignatories = MaxSignatories;
    type WeightInfo = weights::pallet_multisig::WeightInfo<Runtime>;
}
impl pallet_utility::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type RuntimeCall = RuntimeCall;
    type PalletsOrigin = OriginCaller;
    type WeightInfo = weights::pallet_utility::WeightInfo<Runtime>;
}
pub struct ProxyDepositBase;
impl ProxyDepositBase {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        deposit(1, 40)
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for ProxyDepositBase {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for ProxyDepositBase {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct ProxyDepositFactor;
impl ProxyDepositFactor {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        deposit(0, 33)
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for ProxyDepositFactor {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for ProxyDepositFactor {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct MaxProxies;
impl MaxProxies {
    /// Returns the value of this parameter type.
    pub const fn get() -> u16 {
        32
    }
}
impl<_I: From<u16>> ::frame_support::traits::Get<_I> for MaxProxies {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for MaxProxies {
    type Type = u16;
    fn get() -> u16 {
        Self::get()
    }
}
pub struct AnnouncementDepositBase;
impl AnnouncementDepositBase {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        deposit(1, 48)
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for AnnouncementDepositBase {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for AnnouncementDepositBase {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct AnnouncementDepositFactor;
impl AnnouncementDepositFactor {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        deposit(0, 66)
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for AnnouncementDepositFactor {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for AnnouncementDepositFactor {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct MaxPending;
impl MaxPending {
    /// Returns the value of this parameter type.
    pub const fn get() -> u16 {
        32
    }
}
impl<_I: From<u16>> ::frame_support::traits::Get<_I> for MaxPending {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for MaxPending {
    type Type = u16;
    fn get() -> u16 {
        Self::get()
    }
}
/// The type used to represent the kinds of proxying allowed.
pub enum ProxyType {
    /// Fully permissioned proxy. Can execute any call on behalf of _proxied_.
    Any,
    /// Can execute any call that does not transfer funds or assets.
    NonTransfer,
    /// Proxy with the ability to reject time-delay proxy announcements.
    CancelProxy,
    /// Assets proxy. Can execute any call from `assets`, **including asset transfers**.
    Assets,
    /// Owner proxy. Can execute calls related to asset ownership.
    AssetOwner,
    /// Asset manager. Can execute calls related to asset management.
    AssetManager,
    /// Collator selection proxy. Can execute calls related to collator selection mechanism.
    Collator,
}
#[automatically_derived]
impl ::core::marker::Copy for ProxyType {}
#[automatically_derived]
impl ::core::clone::Clone for ProxyType {
    #[inline]
    fn clone(&self) -> ProxyType {
        *self
    }
}
#[automatically_derived]
impl ::core::marker::StructuralEq for ProxyType {}
#[automatically_derived]
impl ::core::cmp::Eq for ProxyType {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {}
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for ProxyType {}
#[automatically_derived]
impl ::core::cmp::PartialEq for ProxyType {
    #[inline]
    fn eq(&self, other: &ProxyType) -> bool {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        __self_tag == __arg1_tag
    }
}
#[automatically_derived]
impl ::core::cmp::Ord for ProxyType {
    #[inline]
    fn cmp(&self, other: &ProxyType) -> ::core::cmp::Ordering {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
    }
}
#[automatically_derived]
impl ::core::cmp::PartialOrd for ProxyType {
    #[inline]
    fn partial_cmp(
        &self,
        other: &ProxyType,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
    }
}
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Encode for ProxyType {
        fn size_hint(&self) -> usize {
            1_usize
                + match *self {
                    ProxyType::Any => 0_usize,
                    ProxyType::NonTransfer => 0_usize,
                    ProxyType::CancelProxy => 0_usize,
                    ProxyType::Assets => 0_usize,
                    ProxyType::AssetOwner => 0_usize,
                    ProxyType::AssetManager => 0_usize,
                    ProxyType::Collator => 0_usize,
                    _ => 0_usize,
                }
        }
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            match *self {
                ProxyType::Any => {
                    #[allow(clippy::unnecessary_cast)]
                    __codec_dest_edqy.push_byte(0usize as ::core::primitive::u8);
                }
                ProxyType::NonTransfer => {
                    #[allow(clippy::unnecessary_cast)]
                    __codec_dest_edqy.push_byte(1usize as ::core::primitive::u8);
                }
                ProxyType::CancelProxy => {
                    #[allow(clippy::unnecessary_cast)]
                    __codec_dest_edqy.push_byte(2usize as ::core::primitive::u8);
                }
                ProxyType::Assets => {
                    #[allow(clippy::unnecessary_cast)]
                    __codec_dest_edqy.push_byte(3usize as ::core::primitive::u8);
                }
                ProxyType::AssetOwner => {
                    #[allow(clippy::unnecessary_cast)]
                    __codec_dest_edqy.push_byte(4usize as ::core::primitive::u8);
                }
                ProxyType::AssetManager => {
                    #[allow(clippy::unnecessary_cast)]
                    __codec_dest_edqy.push_byte(5usize as ::core::primitive::u8);
                }
                ProxyType::Collator => {
                    #[allow(clippy::unnecessary_cast)]
                    __codec_dest_edqy.push_byte(6usize as ::core::primitive::u8);
                }
                _ => {}
            }
        }
    }
    #[automatically_derived]
    impl ::codec::EncodeLike for ProxyType {}
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Decode for ProxyType {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            match __codec_input_edqy
                .read_byte()
                .map_err(|e| {
                    e.chain("Could not decode `ProxyType`, failed to read variant byte")
                })?
            {
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 0usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || { ::core::result::Result::Ok(ProxyType::Any) })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 1usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(ProxyType::NonTransfer)
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 2usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(ProxyType::CancelProxy)
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 3usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || { ::core::result::Result::Ok(ProxyType::Assets) })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 4usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(ProxyType::AssetOwner)
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 5usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(ProxyType::AssetManager)
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 6usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(ProxyType::Collator)
                    })();
                }
                _ => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Err(
                            <_ as ::core::convert::Into<
                                _,
                            >>::into(
                                "Could not decode `ProxyType`, variant doesn't exist",
                            ),
                        )
                    })();
                }
            }
        }
    }
};
impl core::fmt::Debug for ProxyType {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            Self::Any => fmt.debug_tuple("ProxyType::Any").finish(),
            Self::NonTransfer => fmt.debug_tuple("ProxyType::NonTransfer").finish(),
            Self::CancelProxy => fmt.debug_tuple("ProxyType::CancelProxy").finish(),
            Self::Assets => fmt.debug_tuple("ProxyType::Assets").finish(),
            Self::AssetOwner => fmt.debug_tuple("ProxyType::AssetOwner").finish(),
            Self::AssetManager => fmt.debug_tuple("ProxyType::AssetManager").finish(),
            Self::Collator => fmt.debug_tuple("ProxyType::Collator").finish(),
            _ => Ok(()),
        }
    }
}
const _: () = {
    impl ::codec::MaxEncodedLen for ProxyType {
        fn max_encoded_len() -> ::core::primitive::usize {
            0_usize
                .max(0_usize)
                .max(0_usize)
                .max(0_usize)
                .max(0_usize)
                .max(0_usize)
                .max(0_usize)
                .max(0_usize)
                .saturating_add(1)
        }
    }
};
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl ::scale_info::TypeInfo for ProxyType {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(::scale_info::Path::new("ProxyType", "asset_hub_kusama_runtime"))
                .type_params(::alloc::vec::Vec::new())
                .docs(&["The type used to represent the kinds of proxying allowed."])
                .variant(
                    ::scale_info::build::Variants::new()
                        .variant(
                            "Any",
                            |v| {
                                v
                                    .index(0usize as ::core::primitive::u8)
                                    .docs(
                                        &[
                                            "Fully permissioned proxy. Can execute any call on behalf of _proxied_.",
                                        ],
                                    )
                            },
                        )
                        .variant(
                            "NonTransfer",
                            |v| {
                                v
                                    .index(1usize as ::core::primitive::u8)
                                    .docs(
                                        &[
                                            "Can execute any call that does not transfer funds or assets.",
                                        ],
                                    )
                            },
                        )
                        .variant(
                            "CancelProxy",
                            |v| {
                                v
                                    .index(2usize as ::core::primitive::u8)
                                    .docs(
                                        &[
                                            "Proxy with the ability to reject time-delay proxy announcements.",
                                        ],
                                    )
                            },
                        )
                        .variant(
                            "Assets",
                            |v| {
                                v
                                    .index(3usize as ::core::primitive::u8)
                                    .docs(
                                        &[
                                            "Assets proxy. Can execute any call from `assets`, **including asset transfers**.",
                                        ],
                                    )
                            },
                        )
                        .variant(
                            "AssetOwner",
                            |v| {
                                v
                                    .index(4usize as ::core::primitive::u8)
                                    .docs(
                                        &[
                                            "Owner proxy. Can execute calls related to asset ownership.",
                                        ],
                                    )
                            },
                        )
                        .variant(
                            "AssetManager",
                            |v| {
                                v
                                    .index(5usize as ::core::primitive::u8)
                                    .docs(
                                        &[
                                            "Asset manager. Can execute calls related to asset management.",
                                        ],
                                    )
                            },
                        )
                        .variant(
                            "Collator",
                            |v| {
                                v
                                    .index(6usize as ::core::primitive::u8)
                                    .docs(
                                        &[
                                            "Collator selection proxy. Can execute calls related to collator selection mechanism.",
                                        ],
                                    )
                            },
                        ),
                )
        }
    }
};
impl Default for ProxyType {
    fn default() -> Self {
        Self::Any
    }
}
impl InstanceFilter<RuntimeCall> for ProxyType {
    fn filter(&self, c: &RuntimeCall) -> bool {
        match self {
            ProxyType::Any => true,
            ProxyType::NonTransfer => {
                !match c {
                    RuntimeCall::Balances { .. }
                    | RuntimeCall::Assets { .. }
                    | RuntimeCall::NftFractionalization { .. }
                    | RuntimeCall::Nfts { .. }
                    | RuntimeCall::Uniques { .. } => true,
                    _ => false,
                }
            }
            ProxyType::CancelProxy => {
                match c {
                    RuntimeCall::Proxy(pallet_proxy::Call::reject_announcement { .. })
                    | RuntimeCall::Utility { .. }
                    | RuntimeCall::Multisig { .. } => true,
                    _ => false,
                }
            }
            ProxyType::Assets => {
                match c {
                    RuntimeCall::Assets { .. }
                    | RuntimeCall::Utility { .. }
                    | RuntimeCall::Multisig { .. }
                    | RuntimeCall::NftFractionalization { .. }
                    | RuntimeCall::Nfts { .. }
                    | RuntimeCall::Uniques { .. } => true,
                    _ => false,
                }
            }
            ProxyType::AssetOwner => {
                match c {
                    RuntimeCall::Assets(TrustBackedAssetsCall::create { .. })
                    | RuntimeCall::Assets(TrustBackedAssetsCall::start_destroy { .. })
                    | RuntimeCall::Assets(TrustBackedAssetsCall::destroy_accounts { .. })
                    | RuntimeCall::Assets(
                        TrustBackedAssetsCall::destroy_approvals { .. },
                    )
                    | RuntimeCall::Assets(TrustBackedAssetsCall::finish_destroy { .. })
                    | RuntimeCall::Assets(
                        TrustBackedAssetsCall::transfer_ownership { .. },
                    )
                    | RuntimeCall::Assets(TrustBackedAssetsCall::set_team { .. })
                    | RuntimeCall::Assets(TrustBackedAssetsCall::set_metadata { .. })
                    | RuntimeCall::Assets(TrustBackedAssetsCall::clear_metadata { .. })
                    | RuntimeCall::Assets(TrustBackedAssetsCall::set_min_balance { .. })
                    | RuntimeCall::Nfts(pallet_nfts::Call::create { .. })
                    | RuntimeCall::Nfts(pallet_nfts::Call::destroy { .. })
                    | RuntimeCall::Nfts(pallet_nfts::Call::redeposit { .. })
                    | RuntimeCall::Nfts(pallet_nfts::Call::transfer_ownership { .. })
                    | RuntimeCall::Nfts(pallet_nfts::Call::set_team { .. })
                    | RuntimeCall::Nfts(
                        pallet_nfts::Call::set_collection_max_supply { .. },
                    )
                    | RuntimeCall::Nfts(pallet_nfts::Call::lock_collection { .. })
                    | RuntimeCall::Uniques(pallet_uniques::Call::create { .. })
                    | RuntimeCall::Uniques(pallet_uniques::Call::destroy { .. })
                    | RuntimeCall::Uniques(
                        pallet_uniques::Call::transfer_ownership { .. },
                    )
                    | RuntimeCall::Uniques(pallet_uniques::Call::set_team { .. })
                    | RuntimeCall::Uniques(pallet_uniques::Call::set_metadata { .. })
                    | RuntimeCall::Uniques(pallet_uniques::Call::set_attribute { .. })
                    | RuntimeCall::Uniques(
                        pallet_uniques::Call::set_collection_metadata { .. },
                    )
                    | RuntimeCall::Uniques(pallet_uniques::Call::clear_metadata { .. })
                    | RuntimeCall::Uniques(pallet_uniques::Call::clear_attribute { .. })
                    | RuntimeCall::Uniques(
                        pallet_uniques::Call::clear_collection_metadata { .. },
                    )
                    | RuntimeCall::Uniques(
                        pallet_uniques::Call::set_collection_max_supply { .. },
                    )
                    | RuntimeCall::Utility { .. }
                    | RuntimeCall::Multisig { .. } => true,
                    _ => false,
                }
            }
            ProxyType::AssetManager => {
                match c {
                    RuntimeCall::Assets(TrustBackedAssetsCall::mint { .. })
                    | RuntimeCall::Assets(TrustBackedAssetsCall::burn { .. })
                    | RuntimeCall::Assets(TrustBackedAssetsCall::freeze { .. })
                    | RuntimeCall::Assets(TrustBackedAssetsCall::block { .. })
                    | RuntimeCall::Assets(TrustBackedAssetsCall::thaw { .. })
                    | RuntimeCall::Assets(TrustBackedAssetsCall::freeze_asset { .. })
                    | RuntimeCall::Assets(TrustBackedAssetsCall::thaw_asset { .. })
                    | RuntimeCall::Assets(TrustBackedAssetsCall::touch_other { .. })
                    | RuntimeCall::Assets(TrustBackedAssetsCall::refund_other { .. })
                    | RuntimeCall::Nfts(pallet_nfts::Call::force_mint { .. })
                    | RuntimeCall::Nfts(pallet_nfts::Call::update_mint_settings { .. })
                    | RuntimeCall::Nfts(pallet_nfts::Call::mint_pre_signed { .. })
                    | RuntimeCall::Nfts(
                        pallet_nfts::Call::set_attributes_pre_signed { .. },
                    )
                    | RuntimeCall::Nfts(pallet_nfts::Call::lock_item_transfer { .. })
                    | RuntimeCall::Nfts(pallet_nfts::Call::unlock_item_transfer { .. })
                    | RuntimeCall::Nfts(pallet_nfts::Call::lock_item_properties { .. })
                    | RuntimeCall::Nfts(pallet_nfts::Call::set_metadata { .. })
                    | RuntimeCall::Nfts(pallet_nfts::Call::clear_metadata { .. })
                    | RuntimeCall::Nfts(
                        pallet_nfts::Call::set_collection_metadata { .. },
                    )
                    | RuntimeCall::Nfts(
                        pallet_nfts::Call::clear_collection_metadata { .. },
                    )
                    | RuntimeCall::Uniques(pallet_uniques::Call::mint { .. })
                    | RuntimeCall::Uniques(pallet_uniques::Call::burn { .. })
                    | RuntimeCall::Uniques(pallet_uniques::Call::freeze { .. })
                    | RuntimeCall::Uniques(pallet_uniques::Call::thaw { .. })
                    | RuntimeCall::Uniques(
                        pallet_uniques::Call::freeze_collection { .. },
                    )
                    | RuntimeCall::Uniques(pallet_uniques::Call::thaw_collection { .. })
                    | RuntimeCall::Utility { .. }
                    | RuntimeCall::Multisig { .. } => true,
                    _ => false,
                }
            }
            ProxyType::Collator => {
                match c {
                    RuntimeCall::CollatorSelection { .. }
                    | RuntimeCall::Utility { .. }
                    | RuntimeCall::Multisig { .. } => true,
                    _ => false,
                }
            }
        }
    }
    fn is_superset(&self, o: &Self) -> bool {
        match (self, o) {
            (x, y) if x == y => true,
            (ProxyType::Any, _) => true,
            (_, ProxyType::Any) => false,
            (ProxyType::Assets, ProxyType::AssetOwner) => true,
            (ProxyType::Assets, ProxyType::AssetManager) => true,
            (ProxyType::NonTransfer, ProxyType::Collator) => true,
            _ => false,
        }
    }
}
impl pallet_proxy::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type RuntimeCall = RuntimeCall;
    type Currency = Balances;
    type ProxyType = ProxyType;
    type ProxyDepositBase = ProxyDepositBase;
    type ProxyDepositFactor = ProxyDepositFactor;
    type MaxProxies = MaxProxies;
    type WeightInfo = weights::pallet_proxy::WeightInfo<Runtime>;
    type MaxPending = MaxPending;
    type CallHasher = BlakeTwo256;
    type AnnouncementDepositBase = AnnouncementDepositBase;
    type AnnouncementDepositFactor = AnnouncementDepositFactor;
}
pub struct ReservedXcmpWeight;
impl ReservedXcmpWeight {
    /// Returns the value of this parameter type.
    pub const fn get() -> Weight {
        MAXIMUM_BLOCK_WEIGHT.saturating_div(4)
    }
}
impl<_I: From<Weight>> ::frame_support::traits::Get<_I> for ReservedXcmpWeight {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for ReservedXcmpWeight {
    type Type = Weight;
    fn get() -> Weight {
        Self::get()
    }
}
pub struct ReservedDmpWeight;
impl ReservedDmpWeight {
    /// Returns the value of this parameter type.
    pub const fn get() -> Weight {
        MAXIMUM_BLOCK_WEIGHT.saturating_div(4)
    }
}
impl<_I: From<Weight>> ::frame_support::traits::Get<_I> for ReservedDmpWeight {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for ReservedDmpWeight {
    type Type = Weight;
    fn get() -> Weight {
        Self::get()
    }
}
impl cumulus_pallet_parachain_system::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type OnSystemEvent = ();
    type SelfParaId = parachain_info::Pallet<Runtime>;
    type DmpMessageHandler = DmpQueue;
    type ReservedDmpWeight = ReservedDmpWeight;
    type OutboundXcmpMessageSource = XcmpQueue;
    type XcmpMessageHandler = XcmpQueue;
    type ReservedXcmpWeight = ReservedXcmpWeight;
    type CheckAssociatedRelayNumber = RelayNumberStrictlyIncreases;
    type ConsensusHook = cumulus_pallet_aura_ext::FixedVelocityConsensusHook<
        Runtime,
        RELAY_CHAIN_SLOT_DURATION_MILLIS,
        BLOCK_PROCESSING_VELOCITY,
        UNINCLUDED_SEGMENT_CAPACITY,
    >;
}
impl parachain_info::Config for Runtime {}
impl cumulus_pallet_aura_ext::Config for Runtime {}
pub struct FellowsBodyId;
impl FellowsBodyId {
    /// Returns the value of this parameter type.
    pub const fn get() -> BodyId {
        BodyId::Technical
    }
}
impl<_I: From<BodyId>> ::frame_support::traits::Get<_I> for FellowsBodyId {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for FellowsBodyId {
    type Type = BodyId;
    fn get() -> BodyId {
        Self::get()
    }
}
impl cumulus_pallet_xcmp_queue::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type XcmExecutor = XcmExecutor<XcmConfig>;
    type ChannelInfo = ParachainSystem;
    type VersionWrapper = PolkadotXcm;
    type ExecuteOverweightOrigin = EnsureRoot<AccountId>;
    type ControllerOrigin = EitherOfDiverse<
        EnsureRoot<AccountId>,
        EnsureXcm<IsVoiceOfBody<FellowshipLocation, FellowsBodyId>>,
    >;
    type ControllerOriginConverter = xcm_config::XcmOriginToTransactDispatchOrigin;
    type WeightInfo = weights::cumulus_pallet_xcmp_queue::WeightInfo<Runtime>;
    type PriceForSiblingDelivery = ();
}
impl cumulus_pallet_dmp_queue::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type XcmExecutor = XcmExecutor<XcmConfig>;
    type ExecuteOverweightOrigin = EnsureRoot<AccountId>;
}
pub struct Period;
impl Period {
    /// Returns the value of this parameter type.
    pub const fn get() -> u32 {
        6 * HOURS
    }
}
impl<_I: From<u32>> ::frame_support::traits::Get<_I> for Period {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for Period {
    type Type = u32;
    fn get() -> u32 {
        Self::get()
    }
}
pub struct Offset;
impl Offset {
    /// Returns the value of this parameter type.
    pub const fn get() -> u32 {
        0
    }
}
impl<_I: From<u32>> ::frame_support::traits::Get<_I> for Offset {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for Offset {
    type Type = u32;
    fn get() -> u32 {
        Self::get()
    }
}
impl pallet_session::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type ValidatorId = <Self as frame_system::Config>::AccountId;
    type ValidatorIdOf = pallet_collator_selection::IdentityCollator;
    type ShouldEndSession = pallet_session::PeriodicSessions<Period, Offset>;
    type NextSessionRotation = pallet_session::PeriodicSessions<Period, Offset>;
    type SessionManager = CollatorSelection;
    type SessionHandler = <SessionKeys as sp_runtime::traits::OpaqueKeys>::KeyTypeIdProviders;
    type Keys = SessionKeys;
    type WeightInfo = weights::pallet_session::WeightInfo<Runtime>;
}
impl pallet_aura::Config for Runtime {
    type AuthorityId = AuraId;
    type DisabledValidators = ();
    type MaxAuthorities = ConstU32<100_000>;
    type AllowMultipleBlocksPerSlot = ConstBool<false>;
}
pub struct PotId;
impl PotId {
    /// Returns the value of this parameter type.
    pub const fn get() -> PalletId {
        PalletId(*b"PotStake")
    }
}
impl<_I: From<PalletId>> ::frame_support::traits::Get<_I> for PotId {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for PotId {
    type Type = PalletId;
    fn get() -> PalletId {
        Self::get()
    }
}
pub struct SessionLength;
impl SessionLength {
    /// Returns the value of this parameter type.
    pub const fn get() -> BlockNumber {
        6 * HOURS
    }
}
impl<_I: From<BlockNumber>> ::frame_support::traits::Get<_I> for SessionLength {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for SessionLength {
    type Type = BlockNumber;
    fn get() -> BlockNumber {
        Self::get()
    }
}
pub struct StakingAdminBodyId;
impl StakingAdminBodyId {
    /// Returns the value of this parameter type.
    pub const fn get() -> BodyId {
        BodyId::Defense
    }
}
impl<_I: From<BodyId>> ::frame_support::traits::Get<_I> for StakingAdminBodyId {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for StakingAdminBodyId {
    type Type = BodyId;
    fn get() -> BodyId {
        Self::get()
    }
}
/// We allow root and the `StakingAdmin` to execute privileged collator selection operations.
pub type CollatorSelectionUpdateOrigin = EitherOfDiverse<
    EnsureRoot<AccountId>,
    EnsureXcm<IsVoiceOfBody<GovernanceLocation, StakingAdminBodyId>>,
>;
impl pallet_collator_selection::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type Currency = Balances;
    type UpdateOrigin = CollatorSelectionUpdateOrigin;
    type PotId = PotId;
    type MaxCandidates = ConstU32<100>;
    type MinEligibleCollators = ConstU32<4>;
    type MaxInvulnerables = ConstU32<20>;
    type KickThreshold = Period;
    type ValidatorId = <Self as frame_system::Config>::AccountId;
    type ValidatorIdOf = pallet_collator_selection::IdentityCollator;
    type ValidatorRegistration = Session;
    type WeightInfo = weights::pallet_collator_selection::WeightInfo<Runtime>;
}
impl pallet_asset_conversion_tx_payment::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type Fungibles = LocalAndForeignAssets<
        Assets,
        AssetIdForTrustBackedAssetsConvert<TrustBackedAssetsPalletLocation>,
        ForeignAssets,
    >;
    type OnChargeAssetTransaction = AssetConversionAdapter<Balances, AssetConversion>;
}
pub struct UniquesCollectionDeposit;
impl UniquesCollectionDeposit {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        UNITS / 10
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for UniquesCollectionDeposit {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for UniquesCollectionDeposit {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct UniquesItemDeposit;
impl UniquesItemDeposit {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        UNITS / 1_000
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for UniquesItemDeposit {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for UniquesItemDeposit {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct UniquesMetadataDepositBase;
impl UniquesMetadataDepositBase {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        deposit(1, 129)
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for UniquesMetadataDepositBase {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for UniquesMetadataDepositBase {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct UniquesAttributeDepositBase;
impl UniquesAttributeDepositBase {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        deposit(1, 0)
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I>
for UniquesAttributeDepositBase {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for UniquesAttributeDepositBase {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct UniquesDepositPerByte;
impl UniquesDepositPerByte {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        deposit(0, 1)
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for UniquesDepositPerByte {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for UniquesDepositPerByte {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
impl pallet_uniques::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type CollectionId = u32;
    type ItemId = u32;
    type Currency = Balances;
    type ForceOrigin = AssetsForceOrigin;
    type CollectionDeposit = UniquesCollectionDeposit;
    type ItemDeposit = UniquesItemDeposit;
    type MetadataDepositBase = UniquesMetadataDepositBase;
    type AttributeDepositBase = UniquesAttributeDepositBase;
    type DepositPerByte = UniquesDepositPerByte;
    type StringLimit = ConstU32<128>;
    type KeyLimit = ConstU32<32>;
    type ValueLimit = ConstU32<64>;
    type WeightInfo = weights::pallet_uniques::WeightInfo<Runtime>;
    type CreateOrigin = AsEnsureOriginWithArg<EnsureSigned<AccountId>>;
    type Locker = ();
}
pub struct NftFractionalizationPalletId;
impl NftFractionalizationPalletId {
    /// Returns the value of this parameter type.
    pub const fn get() -> PalletId {
        PalletId(*b"fraction")
    }
}
impl<_I: From<PalletId>> ::frame_support::traits::Get<_I>
for NftFractionalizationPalletId {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for NftFractionalizationPalletId {
    type Type = PalletId;
    fn get() -> PalletId {
        Self::get()
    }
}
pub struct NewAssetSymbol;
impl NewAssetSymbol {
    /// Returns the value of this parameter type.
    pub fn get() -> BoundedVec<u8, AssetsStringLimit> {
        (*b"FRAC").to_vec().try_into().unwrap()
    }
}
impl<_I: From<BoundedVec<u8, AssetsStringLimit>>> ::frame_support::traits::Get<_I>
for NewAssetSymbol {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for NewAssetSymbol {
    type Type = BoundedVec<u8, AssetsStringLimit>;
    fn get() -> BoundedVec<u8, AssetsStringLimit> {
        Self::get()
    }
}
pub struct NewAssetName;
impl NewAssetName {
    /// Returns the value of this parameter type.
    pub fn get() -> BoundedVec<u8, AssetsStringLimit> {
        (*b"Frac").to_vec().try_into().unwrap()
    }
}
impl<_I: From<BoundedVec<u8, AssetsStringLimit>>> ::frame_support::traits::Get<_I>
for NewAssetName {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for NewAssetName {
    type Type = BoundedVec<u8, AssetsStringLimit>;
    fn get() -> BoundedVec<u8, AssetsStringLimit> {
        Self::get()
    }
}
impl pallet_nft_fractionalization::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type Deposit = AssetDeposit;
    type Currency = Balances;
    type NewAssetSymbol = NewAssetSymbol;
    type NewAssetName = NewAssetName;
    type StringLimit = AssetsStringLimit;
    type NftCollectionId = <Self as pallet_nfts::Config>::CollectionId;
    type NftId = <Self as pallet_nfts::Config>::ItemId;
    type AssetBalance = <Self as pallet_balances::Config>::Balance;
    type AssetId = <Self as pallet_assets::Config<TrustBackedAssetsInstance>>::AssetId;
    type Assets = Assets;
    type Nfts = Nfts;
    type PalletId = NftFractionalizationPalletId;
    type WeightInfo = pallet_nft_fractionalization::weights::SubstrateWeight<Runtime>;
    type RuntimeHoldReason = RuntimeHoldReason;
}
pub struct NftsPalletFeatures;
impl NftsPalletFeatures {
    /// Returns the value of this parameter type.
    pub fn get() -> PalletFeatures {
        PalletFeatures::all_enabled()
    }
}
impl<_I: From<PalletFeatures>> ::frame_support::traits::Get<_I> for NftsPalletFeatures {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for NftsPalletFeatures {
    type Type = PalletFeatures;
    fn get() -> PalletFeatures {
        Self::get()
    }
}
pub struct NftsMaxDeadlineDuration;
impl NftsMaxDeadlineDuration {
    /// Returns the value of this parameter type.
    pub const fn get() -> BlockNumber {
        12 * 30 * DAYS
    }
}
impl<_I: From<BlockNumber>> ::frame_support::traits::Get<_I>
for NftsMaxDeadlineDuration {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for NftsMaxDeadlineDuration {
    type Type = BlockNumber;
    fn get() -> BlockNumber {
        Self::get()
    }
}
pub struct NftsCollectionDeposit;
impl NftsCollectionDeposit {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        UniquesCollectionDeposit::get()
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for NftsCollectionDeposit {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for NftsCollectionDeposit {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct NftsItemDeposit;
impl NftsItemDeposit {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        UniquesItemDeposit::get()
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for NftsItemDeposit {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for NftsItemDeposit {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct NftsMetadataDepositBase;
impl NftsMetadataDepositBase {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        UniquesMetadataDepositBase::get()
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for NftsMetadataDepositBase {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for NftsMetadataDepositBase {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct NftsAttributeDepositBase;
impl NftsAttributeDepositBase {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        UniquesAttributeDepositBase::get()
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for NftsAttributeDepositBase {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for NftsAttributeDepositBase {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
pub struct NftsDepositPerByte;
impl NftsDepositPerByte {
    /// Returns the value of this parameter type.
    pub const fn get() -> Balance {
        UniquesDepositPerByte::get()
    }
}
impl<_I: From<Balance>> ::frame_support::traits::Get<_I> for NftsDepositPerByte {
    fn get() -> _I {
        _I::from(Self::get())
    }
}
impl ::frame_support::traits::TypedGet for NftsDepositPerByte {
    type Type = Balance;
    fn get() -> Balance {
        Self::get()
    }
}
impl pallet_nfts::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type CollectionId = u32;
    type ItemId = u32;
    type Currency = Balances;
    type CreateOrigin = AsEnsureOriginWithArg<EnsureSigned<AccountId>>;
    type ForceOrigin = AssetsForceOrigin;
    type Locker = ();
    type CollectionDeposit = NftsCollectionDeposit;
    type ItemDeposit = NftsItemDeposit;
    type MetadataDepositBase = NftsMetadataDepositBase;
    type AttributeDepositBase = NftsAttributeDepositBase;
    type DepositPerByte = NftsDepositPerByte;
    type StringLimit = ConstU32<256>;
    type KeyLimit = ConstU32<64>;
    type ValueLimit = ConstU32<256>;
    type ApprovalsLimit = ConstU32<20>;
    type ItemAttributesApprovalsLimit = ConstU32<30>;
    type MaxTips = ConstU32<10>;
    type MaxDeadlineDuration = NftsMaxDeadlineDuration;
    type MaxAttributesPerCall = ConstU32<10>;
    type Features = NftsPalletFeatures;
    type OffchainSignature = Signature;
    type OffchainPublic = <Signature as Verify>::Signer;
    type WeightInfo = weights::pallet_nfts::WeightInfo<Runtime>;
}
#[doc(hidden)]
mod sp_api_hidden_includes_construct_runtime {
    pub use frame_support as hidden_include;
}
const _: () = {
    #[allow(unused)]
    type __hidden_use_of_unchecked_extrinsic = <<Runtime as frame_system::Config>::Block as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Block>::Extrinsic;
};
pub struct Runtime;
#[automatically_derived]
impl ::core::clone::Clone for Runtime {
    #[inline]
    fn clone(&self) -> Runtime {
        *self
    }
}
#[automatically_derived]
impl ::core::marker::Copy for Runtime {}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for Runtime {}
#[automatically_derived]
impl ::core::cmp::PartialEq for Runtime {
    #[inline]
    fn eq(&self, other: &Runtime) -> bool {
        true
    }
}
#[automatically_derived]
impl ::core::marker::StructuralEq for Runtime {}
#[automatically_derived]
impl ::core::cmp::Eq for Runtime {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {}
}
impl core::fmt::Debug for Runtime {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        fmt.debug_tuple("Runtime").finish()
    }
}
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl ::scale_info::TypeInfo for Runtime {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(::scale_info::Path::new("Runtime", "asset_hub_kusama_runtime"))
                .type_params(::alloc::vec::Vec::new())
                .composite(::scale_info::build::Fields::unit())
        }
    }
};
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::GetRuntimeBlockType
for Runtime {
    type RuntimeBlock = <Runtime as frame_system::Config>::Block;
}
#[doc(hidden)]
trait InternalConstructRuntime {
    #[inline(always)]
    fn runtime_metadata(
        &self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::vec::Vec<
        self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::RuntimeApiMetadataIR,
    > {
        Default::default()
    }
}
#[doc(hidden)]
impl InternalConstructRuntime for &Runtime {}
#[allow(non_camel_case_types)]
pub enum RuntimeEvent {
    #[codec(index = 0u8)]
    System(frame_system::Event<Runtime>),
    #[codec(index = 1u8)]
    ParachainSystem(cumulus_pallet_parachain_system::Event<Runtime>),
    #[codec(index = 10u8)]
    Balances(pallet_balances::Event<Runtime>),
    #[codec(index = 11u8)]
    TransactionPayment(pallet_transaction_payment::Event<Runtime>),
    #[codec(index = 13u8)]
    AssetTxPayment(pallet_asset_conversion_tx_payment::Event<Runtime>),
    #[codec(index = 21u8)]
    CollatorSelection(pallet_collator_selection::Event<Runtime>),
    #[codec(index = 22u8)]
    Session(pallet_session::Event),
    #[codec(index = 30u8)]
    XcmpQueue(cumulus_pallet_xcmp_queue::Event<Runtime>),
    #[codec(index = 31u8)]
    PolkadotXcm(pallet_xcm::Event<Runtime>),
    #[codec(index = 32u8)]
    CumulusXcm(cumulus_pallet_xcm::Event<Runtime>),
    #[codec(index = 33u8)]
    DmpQueue(cumulus_pallet_dmp_queue::Event<Runtime>),
    #[codec(index = 40u8)]
    Utility(pallet_utility::Event),
    #[codec(index = 41u8)]
    Multisig(pallet_multisig::Event<Runtime>),
    #[codec(index = 42u8)]
    Proxy(pallet_proxy::Event<Runtime>),
    #[codec(index = 50u8)]
    Assets(pallet_assets::Event<Runtime, pallet_assets::Instance1>),
    #[codec(index = 51u8)]
    Uniques(pallet_uniques::Event<Runtime>),
    #[codec(index = 52u8)]
    Nfts(pallet_nfts::Event<Runtime>),
    #[codec(index = 53u8)]
    ForeignAssets(pallet_assets::Event<Runtime, pallet_assets::Instance2>),
    #[codec(index = 54u8)]
    NftFractionalization(pallet_nft_fractionalization::Event<Runtime>),
    #[codec(index = 55u8)]
    PoolAssets(pallet_assets::Event<Runtime, pallet_assets::Instance3>),
    #[codec(index = 56u8)]
    AssetConversion(pallet_asset_conversion::Event<Runtime>),
}
#[automatically_derived]
#[allow(non_camel_case_types)]
impl ::core::clone::Clone for RuntimeEvent {
    #[inline]
    fn clone(&self) -> RuntimeEvent {
        match self {
            RuntimeEvent::System(__self_0) => {
                RuntimeEvent::System(::core::clone::Clone::clone(__self_0))
            }
            RuntimeEvent::ParachainSystem(__self_0) => {
                RuntimeEvent::ParachainSystem(::core::clone::Clone::clone(__self_0))
            }
            RuntimeEvent::Balances(__self_0) => {
                RuntimeEvent::Balances(::core::clone::Clone::clone(__self_0))
            }
            RuntimeEvent::TransactionPayment(__self_0) => {
                RuntimeEvent::TransactionPayment(::core::clone::Clone::clone(__self_0))
            }
            RuntimeEvent::AssetTxPayment(__self_0) => {
                RuntimeEvent::AssetTxPayment(::core::clone::Clone::clone(__self_0))
            }
            RuntimeEvent::CollatorSelection(__self_0) => {
                RuntimeEvent::CollatorSelection(::core::clone::Clone::clone(__self_0))
            }
            RuntimeEvent::Session(__self_0) => {
                RuntimeEvent::Session(::core::clone::Clone::clone(__self_0))
            }
            RuntimeEvent::XcmpQueue(__self_0) => {
                RuntimeEvent::XcmpQueue(::core::clone::Clone::clone(__self_0))
            }
            RuntimeEvent::PolkadotXcm(__self_0) => {
                RuntimeEvent::PolkadotXcm(::core::clone::Clone::clone(__self_0))
            }
            RuntimeEvent::CumulusXcm(__self_0) => {
                RuntimeEvent::CumulusXcm(::core::clone::Clone::clone(__self_0))
            }
            RuntimeEvent::DmpQueue(__self_0) => {
                RuntimeEvent::DmpQueue(::core::clone::Clone::clone(__self_0))
            }
            RuntimeEvent::Utility(__self_0) => {
                RuntimeEvent::Utility(::core::clone::Clone::clone(__self_0))
            }
            RuntimeEvent::Multisig(__self_0) => {
                RuntimeEvent::Multisig(::core::clone::Clone::clone(__self_0))
            }
            RuntimeEvent::Proxy(__self_0) => {
                RuntimeEvent::Proxy(::core::clone::Clone::clone(__self_0))
            }
            RuntimeEvent::Assets(__self_0) => {
                RuntimeEvent::Assets(::core::clone::Clone::clone(__self_0))
            }
            RuntimeEvent::Uniques(__self_0) => {
                RuntimeEvent::Uniques(::core::clone::Clone::clone(__self_0))
            }
            RuntimeEvent::Nfts(__self_0) => {
                RuntimeEvent::Nfts(::core::clone::Clone::clone(__self_0))
            }
            RuntimeEvent::ForeignAssets(__self_0) => {
                RuntimeEvent::ForeignAssets(::core::clone::Clone::clone(__self_0))
            }
            RuntimeEvent::NftFractionalization(__self_0) => {
                RuntimeEvent::NftFractionalization(::core::clone::Clone::clone(__self_0))
            }
            RuntimeEvent::PoolAssets(__self_0) => {
                RuntimeEvent::PoolAssets(::core::clone::Clone::clone(__self_0))
            }
            RuntimeEvent::AssetConversion(__self_0) => {
                RuntimeEvent::AssetConversion(::core::clone::Clone::clone(__self_0))
            }
        }
    }
}
#[automatically_derived]
#[allow(non_camel_case_types)]
impl ::core::marker::StructuralPartialEq for RuntimeEvent {}
#[automatically_derived]
#[allow(non_camel_case_types)]
impl ::core::cmp::PartialEq for RuntimeEvent {
    #[inline]
    fn eq(&self, other: &RuntimeEvent) -> bool {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        __self_tag == __arg1_tag
            && match (self, other) {
                (RuntimeEvent::System(__self_0), RuntimeEvent::System(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (
                    RuntimeEvent::ParachainSystem(__self_0),
                    RuntimeEvent::ParachainSystem(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (RuntimeEvent::Balances(__self_0), RuntimeEvent::Balances(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (
                    RuntimeEvent::TransactionPayment(__self_0),
                    RuntimeEvent::TransactionPayment(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (
                    RuntimeEvent::AssetTxPayment(__self_0),
                    RuntimeEvent::AssetTxPayment(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (
                    RuntimeEvent::CollatorSelection(__self_0),
                    RuntimeEvent::CollatorSelection(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (RuntimeEvent::Session(__self_0), RuntimeEvent::Session(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (
                    RuntimeEvent::XcmpQueue(__self_0),
                    RuntimeEvent::XcmpQueue(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (
                    RuntimeEvent::PolkadotXcm(__self_0),
                    RuntimeEvent::PolkadotXcm(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (
                    RuntimeEvent::CumulusXcm(__self_0),
                    RuntimeEvent::CumulusXcm(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (RuntimeEvent::DmpQueue(__self_0), RuntimeEvent::DmpQueue(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (RuntimeEvent::Utility(__self_0), RuntimeEvent::Utility(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (RuntimeEvent::Multisig(__self_0), RuntimeEvent::Multisig(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (RuntimeEvent::Proxy(__self_0), RuntimeEvent::Proxy(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (RuntimeEvent::Assets(__self_0), RuntimeEvent::Assets(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (RuntimeEvent::Uniques(__self_0), RuntimeEvent::Uniques(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (RuntimeEvent::Nfts(__self_0), RuntimeEvent::Nfts(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (
                    RuntimeEvent::ForeignAssets(__self_0),
                    RuntimeEvent::ForeignAssets(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (
                    RuntimeEvent::NftFractionalization(__self_0),
                    RuntimeEvent::NftFractionalization(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (
                    RuntimeEvent::PoolAssets(__self_0),
                    RuntimeEvent::PoolAssets(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (
                    RuntimeEvent::AssetConversion(__self_0),
                    RuntimeEvent::AssetConversion(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                _ => unsafe { ::core::intrinsics::unreachable() }
            }
    }
}
#[automatically_derived]
#[allow(non_camel_case_types)]
impl ::core::marker::StructuralEq for RuntimeEvent {}
#[automatically_derived]
#[allow(non_camel_case_types)]
impl ::core::cmp::Eq for RuntimeEvent {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<frame_system::Event<Runtime>>;
        let _: ::core::cmp::AssertParamIsEq<
            cumulus_pallet_parachain_system::Event<Runtime>,
        >;
        let _: ::core::cmp::AssertParamIsEq<pallet_balances::Event<Runtime>>;
        let _: ::core::cmp::AssertParamIsEq<pallet_transaction_payment::Event<Runtime>>;
        let _: ::core::cmp::AssertParamIsEq<
            pallet_asset_conversion_tx_payment::Event<Runtime>,
        >;
        let _: ::core::cmp::AssertParamIsEq<pallet_collator_selection::Event<Runtime>>;
        let _: ::core::cmp::AssertParamIsEq<pallet_session::Event>;
        let _: ::core::cmp::AssertParamIsEq<cumulus_pallet_xcmp_queue::Event<Runtime>>;
        let _: ::core::cmp::AssertParamIsEq<pallet_xcm::Event<Runtime>>;
        let _: ::core::cmp::AssertParamIsEq<cumulus_pallet_xcm::Event<Runtime>>;
        let _: ::core::cmp::AssertParamIsEq<cumulus_pallet_dmp_queue::Event<Runtime>>;
        let _: ::core::cmp::AssertParamIsEq<pallet_utility::Event>;
        let _: ::core::cmp::AssertParamIsEq<pallet_multisig::Event<Runtime>>;
        let _: ::core::cmp::AssertParamIsEq<pallet_proxy::Event<Runtime>>;
        let _: ::core::cmp::AssertParamIsEq<
            pallet_assets::Event<Runtime, pallet_assets::Instance1>,
        >;
        let _: ::core::cmp::AssertParamIsEq<pallet_uniques::Event<Runtime>>;
        let _: ::core::cmp::AssertParamIsEq<pallet_nfts::Event<Runtime>>;
        let _: ::core::cmp::AssertParamIsEq<
            pallet_assets::Event<Runtime, pallet_assets::Instance2>,
        >;
        let _: ::core::cmp::AssertParamIsEq<
            pallet_nft_fractionalization::Event<Runtime>,
        >;
        let _: ::core::cmp::AssertParamIsEq<
            pallet_assets::Event<Runtime, pallet_assets::Instance3>,
        >;
        let _: ::core::cmp::AssertParamIsEq<pallet_asset_conversion::Event<Runtime>>;
    }
}
#[allow(deprecated)]
const _: () = {
    #[allow(non_camel_case_types)]
    #[automatically_derived]
    impl ::codec::Encode for RuntimeEvent {
        fn size_hint(&self) -> usize {
            1_usize
                + match *self {
                    RuntimeEvent::System(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeEvent::ParachainSystem(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeEvent::Balances(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeEvent::TransactionPayment(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeEvent::AssetTxPayment(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeEvent::CollatorSelection(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeEvent::Session(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeEvent::XcmpQueue(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeEvent::PolkadotXcm(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeEvent::CumulusXcm(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeEvent::DmpQueue(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeEvent::Utility(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeEvent::Multisig(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeEvent::Proxy(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeEvent::Assets(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeEvent::Uniques(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeEvent::Nfts(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeEvent::ForeignAssets(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeEvent::NftFractionalization(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeEvent::PoolAssets(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeEvent::AssetConversion(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    _ => 0_usize,
                }
        }
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            match *self {
                RuntimeEvent::System(ref aa) => {
                    __codec_dest_edqy.push_byte(0u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeEvent::ParachainSystem(ref aa) => {
                    __codec_dest_edqy.push_byte(1u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeEvent::Balances(ref aa) => {
                    __codec_dest_edqy.push_byte(10u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeEvent::TransactionPayment(ref aa) => {
                    __codec_dest_edqy.push_byte(11u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeEvent::AssetTxPayment(ref aa) => {
                    __codec_dest_edqy.push_byte(13u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeEvent::CollatorSelection(ref aa) => {
                    __codec_dest_edqy.push_byte(21u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeEvent::Session(ref aa) => {
                    __codec_dest_edqy.push_byte(22u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeEvent::XcmpQueue(ref aa) => {
                    __codec_dest_edqy.push_byte(30u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeEvent::PolkadotXcm(ref aa) => {
                    __codec_dest_edqy.push_byte(31u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeEvent::CumulusXcm(ref aa) => {
                    __codec_dest_edqy.push_byte(32u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeEvent::DmpQueue(ref aa) => {
                    __codec_dest_edqy.push_byte(33u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeEvent::Utility(ref aa) => {
                    __codec_dest_edqy.push_byte(40u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeEvent::Multisig(ref aa) => {
                    __codec_dest_edqy.push_byte(41u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeEvent::Proxy(ref aa) => {
                    __codec_dest_edqy.push_byte(42u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeEvent::Assets(ref aa) => {
                    __codec_dest_edqy.push_byte(50u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeEvent::Uniques(ref aa) => {
                    __codec_dest_edqy.push_byte(51u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeEvent::Nfts(ref aa) => {
                    __codec_dest_edqy.push_byte(52u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeEvent::ForeignAssets(ref aa) => {
                    __codec_dest_edqy.push_byte(53u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeEvent::NftFractionalization(ref aa) => {
                    __codec_dest_edqy.push_byte(54u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeEvent::PoolAssets(ref aa) => {
                    __codec_dest_edqy.push_byte(55u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeEvent::AssetConversion(ref aa) => {
                    __codec_dest_edqy.push_byte(56u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                _ => {}
            }
        }
    }
    #[automatically_derived]
    impl ::codec::EncodeLike for RuntimeEvent {}
};
#[allow(deprecated)]
const _: () = {
    #[allow(non_camel_case_types)]
    #[automatically_derived]
    impl ::codec::Decode for RuntimeEvent {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            match __codec_input_edqy
                .read_byte()
                .map_err(|e| {
                    e
                        .chain(
                            "Could not decode `RuntimeEvent`, failed to read variant byte",
                        )
                })?
            {
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 0u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::System({
                                let __codec_res_edqy = <frame_system::Event<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeEvent::System.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 1u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::ParachainSystem({
                                let __codec_res_edqy = <cumulus_pallet_parachain_system::Event<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e
                                                .chain("Could not decode `RuntimeEvent::ParachainSystem.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 10u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::Balances({
                                let __codec_res_edqy = <pallet_balances::Event<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeEvent::Balances.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 11u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::TransactionPayment({
                                let __codec_res_edqy = <pallet_transaction_payment::Event<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e
                                                .chain(
                                                    "Could not decode `RuntimeEvent::TransactionPayment.0`",
                                                ),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 13u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::AssetTxPayment({
                                let __codec_res_edqy = <pallet_asset_conversion_tx_payment::Event<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeEvent::AssetTxPayment.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 21u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::CollatorSelection({
                                let __codec_res_edqy = <pallet_collator_selection::Event<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e
                                                .chain(
                                                    "Could not decode `RuntimeEvent::CollatorSelection.0`",
                                                ),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 22u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::Session({
                                let __codec_res_edqy = <pallet_session::Event as ::codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeEvent::Session.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 30u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::XcmpQueue({
                                let __codec_res_edqy = <cumulus_pallet_xcmp_queue::Event<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeEvent::XcmpQueue.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 31u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::PolkadotXcm({
                                let __codec_res_edqy = <pallet_xcm::Event<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeEvent::PolkadotXcm.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 32u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::CumulusXcm({
                                let __codec_res_edqy = <cumulus_pallet_xcm::Event<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeEvent::CumulusXcm.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 33u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::DmpQueue({
                                let __codec_res_edqy = <cumulus_pallet_dmp_queue::Event<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeEvent::DmpQueue.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 40u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::Utility({
                                let __codec_res_edqy = <pallet_utility::Event as ::codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeEvent::Utility.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 41u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::Multisig({
                                let __codec_res_edqy = <pallet_multisig::Event<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeEvent::Multisig.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 42u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::Proxy({
                                let __codec_res_edqy = <pallet_proxy::Event<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeEvent::Proxy.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 50u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::Assets({
                                let __codec_res_edqy = <pallet_assets::Event<
                                    Runtime,
                                    pallet_assets::Instance1,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeEvent::Assets.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 51u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::Uniques({
                                let __codec_res_edqy = <pallet_uniques::Event<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeEvent::Uniques.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 52u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::Nfts({
                                let __codec_res_edqy = <pallet_nfts::Event<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeEvent::Nfts.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 53u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::ForeignAssets({
                                let __codec_res_edqy = <pallet_assets::Event<
                                    Runtime,
                                    pallet_assets::Instance2,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeEvent::ForeignAssets.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 54u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::NftFractionalization({
                                let __codec_res_edqy = <pallet_nft_fractionalization::Event<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e
                                                .chain(
                                                    "Could not decode `RuntimeEvent::NftFractionalization.0`",
                                                ),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 55u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::PoolAssets({
                                let __codec_res_edqy = <pallet_assets::Event<
                                    Runtime,
                                    pallet_assets::Instance3,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeEvent::PoolAssets.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 56u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeEvent::AssetConversion({
                                let __codec_res_edqy = <pallet_asset_conversion::Event<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e
                                                .chain("Could not decode `RuntimeEvent::AssetConversion.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                _ => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Err(
                            <_ as ::core::convert::Into<
                                _,
                            >>::into(
                                "Could not decode `RuntimeEvent`, variant doesn't exist",
                            ),
                        )
                    })();
                }
            }
        }
    }
};
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl ::scale_info::TypeInfo for RuntimeEvent {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(
                    ::scale_info::Path::new("RuntimeEvent", "asset_hub_kusama_runtime"),
                )
                .type_params(::alloc::vec::Vec::new())
                .variant(
                    ::scale_info::build::Variants::new()
                        .variant(
                            "System",
                            |v| {
                                v
                                    .index(0u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<frame_system::Event<Runtime>>()
                                                    .type_name("frame_system::Event<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "ParachainSystem",
                            |v| {
                                v
                                    .index(1u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<cumulus_pallet_parachain_system::Event<Runtime>>()
                                                    .type_name(
                                                        "cumulus_pallet_parachain_system::Event<Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Balances",
                            |v| {
                                v
                                    .index(10u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_balances::Event<Runtime>>()
                                                    .type_name("pallet_balances::Event<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "TransactionPayment",
                            |v| {
                                v
                                    .index(11u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_transaction_payment::Event<Runtime>>()
                                                    .type_name("pallet_transaction_payment::Event<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "AssetTxPayment",
                            |v| {
                                v
                                    .index(13u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_asset_conversion_tx_payment::Event<Runtime>>()
                                                    .type_name(
                                                        "pallet_asset_conversion_tx_payment::Event<Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "CollatorSelection",
                            |v| {
                                v
                                    .index(21u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_collator_selection::Event<Runtime>>()
                                                    .type_name("pallet_collator_selection::Event<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Session",
                            |v| {
                                v
                                    .index(22u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_session::Event>()
                                                    .type_name("pallet_session::Event")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "XcmpQueue",
                            |v| {
                                v
                                    .index(30u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<cumulus_pallet_xcmp_queue::Event<Runtime>>()
                                                    .type_name("cumulus_pallet_xcmp_queue::Event<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "PolkadotXcm",
                            |v| {
                                v
                                    .index(31u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_xcm::Event<Runtime>>()
                                                    .type_name("pallet_xcm::Event<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "CumulusXcm",
                            |v| {
                                v
                                    .index(32u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<cumulus_pallet_xcm::Event<Runtime>>()
                                                    .type_name("cumulus_pallet_xcm::Event<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "DmpQueue",
                            |v| {
                                v
                                    .index(33u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<cumulus_pallet_dmp_queue::Event<Runtime>>()
                                                    .type_name("cumulus_pallet_dmp_queue::Event<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Utility",
                            |v| {
                                v
                                    .index(40u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_utility::Event>()
                                                    .type_name("pallet_utility::Event")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Multisig",
                            |v| {
                                v
                                    .index(41u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_multisig::Event<Runtime>>()
                                                    .type_name("pallet_multisig::Event<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Proxy",
                            |v| {
                                v
                                    .index(42u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_proxy::Event<Runtime>>()
                                                    .type_name("pallet_proxy::Event<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Assets",
                            |v| {
                                v
                                    .index(50u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        pallet_assets::Event<Runtime, pallet_assets::Instance1>,
                                                    >()
                                                    .type_name(
                                                        "pallet_assets::Event<Runtime, pallet_assets::Instance1>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Uniques",
                            |v| {
                                v
                                    .index(51u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_uniques::Event<Runtime>>()
                                                    .type_name("pallet_uniques::Event<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Nfts",
                            |v| {
                                v
                                    .index(52u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_nfts::Event<Runtime>>()
                                                    .type_name("pallet_nfts::Event<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "ForeignAssets",
                            |v| {
                                v
                                    .index(53u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        pallet_assets::Event<Runtime, pallet_assets::Instance2>,
                                                    >()
                                                    .type_name(
                                                        "pallet_assets::Event<Runtime, pallet_assets::Instance2>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "NftFractionalization",
                            |v| {
                                v
                                    .index(54u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_nft_fractionalization::Event<Runtime>>()
                                                    .type_name("pallet_nft_fractionalization::Event<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "PoolAssets",
                            |v| {
                                v
                                    .index(55u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        pallet_assets::Event<Runtime, pallet_assets::Instance3>,
                                                    >()
                                                    .type_name(
                                                        "pallet_assets::Event<Runtime, pallet_assets::Instance3>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "AssetConversion",
                            |v| {
                                v
                                    .index(56u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_asset_conversion::Event<Runtime>>()
                                                    .type_name("pallet_asset_conversion::Event<Runtime>")
                                            }),
                                    )
                            },
                        ),
                )
        }
    }
};
impl core::fmt::Debug for RuntimeEvent {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            Self::System(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::System").field(a0).finish()
            }
            Self::ParachainSystem(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::ParachainSystem").field(a0).finish()
            }
            Self::Balances(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::Balances").field(a0).finish()
            }
            Self::TransactionPayment(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::TransactionPayment").field(a0).finish()
            }
            Self::AssetTxPayment(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::AssetTxPayment").field(a0).finish()
            }
            Self::CollatorSelection(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::CollatorSelection").field(a0).finish()
            }
            Self::Session(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::Session").field(a0).finish()
            }
            Self::XcmpQueue(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::XcmpQueue").field(a0).finish()
            }
            Self::PolkadotXcm(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::PolkadotXcm").field(a0).finish()
            }
            Self::CumulusXcm(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::CumulusXcm").field(a0).finish()
            }
            Self::DmpQueue(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::DmpQueue").field(a0).finish()
            }
            Self::Utility(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::Utility").field(a0).finish()
            }
            Self::Multisig(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::Multisig").field(a0).finish()
            }
            Self::Proxy(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::Proxy").field(a0).finish()
            }
            Self::Assets(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::Assets").field(a0).finish()
            }
            Self::Uniques(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::Uniques").field(a0).finish()
            }
            Self::Nfts(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::Nfts").field(a0).finish()
            }
            Self::ForeignAssets(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::ForeignAssets").field(a0).finish()
            }
            Self::NftFractionalization(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::NftFractionalization").field(a0).finish()
            }
            Self::PoolAssets(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::PoolAssets").field(a0).finish()
            }
            Self::AssetConversion(ref a0) => {
                fmt.debug_tuple("RuntimeEvent::AssetConversion").field(a0).finish()
            }
            _ => Ok(()),
        }
    }
}
impl From<frame_system::Event<Runtime>> for RuntimeEvent {
    fn from(x: frame_system::Event<Runtime>) -> Self {
        RuntimeEvent::System(x)
    }
}
impl TryInto<frame_system::Event<Runtime>> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        frame_system::Event<Runtime>,
        Self::Error,
    > {
        match self {
            Self::System(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<cumulus_pallet_parachain_system::Event<Runtime>> for RuntimeEvent {
    fn from(x: cumulus_pallet_parachain_system::Event<Runtime>) -> Self {
        RuntimeEvent::ParachainSystem(x)
    }
}
impl TryInto<cumulus_pallet_parachain_system::Event<Runtime>> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        cumulus_pallet_parachain_system::Event<Runtime>,
        Self::Error,
    > {
        match self {
            Self::ParachainSystem(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_balances::Event<Runtime>> for RuntimeEvent {
    fn from(x: pallet_balances::Event<Runtime>) -> Self {
        RuntimeEvent::Balances(x)
    }
}
impl TryInto<pallet_balances::Event<Runtime>> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_balances::Event<Runtime>,
        Self::Error,
    > {
        match self {
            Self::Balances(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_transaction_payment::Event<Runtime>> for RuntimeEvent {
    fn from(x: pallet_transaction_payment::Event<Runtime>) -> Self {
        RuntimeEvent::TransactionPayment(x)
    }
}
impl TryInto<pallet_transaction_payment::Event<Runtime>> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_transaction_payment::Event<Runtime>,
        Self::Error,
    > {
        match self {
            Self::TransactionPayment(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_asset_conversion_tx_payment::Event<Runtime>> for RuntimeEvent {
    fn from(x: pallet_asset_conversion_tx_payment::Event<Runtime>) -> Self {
        RuntimeEvent::AssetTxPayment(x)
    }
}
impl TryInto<pallet_asset_conversion_tx_payment::Event<Runtime>> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_asset_conversion_tx_payment::Event<Runtime>,
        Self::Error,
    > {
        match self {
            Self::AssetTxPayment(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_collator_selection::Event<Runtime>> for RuntimeEvent {
    fn from(x: pallet_collator_selection::Event<Runtime>) -> Self {
        RuntimeEvent::CollatorSelection(x)
    }
}
impl TryInto<pallet_collator_selection::Event<Runtime>> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_collator_selection::Event<Runtime>,
        Self::Error,
    > {
        match self {
            Self::CollatorSelection(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_session::Event> for RuntimeEvent {
    fn from(x: pallet_session::Event) -> Self {
        RuntimeEvent::Session(x)
    }
}
impl TryInto<pallet_session::Event> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_session::Event,
        Self::Error,
    > {
        match self {
            Self::Session(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<cumulus_pallet_xcmp_queue::Event<Runtime>> for RuntimeEvent {
    fn from(x: cumulus_pallet_xcmp_queue::Event<Runtime>) -> Self {
        RuntimeEvent::XcmpQueue(x)
    }
}
impl TryInto<cumulus_pallet_xcmp_queue::Event<Runtime>> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        cumulus_pallet_xcmp_queue::Event<Runtime>,
        Self::Error,
    > {
        match self {
            Self::XcmpQueue(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_xcm::Event<Runtime>> for RuntimeEvent {
    fn from(x: pallet_xcm::Event<Runtime>) -> Self {
        RuntimeEvent::PolkadotXcm(x)
    }
}
impl TryInto<pallet_xcm::Event<Runtime>> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_xcm::Event<Runtime>,
        Self::Error,
    > {
        match self {
            Self::PolkadotXcm(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<cumulus_pallet_xcm::Event<Runtime>> for RuntimeEvent {
    fn from(x: cumulus_pallet_xcm::Event<Runtime>) -> Self {
        RuntimeEvent::CumulusXcm(x)
    }
}
impl TryInto<cumulus_pallet_xcm::Event<Runtime>> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        cumulus_pallet_xcm::Event<Runtime>,
        Self::Error,
    > {
        match self {
            Self::CumulusXcm(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<cumulus_pallet_dmp_queue::Event<Runtime>> for RuntimeEvent {
    fn from(x: cumulus_pallet_dmp_queue::Event<Runtime>) -> Self {
        RuntimeEvent::DmpQueue(x)
    }
}
impl TryInto<cumulus_pallet_dmp_queue::Event<Runtime>> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        cumulus_pallet_dmp_queue::Event<Runtime>,
        Self::Error,
    > {
        match self {
            Self::DmpQueue(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_utility::Event> for RuntimeEvent {
    fn from(x: pallet_utility::Event) -> Self {
        RuntimeEvent::Utility(x)
    }
}
impl TryInto<pallet_utility::Event> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_utility::Event,
        Self::Error,
    > {
        match self {
            Self::Utility(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_multisig::Event<Runtime>> for RuntimeEvent {
    fn from(x: pallet_multisig::Event<Runtime>) -> Self {
        RuntimeEvent::Multisig(x)
    }
}
impl TryInto<pallet_multisig::Event<Runtime>> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_multisig::Event<Runtime>,
        Self::Error,
    > {
        match self {
            Self::Multisig(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_proxy::Event<Runtime>> for RuntimeEvent {
    fn from(x: pallet_proxy::Event<Runtime>) -> Self {
        RuntimeEvent::Proxy(x)
    }
}
impl TryInto<pallet_proxy::Event<Runtime>> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_proxy::Event<Runtime>,
        Self::Error,
    > {
        match self {
            Self::Proxy(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_assets::Event<Runtime, pallet_assets::Instance1>> for RuntimeEvent {
    fn from(x: pallet_assets::Event<Runtime, pallet_assets::Instance1>) -> Self {
        RuntimeEvent::Assets(x)
    }
}
impl TryInto<pallet_assets::Event<Runtime, pallet_assets::Instance1>> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_assets::Event<Runtime, pallet_assets::Instance1>,
        Self::Error,
    > {
        match self {
            Self::Assets(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_uniques::Event<Runtime>> for RuntimeEvent {
    fn from(x: pallet_uniques::Event<Runtime>) -> Self {
        RuntimeEvent::Uniques(x)
    }
}
impl TryInto<pallet_uniques::Event<Runtime>> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_uniques::Event<Runtime>,
        Self::Error,
    > {
        match self {
            Self::Uniques(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_nfts::Event<Runtime>> for RuntimeEvent {
    fn from(x: pallet_nfts::Event<Runtime>) -> Self {
        RuntimeEvent::Nfts(x)
    }
}
impl TryInto<pallet_nfts::Event<Runtime>> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_nfts::Event<Runtime>,
        Self::Error,
    > {
        match self {
            Self::Nfts(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_assets::Event<Runtime, pallet_assets::Instance2>> for RuntimeEvent {
    fn from(x: pallet_assets::Event<Runtime, pallet_assets::Instance2>) -> Self {
        RuntimeEvent::ForeignAssets(x)
    }
}
impl TryInto<pallet_assets::Event<Runtime, pallet_assets::Instance2>> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_assets::Event<Runtime, pallet_assets::Instance2>,
        Self::Error,
    > {
        match self {
            Self::ForeignAssets(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_nft_fractionalization::Event<Runtime>> for RuntimeEvent {
    fn from(x: pallet_nft_fractionalization::Event<Runtime>) -> Self {
        RuntimeEvent::NftFractionalization(x)
    }
}
impl TryInto<pallet_nft_fractionalization::Event<Runtime>> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_nft_fractionalization::Event<Runtime>,
        Self::Error,
    > {
        match self {
            Self::NftFractionalization(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_assets::Event<Runtime, pallet_assets::Instance3>> for RuntimeEvent {
    fn from(x: pallet_assets::Event<Runtime, pallet_assets::Instance3>) -> Self {
        RuntimeEvent::PoolAssets(x)
    }
}
impl TryInto<pallet_assets::Event<Runtime, pallet_assets::Instance3>> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_assets::Event<Runtime, pallet_assets::Instance3>,
        Self::Error,
    > {
        match self {
            Self::PoolAssets(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_asset_conversion::Event<Runtime>> for RuntimeEvent {
    fn from(x: pallet_asset_conversion::Event<Runtime>) -> Self {
        RuntimeEvent::AssetConversion(x)
    }
}
impl TryInto<pallet_asset_conversion::Event<Runtime>> for RuntimeEvent {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_asset_conversion::Event<Runtime>,
        Self::Error,
    > {
        match self {
            Self::AssetConversion(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
#[allow(non_camel_case_types)]
pub enum RuntimeError {
    #[codec(index = 0u8)]
    System(frame_system::Error<Runtime>),
    #[codec(index = 1u8)]
    ParachainSystem(cumulus_pallet_parachain_system::Error<Runtime>),
    #[codec(index = 10u8)]
    Balances(pallet_balances::Error<Runtime>),
    #[codec(index = 21u8)]
    CollatorSelection(pallet_collator_selection::Error<Runtime>),
    #[codec(index = 22u8)]
    Session(pallet_session::Error<Runtime>),
    #[codec(index = 30u8)]
    XcmpQueue(cumulus_pallet_xcmp_queue::Error<Runtime>),
    #[codec(index = 31u8)]
    PolkadotXcm(pallet_xcm::Error<Runtime>),
    #[codec(index = 32u8)]
    CumulusXcm(cumulus_pallet_xcm::Error<Runtime>),
    #[codec(index = 33u8)]
    DmpQueue(cumulus_pallet_dmp_queue::Error<Runtime>),
    #[codec(index = 40u8)]
    Utility(pallet_utility::Error<Runtime>),
    #[codec(index = 41u8)]
    Multisig(pallet_multisig::Error<Runtime>),
    #[codec(index = 42u8)]
    Proxy(pallet_proxy::Error<Runtime>),
    #[codec(index = 50u8)]
    Assets(pallet_assets::Error<Runtime, pallet_assets::Instance1>),
    #[codec(index = 51u8)]
    Uniques(pallet_uniques::Error<Runtime>),
    #[codec(index = 52u8)]
    Nfts(pallet_nfts::Error<Runtime>),
    #[codec(index = 53u8)]
    ForeignAssets(pallet_assets::Error<Runtime, pallet_assets::Instance2>),
    #[codec(index = 54u8)]
    NftFractionalization(pallet_nft_fractionalization::Error<Runtime>),
    #[codec(index = 55u8)]
    PoolAssets(pallet_assets::Error<Runtime, pallet_assets::Instance3>),
    #[codec(index = 56u8)]
    AssetConversion(pallet_asset_conversion::Error<Runtime>),
}
#[allow(deprecated)]
const _: () = {
    #[allow(non_camel_case_types)]
    #[automatically_derived]
    impl ::codec::Encode for RuntimeError {
        fn size_hint(&self) -> usize {
            1_usize
                + match *self {
                    RuntimeError::System(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeError::ParachainSystem(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeError::Balances(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeError::CollatorSelection(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeError::Session(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeError::XcmpQueue(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeError::PolkadotXcm(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeError::CumulusXcm(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeError::DmpQueue(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeError::Utility(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeError::Multisig(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeError::Proxy(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeError::Assets(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeError::Uniques(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeError::Nfts(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeError::ForeignAssets(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeError::NftFractionalization(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeError::PoolAssets(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeError::AssetConversion(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    _ => 0_usize,
                }
        }
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            match *self {
                RuntimeError::System(ref aa) => {
                    __codec_dest_edqy.push_byte(0u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeError::ParachainSystem(ref aa) => {
                    __codec_dest_edqy.push_byte(1u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeError::Balances(ref aa) => {
                    __codec_dest_edqy.push_byte(10u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeError::CollatorSelection(ref aa) => {
                    __codec_dest_edqy.push_byte(21u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeError::Session(ref aa) => {
                    __codec_dest_edqy.push_byte(22u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeError::XcmpQueue(ref aa) => {
                    __codec_dest_edqy.push_byte(30u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeError::PolkadotXcm(ref aa) => {
                    __codec_dest_edqy.push_byte(31u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeError::CumulusXcm(ref aa) => {
                    __codec_dest_edqy.push_byte(32u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeError::DmpQueue(ref aa) => {
                    __codec_dest_edqy.push_byte(33u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeError::Utility(ref aa) => {
                    __codec_dest_edqy.push_byte(40u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeError::Multisig(ref aa) => {
                    __codec_dest_edqy.push_byte(41u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeError::Proxy(ref aa) => {
                    __codec_dest_edqy.push_byte(42u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeError::Assets(ref aa) => {
                    __codec_dest_edqy.push_byte(50u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeError::Uniques(ref aa) => {
                    __codec_dest_edqy.push_byte(51u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeError::Nfts(ref aa) => {
                    __codec_dest_edqy.push_byte(52u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeError::ForeignAssets(ref aa) => {
                    __codec_dest_edqy.push_byte(53u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeError::NftFractionalization(ref aa) => {
                    __codec_dest_edqy.push_byte(54u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeError::PoolAssets(ref aa) => {
                    __codec_dest_edqy.push_byte(55u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeError::AssetConversion(ref aa) => {
                    __codec_dest_edqy.push_byte(56u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                _ => {}
            }
        }
    }
    #[automatically_derived]
    impl ::codec::EncodeLike for RuntimeError {}
};
#[allow(deprecated)]
const _: () = {
    #[allow(non_camel_case_types)]
    #[automatically_derived]
    impl ::codec::Decode for RuntimeError {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            match __codec_input_edqy
                .read_byte()
                .map_err(|e| {
                    e
                        .chain(
                            "Could not decode `RuntimeError`, failed to read variant byte",
                        )
                })?
            {
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 0u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeError::System({
                                let __codec_res_edqy = <frame_system::Error<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeError::System.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 1u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeError::ParachainSystem({
                                let __codec_res_edqy = <cumulus_pallet_parachain_system::Error<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e
                                                .chain("Could not decode `RuntimeError::ParachainSystem.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 10u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeError::Balances({
                                let __codec_res_edqy = <pallet_balances::Error<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeError::Balances.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 21u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeError::CollatorSelection({
                                let __codec_res_edqy = <pallet_collator_selection::Error<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e
                                                .chain(
                                                    "Could not decode `RuntimeError::CollatorSelection.0`",
                                                ),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 22u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeError::Session({
                                let __codec_res_edqy = <pallet_session::Error<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeError::Session.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 30u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeError::XcmpQueue({
                                let __codec_res_edqy = <cumulus_pallet_xcmp_queue::Error<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeError::XcmpQueue.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 31u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeError::PolkadotXcm({
                                let __codec_res_edqy = <pallet_xcm::Error<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeError::PolkadotXcm.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 32u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeError::CumulusXcm({
                                let __codec_res_edqy = <cumulus_pallet_xcm::Error<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeError::CumulusXcm.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 33u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeError::DmpQueue({
                                let __codec_res_edqy = <cumulus_pallet_dmp_queue::Error<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeError::DmpQueue.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 40u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeError::Utility({
                                let __codec_res_edqy = <pallet_utility::Error<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeError::Utility.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 41u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeError::Multisig({
                                let __codec_res_edqy = <pallet_multisig::Error<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeError::Multisig.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 42u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeError::Proxy({
                                let __codec_res_edqy = <pallet_proxy::Error<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeError::Proxy.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 50u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeError::Assets({
                                let __codec_res_edqy = <pallet_assets::Error<
                                    Runtime,
                                    pallet_assets::Instance1,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeError::Assets.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 51u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeError::Uniques({
                                let __codec_res_edqy = <pallet_uniques::Error<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeError::Uniques.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 52u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeError::Nfts({
                                let __codec_res_edqy = <pallet_nfts::Error<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeError::Nfts.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 53u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeError::ForeignAssets({
                                let __codec_res_edqy = <pallet_assets::Error<
                                    Runtime,
                                    pallet_assets::Instance2,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeError::ForeignAssets.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 54u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeError::NftFractionalization({
                                let __codec_res_edqy = <pallet_nft_fractionalization::Error<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e
                                                .chain(
                                                    "Could not decode `RuntimeError::NftFractionalization.0`",
                                                ),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 55u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeError::PoolAssets({
                                let __codec_res_edqy = <pallet_assets::Error<
                                    Runtime,
                                    pallet_assets::Instance3,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeError::PoolAssets.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 56u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeError::AssetConversion({
                                let __codec_res_edqy = <pallet_asset_conversion::Error<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e
                                                .chain("Could not decode `RuntimeError::AssetConversion.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                _ => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Err(
                            <_ as ::core::convert::Into<
                                _,
                            >>::into(
                                "Could not decode `RuntimeError`, variant doesn't exist",
                            ),
                        )
                    })();
                }
            }
        }
    }
};
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl ::scale_info::TypeInfo for RuntimeError {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(
                    ::scale_info::Path::new("RuntimeError", "asset_hub_kusama_runtime"),
                )
                .type_params(::alloc::vec::Vec::new())
                .variant(
                    ::scale_info::build::Variants::new()
                        .variant(
                            "System",
                            |v| {
                                v
                                    .index(0u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<frame_system::Error<Runtime>>()
                                                    .type_name("frame_system::Error<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "ParachainSystem",
                            |v| {
                                v
                                    .index(1u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<cumulus_pallet_parachain_system::Error<Runtime>>()
                                                    .type_name(
                                                        "cumulus_pallet_parachain_system::Error<Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Balances",
                            |v| {
                                v
                                    .index(10u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_balances::Error<Runtime>>()
                                                    .type_name("pallet_balances::Error<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "CollatorSelection",
                            |v| {
                                v
                                    .index(21u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_collator_selection::Error<Runtime>>()
                                                    .type_name("pallet_collator_selection::Error<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Session",
                            |v| {
                                v
                                    .index(22u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_session::Error<Runtime>>()
                                                    .type_name("pallet_session::Error<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "XcmpQueue",
                            |v| {
                                v
                                    .index(30u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<cumulus_pallet_xcmp_queue::Error<Runtime>>()
                                                    .type_name("cumulus_pallet_xcmp_queue::Error<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "PolkadotXcm",
                            |v| {
                                v
                                    .index(31u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_xcm::Error<Runtime>>()
                                                    .type_name("pallet_xcm::Error<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "CumulusXcm",
                            |v| {
                                v
                                    .index(32u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<cumulus_pallet_xcm::Error<Runtime>>()
                                                    .type_name("cumulus_pallet_xcm::Error<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "DmpQueue",
                            |v| {
                                v
                                    .index(33u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<cumulus_pallet_dmp_queue::Error<Runtime>>()
                                                    .type_name("cumulus_pallet_dmp_queue::Error<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Utility",
                            |v| {
                                v
                                    .index(40u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_utility::Error<Runtime>>()
                                                    .type_name("pallet_utility::Error<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Multisig",
                            |v| {
                                v
                                    .index(41u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_multisig::Error<Runtime>>()
                                                    .type_name("pallet_multisig::Error<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Proxy",
                            |v| {
                                v
                                    .index(42u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_proxy::Error<Runtime>>()
                                                    .type_name("pallet_proxy::Error<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Assets",
                            |v| {
                                v
                                    .index(50u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        pallet_assets::Error<Runtime, pallet_assets::Instance1>,
                                                    >()
                                                    .type_name(
                                                        "pallet_assets::Error<Runtime, pallet_assets::Instance1>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Uniques",
                            |v| {
                                v
                                    .index(51u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_uniques::Error<Runtime>>()
                                                    .type_name("pallet_uniques::Error<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Nfts",
                            |v| {
                                v
                                    .index(52u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_nfts::Error<Runtime>>()
                                                    .type_name("pallet_nfts::Error<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "ForeignAssets",
                            |v| {
                                v
                                    .index(53u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        pallet_assets::Error<Runtime, pallet_assets::Instance2>,
                                                    >()
                                                    .type_name(
                                                        "pallet_assets::Error<Runtime, pallet_assets::Instance2>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "NftFractionalization",
                            |v| {
                                v
                                    .index(54u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_nft_fractionalization::Error<Runtime>>()
                                                    .type_name("pallet_nft_fractionalization::Error<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "PoolAssets",
                            |v| {
                                v
                                    .index(55u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        pallet_assets::Error<Runtime, pallet_assets::Instance3>,
                                                    >()
                                                    .type_name(
                                                        "pallet_assets::Error<Runtime, pallet_assets::Instance3>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "AssetConversion",
                            |v| {
                                v
                                    .index(56u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_asset_conversion::Error<Runtime>>()
                                                    .type_name("pallet_asset_conversion::Error<Runtime>")
                                            }),
                                    )
                            },
                        ),
                )
        }
    }
};
impl core::fmt::Debug for RuntimeError {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            Self::System(ref a0) => {
                fmt.debug_tuple("RuntimeError::System").field(a0).finish()
            }
            Self::ParachainSystem(ref a0) => {
                fmt.debug_tuple("RuntimeError::ParachainSystem").field(a0).finish()
            }
            Self::Balances(ref a0) => {
                fmt.debug_tuple("RuntimeError::Balances").field(a0).finish()
            }
            Self::CollatorSelection(ref a0) => {
                fmt.debug_tuple("RuntimeError::CollatorSelection").field(a0).finish()
            }
            Self::Session(ref a0) => {
                fmt.debug_tuple("RuntimeError::Session").field(a0).finish()
            }
            Self::XcmpQueue(ref a0) => {
                fmt.debug_tuple("RuntimeError::XcmpQueue").field(a0).finish()
            }
            Self::PolkadotXcm(ref a0) => {
                fmt.debug_tuple("RuntimeError::PolkadotXcm").field(a0).finish()
            }
            Self::CumulusXcm(ref a0) => {
                fmt.debug_tuple("RuntimeError::CumulusXcm").field(a0).finish()
            }
            Self::DmpQueue(ref a0) => {
                fmt.debug_tuple("RuntimeError::DmpQueue").field(a0).finish()
            }
            Self::Utility(ref a0) => {
                fmt.debug_tuple("RuntimeError::Utility").field(a0).finish()
            }
            Self::Multisig(ref a0) => {
                fmt.debug_tuple("RuntimeError::Multisig").field(a0).finish()
            }
            Self::Proxy(ref a0) => {
                fmt.debug_tuple("RuntimeError::Proxy").field(a0).finish()
            }
            Self::Assets(ref a0) => {
                fmt.debug_tuple("RuntimeError::Assets").field(a0).finish()
            }
            Self::Uniques(ref a0) => {
                fmt.debug_tuple("RuntimeError::Uniques").field(a0).finish()
            }
            Self::Nfts(ref a0) => {
                fmt.debug_tuple("RuntimeError::Nfts").field(a0).finish()
            }
            Self::ForeignAssets(ref a0) => {
                fmt.debug_tuple("RuntimeError::ForeignAssets").field(a0).finish()
            }
            Self::NftFractionalization(ref a0) => {
                fmt.debug_tuple("RuntimeError::NftFractionalization").field(a0).finish()
            }
            Self::PoolAssets(ref a0) => {
                fmt.debug_tuple("RuntimeError::PoolAssets").field(a0).finish()
            }
            Self::AssetConversion(ref a0) => {
                fmt.debug_tuple("RuntimeError::AssetConversion").field(a0).finish()
            }
            _ => Ok(()),
        }
    }
}
impl From<frame_system::Error<Runtime>> for RuntimeError {
    fn from(x: frame_system::Error<Runtime>) -> Self {
        RuntimeError::System(x)
    }
}
impl TryInto<frame_system::Error<Runtime>> for RuntimeError {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        frame_system::Error<Runtime>,
        Self::Error,
    > {
        match self {
            Self::System(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<cumulus_pallet_parachain_system::Error<Runtime>> for RuntimeError {
    fn from(x: cumulus_pallet_parachain_system::Error<Runtime>) -> Self {
        RuntimeError::ParachainSystem(x)
    }
}
impl TryInto<cumulus_pallet_parachain_system::Error<Runtime>> for RuntimeError {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        cumulus_pallet_parachain_system::Error<Runtime>,
        Self::Error,
    > {
        match self {
            Self::ParachainSystem(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_balances::Error<Runtime>> for RuntimeError {
    fn from(x: pallet_balances::Error<Runtime>) -> Self {
        RuntimeError::Balances(x)
    }
}
impl TryInto<pallet_balances::Error<Runtime>> for RuntimeError {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_balances::Error<Runtime>,
        Self::Error,
    > {
        match self {
            Self::Balances(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_collator_selection::Error<Runtime>> for RuntimeError {
    fn from(x: pallet_collator_selection::Error<Runtime>) -> Self {
        RuntimeError::CollatorSelection(x)
    }
}
impl TryInto<pallet_collator_selection::Error<Runtime>> for RuntimeError {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_collator_selection::Error<Runtime>,
        Self::Error,
    > {
        match self {
            Self::CollatorSelection(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_session::Error<Runtime>> for RuntimeError {
    fn from(x: pallet_session::Error<Runtime>) -> Self {
        RuntimeError::Session(x)
    }
}
impl TryInto<pallet_session::Error<Runtime>> for RuntimeError {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_session::Error<Runtime>,
        Self::Error,
    > {
        match self {
            Self::Session(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<cumulus_pallet_xcmp_queue::Error<Runtime>> for RuntimeError {
    fn from(x: cumulus_pallet_xcmp_queue::Error<Runtime>) -> Self {
        RuntimeError::XcmpQueue(x)
    }
}
impl TryInto<cumulus_pallet_xcmp_queue::Error<Runtime>> for RuntimeError {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        cumulus_pallet_xcmp_queue::Error<Runtime>,
        Self::Error,
    > {
        match self {
            Self::XcmpQueue(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_xcm::Error<Runtime>> for RuntimeError {
    fn from(x: pallet_xcm::Error<Runtime>) -> Self {
        RuntimeError::PolkadotXcm(x)
    }
}
impl TryInto<pallet_xcm::Error<Runtime>> for RuntimeError {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_xcm::Error<Runtime>,
        Self::Error,
    > {
        match self {
            Self::PolkadotXcm(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<cumulus_pallet_xcm::Error<Runtime>> for RuntimeError {
    fn from(x: cumulus_pallet_xcm::Error<Runtime>) -> Self {
        RuntimeError::CumulusXcm(x)
    }
}
impl TryInto<cumulus_pallet_xcm::Error<Runtime>> for RuntimeError {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        cumulus_pallet_xcm::Error<Runtime>,
        Self::Error,
    > {
        match self {
            Self::CumulusXcm(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<cumulus_pallet_dmp_queue::Error<Runtime>> for RuntimeError {
    fn from(x: cumulus_pallet_dmp_queue::Error<Runtime>) -> Self {
        RuntimeError::DmpQueue(x)
    }
}
impl TryInto<cumulus_pallet_dmp_queue::Error<Runtime>> for RuntimeError {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        cumulus_pallet_dmp_queue::Error<Runtime>,
        Self::Error,
    > {
        match self {
            Self::DmpQueue(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_utility::Error<Runtime>> for RuntimeError {
    fn from(x: pallet_utility::Error<Runtime>) -> Self {
        RuntimeError::Utility(x)
    }
}
impl TryInto<pallet_utility::Error<Runtime>> for RuntimeError {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_utility::Error<Runtime>,
        Self::Error,
    > {
        match self {
            Self::Utility(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_multisig::Error<Runtime>> for RuntimeError {
    fn from(x: pallet_multisig::Error<Runtime>) -> Self {
        RuntimeError::Multisig(x)
    }
}
impl TryInto<pallet_multisig::Error<Runtime>> for RuntimeError {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_multisig::Error<Runtime>,
        Self::Error,
    > {
        match self {
            Self::Multisig(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_proxy::Error<Runtime>> for RuntimeError {
    fn from(x: pallet_proxy::Error<Runtime>) -> Self {
        RuntimeError::Proxy(x)
    }
}
impl TryInto<pallet_proxy::Error<Runtime>> for RuntimeError {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_proxy::Error<Runtime>,
        Self::Error,
    > {
        match self {
            Self::Proxy(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_assets::Error<Runtime, pallet_assets::Instance1>> for RuntimeError {
    fn from(x: pallet_assets::Error<Runtime, pallet_assets::Instance1>) -> Self {
        RuntimeError::Assets(x)
    }
}
impl TryInto<pallet_assets::Error<Runtime, pallet_assets::Instance1>> for RuntimeError {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_assets::Error<Runtime, pallet_assets::Instance1>,
        Self::Error,
    > {
        match self {
            Self::Assets(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_uniques::Error<Runtime>> for RuntimeError {
    fn from(x: pallet_uniques::Error<Runtime>) -> Self {
        RuntimeError::Uniques(x)
    }
}
impl TryInto<pallet_uniques::Error<Runtime>> for RuntimeError {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_uniques::Error<Runtime>,
        Self::Error,
    > {
        match self {
            Self::Uniques(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_nfts::Error<Runtime>> for RuntimeError {
    fn from(x: pallet_nfts::Error<Runtime>) -> Self {
        RuntimeError::Nfts(x)
    }
}
impl TryInto<pallet_nfts::Error<Runtime>> for RuntimeError {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_nfts::Error<Runtime>,
        Self::Error,
    > {
        match self {
            Self::Nfts(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_assets::Error<Runtime, pallet_assets::Instance2>> for RuntimeError {
    fn from(x: pallet_assets::Error<Runtime, pallet_assets::Instance2>) -> Self {
        RuntimeError::ForeignAssets(x)
    }
}
impl TryInto<pallet_assets::Error<Runtime, pallet_assets::Instance2>> for RuntimeError {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_assets::Error<Runtime, pallet_assets::Instance2>,
        Self::Error,
    > {
        match self {
            Self::ForeignAssets(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_nft_fractionalization::Error<Runtime>> for RuntimeError {
    fn from(x: pallet_nft_fractionalization::Error<Runtime>) -> Self {
        RuntimeError::NftFractionalization(x)
    }
}
impl TryInto<pallet_nft_fractionalization::Error<Runtime>> for RuntimeError {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_nft_fractionalization::Error<Runtime>,
        Self::Error,
    > {
        match self {
            Self::NftFractionalization(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_assets::Error<Runtime, pallet_assets::Instance3>> for RuntimeError {
    fn from(x: pallet_assets::Error<Runtime, pallet_assets::Instance3>) -> Self {
        RuntimeError::PoolAssets(x)
    }
}
impl TryInto<pallet_assets::Error<Runtime, pallet_assets::Instance3>> for RuntimeError {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_assets::Error<Runtime, pallet_assets::Instance3>,
        Self::Error,
    > {
        match self {
            Self::PoolAssets(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<pallet_asset_conversion::Error<Runtime>> for RuntimeError {
    fn from(x: pallet_asset_conversion::Error<Runtime>) -> Self {
        RuntimeError::AssetConversion(x)
    }
}
impl TryInto<pallet_asset_conversion::Error<Runtime>> for RuntimeError {
    type Error = ();
    fn try_into(
        self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_asset_conversion::Error<Runtime>,
        Self::Error,
    > {
        match self {
            Self::AssetConversion(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl RuntimeError {
    /// Optionally convert the `DispatchError` into the `RuntimeError`.
    ///
    /// Returns `Some` if the error matches the `DispatchError::Module` variant, otherwise `None`.
    pub fn from_dispatch_error(
        err: self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::DispatchError,
    ) -> Option<Self> {
        let self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::DispatchError::Module(
            module_error,
        ) = err else { return None };
        let bytes = self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::codec::Encode::encode(
            &module_error,
        );
        self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::codec::Decode::decode(
                &mut &bytes[..],
            )
            .ok()
    }
}
/// The runtime origin type representing the origin of a call.
///
/// Origin is always created with the base filter configured in [`frame_system::Config::BaseCallFilter`].
pub struct RuntimeOrigin {
    caller: OriginCaller,
    filter: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::rc::Rc<
        Box<dyn Fn(&<Runtime as frame_system::Config>::RuntimeCall) -> bool>,
    >,
}
#[automatically_derived]
impl ::core::clone::Clone for RuntimeOrigin {
    #[inline]
    fn clone(&self) -> RuntimeOrigin {
        RuntimeOrigin {
            caller: ::core::clone::Clone::clone(&self.caller),
            filter: ::core::clone::Clone::clone(&self.filter),
        }
    }
}
#[cfg(feature = "std")]
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::fmt::Debug
for RuntimeOrigin {
    fn fmt(
        &self,
        fmt: &mut self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::fmt::Formatter,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        (),
        self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::fmt::Error,
    > {
        fmt.debug_struct("Origin")
            .field("caller", &self.caller)
            .field("filter", &"[function ptr]")
            .finish()
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::OriginTrait
for RuntimeOrigin {
    type Call = <Runtime as frame_system::Config>::RuntimeCall;
    type PalletsOrigin = OriginCaller;
    type AccountId = <Runtime as frame_system::Config>::AccountId;
    fn add_filter(&mut self, filter: impl Fn(&Self::Call) -> bool + 'static) {
        let f = self.filter.clone();
        self
            .filter = self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::rc::Rc::new(
            Box::new(move |call| { f(call) && filter(call) }),
        );
    }
    fn reset_filter(&mut self) {
        let filter = <<Runtime as frame_system::Config>::BaseCallFilter as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::Contains<
            <Runtime as frame_system::Config>::RuntimeCall,
        >>::contains;
        self
            .filter = self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::rc::Rc::new(
            Box::new(filter),
        );
    }
    fn set_caller_from(&mut self, other: impl Into<Self>) {
        self.caller = other.into().caller;
    }
    fn filter_call(&self, call: &Self::Call) -> bool {
        match self.caller {
            OriginCaller::system(frame_system::Origin::<Runtime>::Root) => true,
            _ => (self.filter)(call),
        }
    }
    fn caller(&self) -> &Self::PalletsOrigin {
        &self.caller
    }
    fn into_caller(self) -> Self::PalletsOrigin {
        self.caller
    }
    fn try_with_caller<R>(
        mut self,
        f: impl FnOnce(Self::PalletsOrigin) -> Result<R, Self::PalletsOrigin>,
    ) -> Result<R, Self> {
        match f(self.caller) {
            Ok(r) => Ok(r),
            Err(caller) => {
                self.caller = caller;
                Err(self)
            }
        }
    }
    fn none() -> Self {
        frame_system::RawOrigin::None.into()
    }
    fn root() -> Self {
        frame_system::RawOrigin::Root.into()
    }
    fn signed(by: Self::AccountId) -> Self {
        frame_system::RawOrigin::Signed(by).into()
    }
}
#[allow(non_camel_case_types)]
pub enum OriginCaller {
    #[codec(index = 0u8)]
    system(frame_system::Origin<Runtime>),
    #[codec(index = 31u8)]
    PolkadotXcm(pallet_xcm::Origin),
    #[codec(index = 32u8)]
    CumulusXcm(cumulus_pallet_xcm::Origin),
    #[allow(dead_code)]
    Void(
        self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::Void,
    ),
}
#[automatically_derived]
#[allow(non_camel_case_types)]
impl ::core::clone::Clone for OriginCaller {
    #[inline]
    fn clone(&self) -> OriginCaller {
        match self {
            OriginCaller::system(__self_0) => {
                OriginCaller::system(::core::clone::Clone::clone(__self_0))
            }
            OriginCaller::PolkadotXcm(__self_0) => {
                OriginCaller::PolkadotXcm(::core::clone::Clone::clone(__self_0))
            }
            OriginCaller::CumulusXcm(__self_0) => {
                OriginCaller::CumulusXcm(::core::clone::Clone::clone(__self_0))
            }
            OriginCaller::Void(__self_0) => {
                OriginCaller::Void(::core::clone::Clone::clone(__self_0))
            }
        }
    }
}
#[automatically_derived]
#[allow(non_camel_case_types)]
impl ::core::marker::StructuralPartialEq for OriginCaller {}
#[automatically_derived]
#[allow(non_camel_case_types)]
impl ::core::cmp::PartialEq for OriginCaller {
    #[inline]
    fn eq(&self, other: &OriginCaller) -> bool {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        __self_tag == __arg1_tag
            && match (self, other) {
                (OriginCaller::system(__self_0), OriginCaller::system(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (
                    OriginCaller::PolkadotXcm(__self_0),
                    OriginCaller::PolkadotXcm(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (
                    OriginCaller::CumulusXcm(__self_0),
                    OriginCaller::CumulusXcm(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (OriginCaller::Void(__self_0), OriginCaller::Void(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                _ => unsafe { ::core::intrinsics::unreachable() }
            }
    }
}
#[automatically_derived]
#[allow(non_camel_case_types)]
impl ::core::marker::StructuralEq for OriginCaller {}
#[automatically_derived]
#[allow(non_camel_case_types)]
impl ::core::cmp::Eq for OriginCaller {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<frame_system::Origin<Runtime>>;
        let _: ::core::cmp::AssertParamIsEq<pallet_xcm::Origin>;
        let _: ::core::cmp::AssertParamIsEq<cumulus_pallet_xcm::Origin>;
        let _: ::core::cmp::AssertParamIsEq<
            self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::Void,
        >;
    }
}
impl core::fmt::Debug for OriginCaller {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            Self::system(ref a0) => {
                fmt.debug_tuple("OriginCaller::system").field(a0).finish()
            }
            Self::PolkadotXcm(ref a0) => {
                fmt.debug_tuple("OriginCaller::PolkadotXcm").field(a0).finish()
            }
            Self::CumulusXcm(ref a0) => {
                fmt.debug_tuple("OriginCaller::CumulusXcm").field(a0).finish()
            }
            Self::Void(ref a0) => {
                fmt.debug_tuple("OriginCaller::Void").field(a0).finish()
            }
            _ => Ok(()),
        }
    }
}
#[allow(deprecated)]
const _: () = {
    #[allow(non_camel_case_types)]
    #[automatically_derived]
    impl ::codec::Encode for OriginCaller {
        fn size_hint(&self) -> usize {
            1_usize
                + match *self {
                    OriginCaller::system(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    OriginCaller::PolkadotXcm(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    OriginCaller::CumulusXcm(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    OriginCaller::Void(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    _ => 0_usize,
                }
        }
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            match *self {
                OriginCaller::system(ref aa) => {
                    __codec_dest_edqy.push_byte(0u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                OriginCaller::PolkadotXcm(ref aa) => {
                    __codec_dest_edqy.push_byte(31u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                OriginCaller::CumulusXcm(ref aa) => {
                    __codec_dest_edqy.push_byte(32u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                OriginCaller::Void(ref aa) => {
                    __codec_dest_edqy.push_byte(3usize as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                _ => {}
            }
        }
    }
    #[automatically_derived]
    impl ::codec::EncodeLike for OriginCaller {}
};
#[allow(deprecated)]
const _: () = {
    #[allow(non_camel_case_types)]
    #[automatically_derived]
    impl ::codec::Decode for OriginCaller {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            match __codec_input_edqy
                .read_byte()
                .map_err(|e| {
                    e
                        .chain(
                            "Could not decode `OriginCaller`, failed to read variant byte",
                        )
                })?
            {
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 0u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            OriginCaller::system({
                                let __codec_res_edqy = <frame_system::Origin<
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `OriginCaller::system.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 31u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            OriginCaller::PolkadotXcm({
                                let __codec_res_edqy = <pallet_xcm::Origin as ::codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `OriginCaller::PolkadotXcm.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 32u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            OriginCaller::CumulusXcm({
                                let __codec_res_edqy = <cumulus_pallet_xcm::Origin as ::codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `OriginCaller::CumulusXcm.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 3usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            OriginCaller::Void({
                                let __codec_res_edqy = <self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::Void as ::codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `OriginCaller::Void.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                _ => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Err(
                            <_ as ::core::convert::Into<
                                _,
                            >>::into(
                                "Could not decode `OriginCaller`, variant doesn't exist",
                            ),
                        )
                    })();
                }
            }
        }
    }
};
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl ::scale_info::TypeInfo for OriginCaller {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(
                    ::scale_info::Path::new("OriginCaller", "asset_hub_kusama_runtime"),
                )
                .type_params(::alloc::vec::Vec::new())
                .variant(
                    ::scale_info::build::Variants::new()
                        .variant(
                            "system",
                            |v| {
                                v
                                    .index(0u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<frame_system::Origin<Runtime>>()
                                                    .type_name("frame_system::Origin<Runtime>")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "PolkadotXcm",
                            |v| {
                                v
                                    .index(31u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f.ty::<pallet_xcm::Origin>().type_name("pallet_xcm::Origin")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "CumulusXcm",
                            |v| {
                                v
                                    .index(32u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<cumulus_pallet_xcm::Origin>()
                                                    .type_name("cumulus_pallet_xcm::Origin")
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Void",
                            |v| {
                                v
                                    .index(3usize as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::Void,
                                                    >()
                                                    .type_name(
                                                        "self::sp_api_hidden_includes_construct_runtime::hidden_include::\n__private::Void",
                                                    )
                                            }),
                                    )
                            },
                        ),
                )
        }
    }
};
const _: () = {
    impl ::codec::MaxEncodedLen for OriginCaller {
        fn max_encoded_len() -> ::core::primitive::usize {
            0_usize
                .max(
                    0_usize
                        .saturating_add(
                            <frame_system::Origin<Runtime>>::max_encoded_len(),
                        ),
                )
                .max(0_usize.saturating_add(<pallet_xcm::Origin>::max_encoded_len()))
                .max(
                    0_usize
                        .saturating_add(<cumulus_pallet_xcm::Origin>::max_encoded_len()),
                )
                .max(
                    0_usize
                        .saturating_add(
                            <self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::Void>::max_encoded_len(),
                        ),
                )
                .saturating_add(1)
        }
    }
};
#[allow(dead_code)]
impl RuntimeOrigin {
    /// Create with system none origin and [`frame_system::Config::BaseCallFilter`].
    pub fn none() -> Self {
        <RuntimeOrigin as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::OriginTrait>::none()
    }
    /// Create with system root origin and [`frame_system::Config::BaseCallFilter`].
    pub fn root() -> Self {
        <RuntimeOrigin as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::OriginTrait>::root()
    }
    /// Create with system signed origin and [`frame_system::Config::BaseCallFilter`].
    pub fn signed(by: <Runtime as frame_system::Config>::AccountId) -> Self {
        <RuntimeOrigin as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::OriginTrait>::signed(
            by,
        )
    }
}
impl From<frame_system::Origin<Runtime>> for OriginCaller {
    fn from(x: frame_system::Origin<Runtime>) -> Self {
        OriginCaller::system(x)
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallerTrait<
    <Runtime as frame_system::Config>::AccountId,
> for OriginCaller {
    fn into_system(
        self,
    ) -> Option<frame_system::RawOrigin<<Runtime as frame_system::Config>::AccountId>> {
        match self {
            OriginCaller::system(x) => Some(x),
            _ => None,
        }
    }
    fn as_system_ref(
        &self,
    ) -> Option<&frame_system::RawOrigin<<Runtime as frame_system::Config>::AccountId>> {
        match &self {
            OriginCaller::system(o) => Some(o),
            _ => None,
        }
    }
}
impl TryFrom<OriginCaller> for frame_system::Origin<Runtime> {
    type Error = OriginCaller;
    fn try_from(
        x: OriginCaller,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        frame_system::Origin<Runtime>,
        OriginCaller,
    > {
        if let OriginCaller::system(l) = x { Ok(l) } else { Err(x) }
    }
}
impl From<frame_system::Origin<Runtime>> for RuntimeOrigin {
    /// Convert to runtime origin, using as filter: [`frame_system::Config::BaseCallFilter`].
    fn from(x: frame_system::Origin<Runtime>) -> Self {
        let o: OriginCaller = x.into();
        o.into()
    }
}
impl From<OriginCaller> for RuntimeOrigin {
    fn from(x: OriginCaller) -> Self {
        let mut o = RuntimeOrigin {
            caller: x,
            filter: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::rc::Rc::new(
                Box::new(|_| true),
            ),
        };
        self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::OriginTrait::reset_filter(
            &mut o,
        );
        o
    }
}
impl From<RuntimeOrigin>
for self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
    frame_system::Origin<Runtime>,
    RuntimeOrigin,
> {
    /// NOTE: converting to pallet origin loses the origin filter information.
    fn from(val: RuntimeOrigin) -> Self {
        if let OriginCaller::system(l) = val.caller { Ok(l) } else { Err(val) }
    }
}
impl From<Option<<Runtime as frame_system::Config>::AccountId>> for RuntimeOrigin {
    /// Convert to runtime origin with caller being system signed or none and use filter [`frame_system::Config::BaseCallFilter`].
    fn from(x: Option<<Runtime as frame_system::Config>::AccountId>) -> Self {
        <frame_system::Origin<Runtime>>::from(x).into()
    }
}
impl From<pallet_xcm::Origin> for OriginCaller {
    fn from(x: pallet_xcm::Origin) -> Self {
        OriginCaller::PolkadotXcm(x)
    }
}
impl From<pallet_xcm::Origin> for RuntimeOrigin {
    ///  Convert to runtime origin using [`pallet_xcm::Config::BaseCallFilter`].
    fn from(x: pallet_xcm::Origin) -> Self {
        let x: OriginCaller = x.into();
        x.into()
    }
}
impl From<RuntimeOrigin>
for self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
    pallet_xcm::Origin,
    RuntimeOrigin,
> {
    /// NOTE: converting to pallet origin loses the origin filter information.
    fn from(val: RuntimeOrigin) -> Self {
        if let OriginCaller::PolkadotXcm(l) = val.caller { Ok(l) } else { Err(val) }
    }
}
impl TryFrom<OriginCaller> for pallet_xcm::Origin {
    type Error = OriginCaller;
    fn try_from(
        x: OriginCaller,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        pallet_xcm::Origin,
        OriginCaller,
    > {
        if let OriginCaller::PolkadotXcm(l) = x { Ok(l) } else { Err(x) }
    }
}
impl<'a> TryFrom<&'a OriginCaller> for &'a pallet_xcm::Origin {
    type Error = ();
    fn try_from(
        x: &'a OriginCaller,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        &'a pallet_xcm::Origin,
        (),
    > {
        if let OriginCaller::PolkadotXcm(l) = x { Ok(&l) } else { Err(()) }
    }
}
impl<'a> TryFrom<&'a RuntimeOrigin> for &'a pallet_xcm::Origin {
    type Error = ();
    fn try_from(
        x: &'a RuntimeOrigin,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        &'a pallet_xcm::Origin,
        (),
    > {
        if let OriginCaller::PolkadotXcm(l) = &x.caller { Ok(&l) } else { Err(()) }
    }
}
impl From<cumulus_pallet_xcm::Origin> for OriginCaller {
    fn from(x: cumulus_pallet_xcm::Origin) -> Self {
        OriginCaller::CumulusXcm(x)
    }
}
impl From<cumulus_pallet_xcm::Origin> for RuntimeOrigin {
    ///  Convert to runtime origin using [`cumulus_pallet_xcm::Config::BaseCallFilter`].
    fn from(x: cumulus_pallet_xcm::Origin) -> Self {
        let x: OriginCaller = x.into();
        x.into()
    }
}
impl From<RuntimeOrigin>
for self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
    cumulus_pallet_xcm::Origin,
    RuntimeOrigin,
> {
    /// NOTE: converting to pallet origin loses the origin filter information.
    fn from(val: RuntimeOrigin) -> Self {
        if let OriginCaller::CumulusXcm(l) = val.caller { Ok(l) } else { Err(val) }
    }
}
impl TryFrom<OriginCaller> for cumulus_pallet_xcm::Origin {
    type Error = OriginCaller;
    fn try_from(
        x: OriginCaller,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        cumulus_pallet_xcm::Origin,
        OriginCaller,
    > {
        if let OriginCaller::CumulusXcm(l) = x { Ok(l) } else { Err(x) }
    }
}
impl<'a> TryFrom<&'a OriginCaller> for &'a cumulus_pallet_xcm::Origin {
    type Error = ();
    fn try_from(
        x: &'a OriginCaller,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        &'a cumulus_pallet_xcm::Origin,
        (),
    > {
        if let OriginCaller::CumulusXcm(l) = x { Ok(&l) } else { Err(()) }
    }
}
impl<'a> TryFrom<&'a RuntimeOrigin> for &'a cumulus_pallet_xcm::Origin {
    type Error = ();
    fn try_from(
        x: &'a RuntimeOrigin,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result<
        &'a cumulus_pallet_xcm::Origin,
        (),
    > {
        if let OriginCaller::CumulusXcm(l) = &x.caller { Ok(&l) } else { Err(()) }
    }
}
pub type System = frame_system::Pallet<Runtime>;
pub type ParachainSystem = cumulus_pallet_parachain_system::Pallet<Runtime>;
pub type Timestamp = pallet_timestamp::Pallet<Runtime>;
pub type ParachainInfo = parachain_info::Pallet<Runtime>;
pub type Balances = pallet_balances::Pallet<Runtime>;
pub type TransactionPayment = pallet_transaction_payment::Pallet<Runtime>;
pub type AssetTxPayment = pallet_asset_conversion_tx_payment::Pallet<Runtime>;
pub type Authorship = pallet_authorship::Pallet<Runtime>;
pub type CollatorSelection = pallet_collator_selection::Pallet<Runtime>;
pub type Session = pallet_session::Pallet<Runtime>;
pub type Aura = pallet_aura::Pallet<Runtime>;
pub type AuraExt = cumulus_pallet_aura_ext::Pallet<Runtime>;
pub type XcmpQueue = cumulus_pallet_xcmp_queue::Pallet<Runtime>;
pub type PolkadotXcm = pallet_xcm::Pallet<Runtime>;
pub type CumulusXcm = cumulus_pallet_xcm::Pallet<Runtime>;
pub type DmpQueue = cumulus_pallet_dmp_queue::Pallet<Runtime>;
pub type Utility = pallet_utility::Pallet<Runtime>;
pub type Multisig = pallet_multisig::Pallet<Runtime>;
pub type Proxy = pallet_proxy::Pallet<Runtime>;
pub type Assets = pallet_assets::Pallet<Runtime, pallet_assets::Instance1>;
pub type Uniques = pallet_uniques::Pallet<Runtime>;
pub type Nfts = pallet_nfts::Pallet<Runtime>;
pub type ForeignAssets = pallet_assets::Pallet<Runtime, pallet_assets::Instance2>;
pub type NftFractionalization = pallet_nft_fractionalization::Pallet<Runtime>;
pub type PoolAssets = pallet_assets::Pallet<Runtime, pallet_assets::Instance3>;
pub type AssetConversion = pallet_asset_conversion::Pallet<Runtime>;
/// All pallets included in the runtime as a nested tuple of types.
#[deprecated(
    note = "The type definition has changed from representing all pallets \
			excluding system, in reversed order to become the representation of all pallets \
			including system pallet in regular order. For this reason it is encouraged to use \
			explicitly one of `AllPalletsWithSystem`, `AllPalletsWithoutSystem`, \
			`AllPalletsWithSystemReversed`, `AllPalletsWithoutSystemReversed`. \
			Note that the type `frame_executive::Executive` expects one of `AllPalletsWithSystem` \
			, `AllPalletsWithSystemReversed`, `AllPalletsReversedWithSystemFirst`. More details in \
			https://github.com/paritytech/substrate/pull/10043"
)]
pub type AllPallets = AllPalletsWithSystem;
#[cfg(all(not(feature = "state-trie-version-1")))]
/// All pallets included in the runtime as a nested tuple of types.
pub type AllPalletsWithSystem = (
    System,
    ParachainSystem,
    Timestamp,
    ParachainInfo,
    Balances,
    TransactionPayment,
    AssetTxPayment,
    Authorship,
    CollatorSelection,
    Session,
    Aura,
    AuraExt,
    XcmpQueue,
    PolkadotXcm,
    CumulusXcm,
    DmpQueue,
    Utility,
    Multisig,
    Proxy,
    Assets,
    Uniques,
    Nfts,
    ForeignAssets,
    NftFractionalization,
    PoolAssets,
    AssetConversion,
);
#[cfg(all(not(feature = "state-trie-version-1")))]
/// All pallets included in the runtime as a nested tuple of types.
/// Excludes the System pallet.
pub type AllPalletsWithoutSystem = (
    ParachainSystem,
    Timestamp,
    ParachainInfo,
    Balances,
    TransactionPayment,
    AssetTxPayment,
    Authorship,
    CollatorSelection,
    Session,
    Aura,
    AuraExt,
    XcmpQueue,
    PolkadotXcm,
    CumulusXcm,
    DmpQueue,
    Utility,
    Multisig,
    Proxy,
    Assets,
    Uniques,
    Nfts,
    ForeignAssets,
    NftFractionalization,
    PoolAssets,
    AssetConversion,
);
#[cfg(all(not(feature = "state-trie-version-1")))]
/// All pallets included in the runtime as a nested tuple of types in reversed order.
#[deprecated(
    note = "Using reverse pallet orders is deprecated. use only \
			`AllPalletsWithSystem or AllPalletsWithoutSystem`"
)]
pub type AllPalletsWithSystemReversed = (
    AssetConversion,
    PoolAssets,
    NftFractionalization,
    ForeignAssets,
    Nfts,
    Uniques,
    Assets,
    Proxy,
    Multisig,
    Utility,
    DmpQueue,
    CumulusXcm,
    PolkadotXcm,
    XcmpQueue,
    AuraExt,
    Aura,
    Session,
    CollatorSelection,
    Authorship,
    AssetTxPayment,
    TransactionPayment,
    Balances,
    ParachainInfo,
    Timestamp,
    ParachainSystem,
    System,
);
#[cfg(all(not(feature = "state-trie-version-1")))]
/// All pallets included in the runtime as a nested tuple of types in reversed order.
/// Excludes the System pallet.
#[deprecated(
    note = "Using reverse pallet orders is deprecated. use only \
			`AllPalletsWithSystem or AllPalletsWithoutSystem`"
)]
pub type AllPalletsWithoutSystemReversed = (
    AssetConversion,
    PoolAssets,
    NftFractionalization,
    ForeignAssets,
    Nfts,
    Uniques,
    Assets,
    Proxy,
    Multisig,
    Utility,
    DmpQueue,
    CumulusXcm,
    PolkadotXcm,
    XcmpQueue,
    AuraExt,
    Aura,
    Session,
    CollatorSelection,
    Authorship,
    AssetTxPayment,
    TransactionPayment,
    Balances,
    ParachainInfo,
    Timestamp,
    ParachainSystem,
);
#[cfg(all(not(feature = "state-trie-version-1")))]
/// All pallets included in the runtime as a nested tuple of types in reversed order.
/// With the system pallet first.
#[deprecated(
    note = "Using reverse pallet orders is deprecated. use only \
			`AllPalletsWithSystem or AllPalletsWithoutSystem`"
)]
pub type AllPalletsReversedWithSystemFirst = (
    System,
    AssetConversion,
    PoolAssets,
    NftFractionalization,
    ForeignAssets,
    Nfts,
    Uniques,
    Assets,
    Proxy,
    Multisig,
    Utility,
    DmpQueue,
    CumulusXcm,
    PolkadotXcm,
    XcmpQueue,
    AuraExt,
    Aura,
    Session,
    CollatorSelection,
    Authorship,
    AssetTxPayment,
    TransactionPayment,
    Balances,
    ParachainInfo,
    Timestamp,
    ParachainSystem,
);
/// Provides an implementation of `PalletInfo` to provide information
/// about the pallet setup in the runtime.
pub struct PalletInfo;
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfo
for PalletInfo {
    fn index<P: 'static>() -> Option<usize> {
        let type_id = self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
            P,
        >();
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                System,
            >()
        {
            return Some(0usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                ParachainSystem,
            >()
        {
            return Some(1usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Timestamp,
            >()
        {
            return Some(3usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                ParachainInfo,
            >()
        {
            return Some(4usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Balances,
            >()
        {
            return Some(10usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                TransactionPayment,
            >()
        {
            return Some(11usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                AssetTxPayment,
            >()
        {
            return Some(13usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Authorship,
            >()
        {
            return Some(20usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                CollatorSelection,
            >()
        {
            return Some(21usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Session,
            >()
        {
            return Some(22usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Aura,
            >()
        {
            return Some(23usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                AuraExt,
            >()
        {
            return Some(24usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                XcmpQueue,
            >()
        {
            return Some(30usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                PolkadotXcm,
            >()
        {
            return Some(31usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                CumulusXcm,
            >()
        {
            return Some(32usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                DmpQueue,
            >()
        {
            return Some(33usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Utility,
            >()
        {
            return Some(40usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Multisig,
            >()
        {
            return Some(41usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Proxy,
            >()
        {
            return Some(42usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Assets,
            >()
        {
            return Some(50usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Uniques,
            >()
        {
            return Some(51usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Nfts,
            >()
        {
            return Some(52usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                ForeignAssets,
            >()
        {
            return Some(53usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                NftFractionalization,
            >()
        {
            return Some(54usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                PoolAssets,
            >()
        {
            return Some(55usize);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                AssetConversion,
            >()
        {
            return Some(56usize);
        }
        None
    }
    fn name<P: 'static>() -> Option<&'static str> {
        let type_id = self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
            P,
        >();
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                System,
            >()
        {
            return Some("System");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                ParachainSystem,
            >()
        {
            return Some("ParachainSystem");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Timestamp,
            >()
        {
            return Some("Timestamp");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                ParachainInfo,
            >()
        {
            return Some("ParachainInfo");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Balances,
            >()
        {
            return Some("Balances");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                TransactionPayment,
            >()
        {
            return Some("TransactionPayment");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                AssetTxPayment,
            >()
        {
            return Some("AssetTxPayment");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Authorship,
            >()
        {
            return Some("Authorship");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                CollatorSelection,
            >()
        {
            return Some("CollatorSelection");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Session,
            >()
        {
            return Some("Session");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Aura,
            >()
        {
            return Some("Aura");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                AuraExt,
            >()
        {
            return Some("AuraExt");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                XcmpQueue,
            >()
        {
            return Some("XcmpQueue");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                PolkadotXcm,
            >()
        {
            return Some("PolkadotXcm");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                CumulusXcm,
            >()
        {
            return Some("CumulusXcm");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                DmpQueue,
            >()
        {
            return Some("DmpQueue");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Utility,
            >()
        {
            return Some("Utility");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Multisig,
            >()
        {
            return Some("Multisig");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Proxy,
            >()
        {
            return Some("Proxy");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Assets,
            >()
        {
            return Some("Assets");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Uniques,
            >()
        {
            return Some("Uniques");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Nfts,
            >()
        {
            return Some("Nfts");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                ForeignAssets,
            >()
        {
            return Some("ForeignAssets");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                NftFractionalization,
            >()
        {
            return Some("NftFractionalization");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                PoolAssets,
            >()
        {
            return Some("PoolAssets");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                AssetConversion,
            >()
        {
            return Some("AssetConversion");
        }
        None
    }
    fn name_hash<P: 'static>() -> Option<[u8; 16]> {
        let type_id = self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
            P,
        >();
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                System,
            >()
        {
            return Some([
                38u8,
                170u8,
                57u8,
                78u8,
                234u8,
                86u8,
                48u8,
                224u8,
                124u8,
                72u8,
                174u8,
                12u8,
                149u8,
                88u8,
                206u8,
                247u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                ParachainSystem,
            >()
        {
            return Some([
                69u8,
                50u8,
                61u8,
                247u8,
                204u8,
                71u8,
                21u8,
                11u8,
                57u8,
                48u8,
                226u8,
                102u8,
                107u8,
                10u8,
                163u8,
                19u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Timestamp,
            >()
        {
            return Some([
                240u8,
                195u8,
                101u8,
                195u8,
                207u8,
                89u8,
                214u8,
                113u8,
                235u8,
                114u8,
                218u8,
                14u8,
                122u8,
                65u8,
                19u8,
                196u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                ParachainInfo,
            >()
        {
            return Some([
                13u8,
                113u8,
                95u8,
                38u8,
                70u8,
                200u8,
                248u8,
                87u8,
                103u8,
                181u8,
                210u8,
                118u8,
                75u8,
                178u8,
                120u8,
                38u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Balances,
            >()
        {
            return Some([
                194u8,
                38u8,
                18u8,
                118u8,
                204u8,
                157u8,
                31u8,
                133u8,
                152u8,
                234u8,
                75u8,
                106u8,
                116u8,
                177u8,
                92u8,
                47u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                TransactionPayment,
            >()
        {
            return Some([
                63u8,
                20u8,
                103u8,
                160u8,
                150u8,
                188u8,
                215u8,
                26u8,
                91u8,
                106u8,
                12u8,
                129u8,
                85u8,
                226u8,
                8u8,
                16u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                AssetTxPayment,
            >()
        {
            return Some([
                38u8,
                122u8,
                218u8,
                22u8,
                64u8,
                85u8,
                41u8,
                194u8,
                247u8,
                239u8,
                39u8,
                39u8,
                215u8,
                30u8,
                219u8,
                222u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Authorship,
            >()
        {
            return Some([
                213u8,
                123u8,
                206u8,
                84u8,
                95u8,
                179u8,
                130u8,
                195u8,
                69u8,
                112u8,
                229u8,
                223u8,
                191u8,
                51u8,
                143u8,
                94u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                CollatorSelection,
            >()
        {
            return Some([
                21u8,
                70u8,
                76u8,
                172u8,
                51u8,
                120u8,
                212u8,
                111u8,
                17u8,
                60u8,
                213u8,
                183u8,
                164u8,
                215u8,
                28u8,
                132u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Session,
            >()
        {
            return Some([
                206u8,
                197u8,
                7u8,
                13u8,
                96u8,
                157u8,
                211u8,
                73u8,
                127u8,
                114u8,
                189u8,
                224u8,
                127u8,
                201u8,
                107u8,
                160u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Aura,
            >()
        {
            return Some([
                87u8,
                248u8,
                220u8,
                47u8,
                90u8,
                176u8,
                148u8,
                103u8,
                137u8,
                111u8,
                71u8,
                48u8,
                15u8,
                4u8,
                36u8,
                56u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                AuraExt,
            >()
        {
            return Some([
                60u8,
                49u8,
                29u8,
                87u8,
                212u8,
                218u8,
                245u8,
                41u8,
                4u8,
                97u8,
                108u8,
                246u8,
                150u8,
                72u8,
                8u8,
                30u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                XcmpQueue,
            >()
        {
            return Some([
                123u8,
                50u8,
                55u8,
                55u8,
                63u8,
                253u8,
                254u8,
                177u8,
                202u8,
                180u8,
                34u8,
                46u8,
                59u8,
                82u8,
                13u8,
                107u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                PolkadotXcm,
            >()
        {
            return Some([
                227u8,
                143u8,
                24u8,
                82u8,
                7u8,
                73u8,
                138u8,
                187u8,
                92u8,
                33u8,
                61u8,
                15u8,
                176u8,
                89u8,
                179u8,
                216u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                CumulusXcm,
            >()
        {
            return Some([
                121u8,
                226u8,
                254u8,
                93u8,
                50u8,
                113u8,
                101u8,
                0u8,
                31u8,
                130u8,
                50u8,
                100u8,
                48u8,
                35u8,
                237u8,
                139u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                DmpQueue,
            >()
        {
            return Some([
                205u8,
                92u8,
                31u8,
                109u8,
                246u8,
                59u8,
                201u8,
                127u8,
                74u8,
                140u8,
                227u8,
                127u8,
                20u8,
                165u8,
                12u8,
                167u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Utility,
            >()
        {
            return Some([
                213u8,
                225u8,
                162u8,
                250u8,
                22u8,
                115u8,
                44u8,
                230u8,
                144u8,
                97u8,
                137u8,
                67u8,
                140u8,
                10u8,
                130u8,
                198u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Multisig,
            >()
        {
            return Some([
                116u8,
                116u8,
                68u8,
                156u8,
                202u8,
                149u8,
                220u8,
                93u8,
                12u8,
                0u8,
                231u8,
                23u8,
                53u8,
                166u8,
                209u8,
                125u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Proxy,
            >()
        {
            return Some([
                24u8,
                9u8,
                215u8,
                131u8,
                70u8,
                114u8,
                122u8,
                14u8,
                245u8,
                140u8,
                15u8,
                160u8,
                59u8,
                175u8,
                163u8,
                35u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Assets,
            >()
        {
            return Some([
                104u8,
                42u8,
                89u8,
                213u8,
                26u8,
                185u8,
                228u8,
                138u8,
                140u8,
                140u8,
                196u8,
                24u8,
                255u8,
                151u8,
                8u8,
                210u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Uniques,
            >()
        {
            return Some([
                94u8,
                138u8,
                25u8,
                227u8,
                205u8,
                27u8,
                124u8,
                20u8,
                139u8,
                51u8,
                136u8,
                12u8,
                71u8,
                156u8,
                2u8,
                129u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Nfts,
            >()
        {
            return Some([
                232u8,
                212u8,
                147u8,
                137u8,
                194u8,
                226u8,
                62u8,
                21u8,
                47u8,
                221u8,
                99u8,
                100u8,
                218u8,
                173u8,
                210u8,
                204u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                ForeignAssets,
            >()
        {
            return Some([
                48u8,
                230u8,
                74u8,
                86u8,
                2u8,
                111u8,
                75u8,
                94u8,
                60u8,
                45u8,
                25u8,
                98u8,
                131u8,
                169u8,
                161u8,
                125u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                NftFractionalization,
            >()
        {
            return Some([
                230u8,
                255u8,
                9u8,
                92u8,
                139u8,
                243u8,
                137u8,
                146u8,
                239u8,
                116u8,
                139u8,
                16u8,
                55u8,
                163u8,
                8u8,
                175u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                PoolAssets,
            >()
        {
            return Some([
                77u8,
                176u8,
                107u8,
                161u8,
                202u8,
                111u8,
                24u8,
                177u8,
                237u8,
                176u8,
                111u8,
                240u8,
                130u8,
                210u8,
                68u8,
                9u8,
            ]);
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                AssetConversion,
            >()
        {
            return Some([
                181u8,
                38u8,
                6u8,
                218u8,
                128u8,
                208u8,
                42u8,
                179u8,
                116u8,
                66u8,
                131u8,
                105u8,
                165u8,
                242u8,
                70u8,
                241u8,
            ]);
        }
        None
    }
    fn module_name<P: 'static>() -> Option<&'static str> {
        let type_id = self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
            P,
        >();
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                System,
            >()
        {
            return Some("frame_system");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                ParachainSystem,
            >()
        {
            return Some("cumulus_pallet_parachain_system");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Timestamp,
            >()
        {
            return Some("pallet_timestamp");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                ParachainInfo,
            >()
        {
            return Some("parachain_info");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Balances,
            >()
        {
            return Some("pallet_balances");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                TransactionPayment,
            >()
        {
            return Some("pallet_transaction_payment");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                AssetTxPayment,
            >()
        {
            return Some("pallet_asset_conversion_tx_payment");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Authorship,
            >()
        {
            return Some("pallet_authorship");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                CollatorSelection,
            >()
        {
            return Some("pallet_collator_selection");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Session,
            >()
        {
            return Some("pallet_session");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Aura,
            >()
        {
            return Some("pallet_aura");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                AuraExt,
            >()
        {
            return Some("cumulus_pallet_aura_ext");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                XcmpQueue,
            >()
        {
            return Some("cumulus_pallet_xcmp_queue");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                PolkadotXcm,
            >()
        {
            return Some("pallet_xcm");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                CumulusXcm,
            >()
        {
            return Some("cumulus_pallet_xcm");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                DmpQueue,
            >()
        {
            return Some("cumulus_pallet_dmp_queue");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Utility,
            >()
        {
            return Some("pallet_utility");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Multisig,
            >()
        {
            return Some("pallet_multisig");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Proxy,
            >()
        {
            return Some("pallet_proxy");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Assets,
            >()
        {
            return Some("pallet_assets");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Uniques,
            >()
        {
            return Some("pallet_uniques");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Nfts,
            >()
        {
            return Some("pallet_nfts");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                ForeignAssets,
            >()
        {
            return Some("pallet_assets");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                NftFractionalization,
            >()
        {
            return Some("pallet_nft_fractionalization");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                PoolAssets,
            >()
        {
            return Some("pallet_assets");
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                AssetConversion,
            >()
        {
            return Some("pallet_asset_conversion");
        }
        None
    }
    fn crate_version<P: 'static>() -> Option<
        self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CrateVersion,
    > {
        let type_id = self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
            P,
        >();
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                System,
            >()
        {
            return Some(
                <frame_system::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                ParachainSystem,
            >()
        {
            return Some(
                <cumulus_pallet_parachain_system::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Timestamp,
            >()
        {
            return Some(
                <pallet_timestamp::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                ParachainInfo,
            >()
        {
            return Some(
                <parachain_info::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Balances,
            >()
        {
            return Some(
                <pallet_balances::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                TransactionPayment,
            >()
        {
            return Some(
                <pallet_transaction_payment::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                AssetTxPayment,
            >()
        {
            return Some(
                <pallet_asset_conversion_tx_payment::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Authorship,
            >()
        {
            return Some(
                <pallet_authorship::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                CollatorSelection,
            >()
        {
            return Some(
                <pallet_collator_selection::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Session,
            >()
        {
            return Some(
                <pallet_session::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Aura,
            >()
        {
            return Some(
                <pallet_aura::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                AuraExt,
            >()
        {
            return Some(
                <cumulus_pallet_aura_ext::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                XcmpQueue,
            >()
        {
            return Some(
                <cumulus_pallet_xcmp_queue::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                PolkadotXcm,
            >()
        {
            return Some(
                <pallet_xcm::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                CumulusXcm,
            >()
        {
            return Some(
                <cumulus_pallet_xcm::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                DmpQueue,
            >()
        {
            return Some(
                <cumulus_pallet_dmp_queue::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Utility,
            >()
        {
            return Some(
                <pallet_utility::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Multisig,
            >()
        {
            return Some(
                <pallet_multisig::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Proxy,
            >()
        {
            return Some(
                <pallet_proxy::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Assets,
            >()
        {
            return Some(
                <pallet_assets::Pallet<
                    Runtime,
                    pallet_assets::Instance1,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Uniques,
            >()
        {
            return Some(
                <pallet_uniques::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                Nfts,
            >()
        {
            return Some(
                <pallet_nfts::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                ForeignAssets,
            >()
        {
            return Some(
                <pallet_assets::Pallet<
                    Runtime,
                    pallet_assets::Instance2,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                NftFractionalization,
            >()
        {
            return Some(
                <pallet_nft_fractionalization::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                PoolAssets,
            >()
        {
            return Some(
                <pallet_assets::Pallet<
                    Runtime,
                    pallet_assets::Instance3,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        if type_id
            == self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::any::TypeId::of::<
                AssetConversion,
            >()
        {
            return Some(
                <pallet_asset_conversion::Pallet<
                    Runtime,
                > as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::PalletInfoAccess>::crate_version(),
            );
        }
        None
    }
}
pub enum RuntimeCall {
    #[codec(index = 0u8)]
    System(
        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            System,
            Runtime,
        >,
    ),
    #[codec(index = 1u8)]
    ParachainSystem(
        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            ParachainSystem,
            Runtime,
        >,
    ),
    #[codec(index = 3u8)]
    Timestamp(
        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Timestamp,
            Runtime,
        >,
    ),
    #[codec(index = 10u8)]
    Balances(
        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Balances,
            Runtime,
        >,
    ),
    #[codec(index = 21u8)]
    CollatorSelection(
        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            CollatorSelection,
            Runtime,
        >,
    ),
    #[codec(index = 22u8)]
    Session(
        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Session,
            Runtime,
        >,
    ),
    #[codec(index = 30u8)]
    XcmpQueue(
        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            XcmpQueue,
            Runtime,
        >,
    ),
    #[codec(index = 31u8)]
    PolkadotXcm(
        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            PolkadotXcm,
            Runtime,
        >,
    ),
    #[codec(index = 33u8)]
    DmpQueue(
        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            DmpQueue,
            Runtime,
        >,
    ),
    #[codec(index = 40u8)]
    Utility(
        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Utility,
            Runtime,
        >,
    ),
    #[codec(index = 41u8)]
    Multisig(
        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Multisig,
            Runtime,
        >,
    ),
    #[codec(index = 42u8)]
    Proxy(
        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Proxy,
            Runtime,
        >,
    ),
    #[codec(index = 50u8)]
    Assets(
        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Assets,
            Runtime,
        >,
    ),
    #[codec(index = 51u8)]
    Uniques(
        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Uniques,
            Runtime,
        >,
    ),
    #[codec(index = 52u8)]
    Nfts(
        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Nfts,
            Runtime,
        >,
    ),
    #[codec(index = 53u8)]
    ForeignAssets(
        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            ForeignAssets,
            Runtime,
        >,
    ),
    #[codec(index = 54u8)]
    NftFractionalization(
        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            NftFractionalization,
            Runtime,
        >,
    ),
    #[codec(index = 55u8)]
    PoolAssets(
        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            PoolAssets,
            Runtime,
        >,
    ),
    #[codec(index = 56u8)]
    AssetConversion(
        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            AssetConversion,
            Runtime,
        >,
    ),
}
#[automatically_derived]
impl ::core::clone::Clone for RuntimeCall {
    #[inline]
    fn clone(&self) -> RuntimeCall {
        match self {
            RuntimeCall::System(__self_0) => {
                RuntimeCall::System(::core::clone::Clone::clone(__self_0))
            }
            RuntimeCall::ParachainSystem(__self_0) => {
                RuntimeCall::ParachainSystem(::core::clone::Clone::clone(__self_0))
            }
            RuntimeCall::Timestamp(__self_0) => {
                RuntimeCall::Timestamp(::core::clone::Clone::clone(__self_0))
            }
            RuntimeCall::Balances(__self_0) => {
                RuntimeCall::Balances(::core::clone::Clone::clone(__self_0))
            }
            RuntimeCall::CollatorSelection(__self_0) => {
                RuntimeCall::CollatorSelection(::core::clone::Clone::clone(__self_0))
            }
            RuntimeCall::Session(__self_0) => {
                RuntimeCall::Session(::core::clone::Clone::clone(__self_0))
            }
            RuntimeCall::XcmpQueue(__self_0) => {
                RuntimeCall::XcmpQueue(::core::clone::Clone::clone(__self_0))
            }
            RuntimeCall::PolkadotXcm(__self_0) => {
                RuntimeCall::PolkadotXcm(::core::clone::Clone::clone(__self_0))
            }
            RuntimeCall::DmpQueue(__self_0) => {
                RuntimeCall::DmpQueue(::core::clone::Clone::clone(__self_0))
            }
            RuntimeCall::Utility(__self_0) => {
                RuntimeCall::Utility(::core::clone::Clone::clone(__self_0))
            }
            RuntimeCall::Multisig(__self_0) => {
                RuntimeCall::Multisig(::core::clone::Clone::clone(__self_0))
            }
            RuntimeCall::Proxy(__self_0) => {
                RuntimeCall::Proxy(::core::clone::Clone::clone(__self_0))
            }
            RuntimeCall::Assets(__self_0) => {
                RuntimeCall::Assets(::core::clone::Clone::clone(__self_0))
            }
            RuntimeCall::Uniques(__self_0) => {
                RuntimeCall::Uniques(::core::clone::Clone::clone(__self_0))
            }
            RuntimeCall::Nfts(__self_0) => {
                RuntimeCall::Nfts(::core::clone::Clone::clone(__self_0))
            }
            RuntimeCall::ForeignAssets(__self_0) => {
                RuntimeCall::ForeignAssets(::core::clone::Clone::clone(__self_0))
            }
            RuntimeCall::NftFractionalization(__self_0) => {
                RuntimeCall::NftFractionalization(::core::clone::Clone::clone(__self_0))
            }
            RuntimeCall::PoolAssets(__self_0) => {
                RuntimeCall::PoolAssets(::core::clone::Clone::clone(__self_0))
            }
            RuntimeCall::AssetConversion(__self_0) => {
                RuntimeCall::AssetConversion(::core::clone::Clone::clone(__self_0))
            }
        }
    }
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for RuntimeCall {}
#[automatically_derived]
impl ::core::cmp::PartialEq for RuntimeCall {
    #[inline]
    fn eq(&self, other: &RuntimeCall) -> bool {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        __self_tag == __arg1_tag
            && match (self, other) {
                (RuntimeCall::System(__self_0), RuntimeCall::System(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (
                    RuntimeCall::ParachainSystem(__self_0),
                    RuntimeCall::ParachainSystem(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (RuntimeCall::Timestamp(__self_0), RuntimeCall::Timestamp(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (RuntimeCall::Balances(__self_0), RuntimeCall::Balances(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (
                    RuntimeCall::CollatorSelection(__self_0),
                    RuntimeCall::CollatorSelection(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (RuntimeCall::Session(__self_0), RuntimeCall::Session(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (RuntimeCall::XcmpQueue(__self_0), RuntimeCall::XcmpQueue(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (
                    RuntimeCall::PolkadotXcm(__self_0),
                    RuntimeCall::PolkadotXcm(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (RuntimeCall::DmpQueue(__self_0), RuntimeCall::DmpQueue(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (RuntimeCall::Utility(__self_0), RuntimeCall::Utility(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (RuntimeCall::Multisig(__self_0), RuntimeCall::Multisig(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (RuntimeCall::Proxy(__self_0), RuntimeCall::Proxy(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (RuntimeCall::Assets(__self_0), RuntimeCall::Assets(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (RuntimeCall::Uniques(__self_0), RuntimeCall::Uniques(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (RuntimeCall::Nfts(__self_0), RuntimeCall::Nfts(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (
                    RuntimeCall::ForeignAssets(__self_0),
                    RuntimeCall::ForeignAssets(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (
                    RuntimeCall::NftFractionalization(__self_0),
                    RuntimeCall::NftFractionalization(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (
                    RuntimeCall::PoolAssets(__self_0),
                    RuntimeCall::PoolAssets(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (
                    RuntimeCall::AssetConversion(__self_0),
                    RuntimeCall::AssetConversion(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                _ => unsafe { ::core::intrinsics::unreachable() }
            }
    }
}
#[automatically_derived]
impl ::core::marker::StructuralEq for RuntimeCall {}
#[automatically_derived]
impl ::core::cmp::Eq for RuntimeCall {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<
            self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                System,
                Runtime,
            >,
        >;
        let _: ::core::cmp::AssertParamIsEq<
            self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                ParachainSystem,
                Runtime,
            >,
        >;
        let _: ::core::cmp::AssertParamIsEq<
            self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                Timestamp,
                Runtime,
            >,
        >;
        let _: ::core::cmp::AssertParamIsEq<
            self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                Balances,
                Runtime,
            >,
        >;
        let _: ::core::cmp::AssertParamIsEq<
            self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                CollatorSelection,
                Runtime,
            >,
        >;
        let _: ::core::cmp::AssertParamIsEq<
            self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                Session,
                Runtime,
            >,
        >;
        let _: ::core::cmp::AssertParamIsEq<
            self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                XcmpQueue,
                Runtime,
            >,
        >;
        let _: ::core::cmp::AssertParamIsEq<
            self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                PolkadotXcm,
                Runtime,
            >,
        >;
        let _: ::core::cmp::AssertParamIsEq<
            self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                DmpQueue,
                Runtime,
            >,
        >;
        let _: ::core::cmp::AssertParamIsEq<
            self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                Utility,
                Runtime,
            >,
        >;
        let _: ::core::cmp::AssertParamIsEq<
            self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                Multisig,
                Runtime,
            >,
        >;
        let _: ::core::cmp::AssertParamIsEq<
            self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                Proxy,
                Runtime,
            >,
        >;
        let _: ::core::cmp::AssertParamIsEq<
            self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                Assets,
                Runtime,
            >,
        >;
        let _: ::core::cmp::AssertParamIsEq<
            self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                Uniques,
                Runtime,
            >,
        >;
        let _: ::core::cmp::AssertParamIsEq<
            self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                Nfts,
                Runtime,
            >,
        >;
        let _: ::core::cmp::AssertParamIsEq<
            self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                ForeignAssets,
                Runtime,
            >,
        >;
        let _: ::core::cmp::AssertParamIsEq<
            self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                NftFractionalization,
                Runtime,
            >,
        >;
        let _: ::core::cmp::AssertParamIsEq<
            self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                PoolAssets,
                Runtime,
            >,
        >;
        let _: ::core::cmp::AssertParamIsEq<
            self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                AssetConversion,
                Runtime,
            >,
        >;
    }
}
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Encode for RuntimeCall {
        fn size_hint(&self) -> usize {
            1_usize
                + match *self {
                    RuntimeCall::System(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeCall::ParachainSystem(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeCall::Timestamp(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeCall::Balances(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeCall::CollatorSelection(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeCall::Session(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeCall::XcmpQueue(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeCall::PolkadotXcm(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeCall::DmpQueue(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeCall::Utility(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeCall::Multisig(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeCall::Proxy(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeCall::Assets(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeCall::Uniques(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeCall::Nfts(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeCall::ForeignAssets(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeCall::NftFractionalization(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeCall::PoolAssets(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RuntimeCall::AssetConversion(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    _ => 0_usize,
                }
        }
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            match *self {
                RuntimeCall::System(ref aa) => {
                    __codec_dest_edqy.push_byte(0u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeCall::ParachainSystem(ref aa) => {
                    __codec_dest_edqy.push_byte(1u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeCall::Timestamp(ref aa) => {
                    __codec_dest_edqy.push_byte(3u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeCall::Balances(ref aa) => {
                    __codec_dest_edqy.push_byte(10u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeCall::CollatorSelection(ref aa) => {
                    __codec_dest_edqy.push_byte(21u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeCall::Session(ref aa) => {
                    __codec_dest_edqy.push_byte(22u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeCall::XcmpQueue(ref aa) => {
                    __codec_dest_edqy.push_byte(30u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeCall::PolkadotXcm(ref aa) => {
                    __codec_dest_edqy.push_byte(31u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeCall::DmpQueue(ref aa) => {
                    __codec_dest_edqy.push_byte(33u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeCall::Utility(ref aa) => {
                    __codec_dest_edqy.push_byte(40u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeCall::Multisig(ref aa) => {
                    __codec_dest_edqy.push_byte(41u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeCall::Proxy(ref aa) => {
                    __codec_dest_edqy.push_byte(42u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeCall::Assets(ref aa) => {
                    __codec_dest_edqy.push_byte(50u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeCall::Uniques(ref aa) => {
                    __codec_dest_edqy.push_byte(51u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeCall::Nfts(ref aa) => {
                    __codec_dest_edqy.push_byte(52u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeCall::ForeignAssets(ref aa) => {
                    __codec_dest_edqy.push_byte(53u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeCall::NftFractionalization(ref aa) => {
                    __codec_dest_edqy.push_byte(54u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeCall::PoolAssets(ref aa) => {
                    __codec_dest_edqy.push_byte(55u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RuntimeCall::AssetConversion(ref aa) => {
                    __codec_dest_edqy.push_byte(56u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                _ => {}
            }
        }
    }
    #[automatically_derived]
    impl ::codec::EncodeLike for RuntimeCall {}
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Decode for RuntimeCall {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            match __codec_input_edqy
                .read_byte()
                .map_err(|e| {
                    e
                        .chain(
                            "Could not decode `RuntimeCall`, failed to read variant byte",
                        )
                })?
            {
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 0u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeCall::System({
                                let __codec_res_edqy = <self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                    System,
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeCall::System.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 1u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeCall::ParachainSystem({
                                let __codec_res_edqy = <self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                    ParachainSystem,
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeCall::ParachainSystem.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 3u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeCall::Timestamp({
                                let __codec_res_edqy = <self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                    Timestamp,
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeCall::Timestamp.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 10u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeCall::Balances({
                                let __codec_res_edqy = <self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                    Balances,
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeCall::Balances.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 21u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeCall::CollatorSelection({
                                let __codec_res_edqy = <self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                    CollatorSelection,
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e
                                                .chain(
                                                    "Could not decode `RuntimeCall::CollatorSelection.0`",
                                                ),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 22u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeCall::Session({
                                let __codec_res_edqy = <self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                    Session,
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeCall::Session.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 30u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeCall::XcmpQueue({
                                let __codec_res_edqy = <self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                    XcmpQueue,
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeCall::XcmpQueue.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 31u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeCall::PolkadotXcm({
                                let __codec_res_edqy = <self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                    PolkadotXcm,
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeCall::PolkadotXcm.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 33u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeCall::DmpQueue({
                                let __codec_res_edqy = <self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                    DmpQueue,
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeCall::DmpQueue.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 40u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeCall::Utility({
                                let __codec_res_edqy = <self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                    Utility,
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeCall::Utility.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 41u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeCall::Multisig({
                                let __codec_res_edqy = <self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                    Multisig,
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeCall::Multisig.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 42u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeCall::Proxy({
                                let __codec_res_edqy = <self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                    Proxy,
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeCall::Proxy.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 50u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeCall::Assets({
                                let __codec_res_edqy = <self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                    Assets,
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeCall::Assets.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 51u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeCall::Uniques({
                                let __codec_res_edqy = <self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                    Uniques,
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeCall::Uniques.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 52u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeCall::Nfts({
                                let __codec_res_edqy = <self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                    Nfts,
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeCall::Nfts.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 53u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeCall::ForeignAssets({
                                let __codec_res_edqy = <self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                    ForeignAssets,
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeCall::ForeignAssets.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 54u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeCall::NftFractionalization({
                                let __codec_res_edqy = <self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                    NftFractionalization,
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e
                                                .chain(
                                                    "Could not decode `RuntimeCall::NftFractionalization.0`",
                                                ),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 55u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeCall::PoolAssets({
                                let __codec_res_edqy = <self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                    PoolAssets,
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeCall::PoolAssets.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 56u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeCall::AssetConversion({
                                let __codec_res_edqy = <self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                    AssetConversion,
                                    Runtime,
                                > as ::codec::Decode>::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RuntimeCall::AssetConversion.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                _ => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Err(
                            <_ as ::core::convert::Into<
                                _,
                            >>::into(
                                "Could not decode `RuntimeCall`, variant doesn't exist",
                            ),
                        )
                    })();
                }
            }
        }
    }
};
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl ::scale_info::TypeInfo for RuntimeCall {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(::scale_info::Path::new("RuntimeCall", "asset_hub_kusama_runtime"))
                .type_params(::alloc::vec::Vec::new())
                .variant(
                    ::scale_info::build::Variants::new()
                        .variant(
                            "System",
                            |v| {
                                v
                                    .index(0u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                                            System,
                                                            Runtime,
                                                        >,
                                                    >()
                                                    .type_name(
                                                        "self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch\n::CallableCallFor<System, Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "ParachainSystem",
                            |v| {
                                v
                                    .index(1u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                                            ParachainSystem,
                                                            Runtime,
                                                        >,
                                                    >()
                                                    .type_name(
                                                        "self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch\n::CallableCallFor<ParachainSystem, Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Timestamp",
                            |v| {
                                v
                                    .index(3u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                                            Timestamp,
                                                            Runtime,
                                                        >,
                                                    >()
                                                    .type_name(
                                                        "self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch\n::CallableCallFor<Timestamp, Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Balances",
                            |v| {
                                v
                                    .index(10u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                                            Balances,
                                                            Runtime,
                                                        >,
                                                    >()
                                                    .type_name(
                                                        "self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch\n::CallableCallFor<Balances, Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "CollatorSelection",
                            |v| {
                                v
                                    .index(21u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                                            CollatorSelection,
                                                            Runtime,
                                                        >,
                                                    >()
                                                    .type_name(
                                                        "self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch\n::CallableCallFor<CollatorSelection, Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Session",
                            |v| {
                                v
                                    .index(22u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                                            Session,
                                                            Runtime,
                                                        >,
                                                    >()
                                                    .type_name(
                                                        "self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch\n::CallableCallFor<Session, Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "XcmpQueue",
                            |v| {
                                v
                                    .index(30u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                                            XcmpQueue,
                                                            Runtime,
                                                        >,
                                                    >()
                                                    .type_name(
                                                        "self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch\n::CallableCallFor<XcmpQueue, Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "PolkadotXcm",
                            |v| {
                                v
                                    .index(31u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                                            PolkadotXcm,
                                                            Runtime,
                                                        >,
                                                    >()
                                                    .type_name(
                                                        "self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch\n::CallableCallFor<PolkadotXcm, Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "DmpQueue",
                            |v| {
                                v
                                    .index(33u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                                            DmpQueue,
                                                            Runtime,
                                                        >,
                                                    >()
                                                    .type_name(
                                                        "self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch\n::CallableCallFor<DmpQueue, Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Utility",
                            |v| {
                                v
                                    .index(40u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                                            Utility,
                                                            Runtime,
                                                        >,
                                                    >()
                                                    .type_name(
                                                        "self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch\n::CallableCallFor<Utility, Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Multisig",
                            |v| {
                                v
                                    .index(41u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                                            Multisig,
                                                            Runtime,
                                                        >,
                                                    >()
                                                    .type_name(
                                                        "self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch\n::CallableCallFor<Multisig, Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Proxy",
                            |v| {
                                v
                                    .index(42u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                                            Proxy,
                                                            Runtime,
                                                        >,
                                                    >()
                                                    .type_name(
                                                        "self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch\n::CallableCallFor<Proxy, Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Assets",
                            |v| {
                                v
                                    .index(50u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                                            Assets,
                                                            Runtime,
                                                        >,
                                                    >()
                                                    .type_name(
                                                        "self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch\n::CallableCallFor<Assets, Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Uniques",
                            |v| {
                                v
                                    .index(51u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                                            Uniques,
                                                            Runtime,
                                                        >,
                                                    >()
                                                    .type_name(
                                                        "self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch\n::CallableCallFor<Uniques, Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "Nfts",
                            |v| {
                                v
                                    .index(52u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                                            Nfts,
                                                            Runtime,
                                                        >,
                                                    >()
                                                    .type_name(
                                                        "self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch\n::CallableCallFor<Nfts, Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "ForeignAssets",
                            |v| {
                                v
                                    .index(53u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                                            ForeignAssets,
                                                            Runtime,
                                                        >,
                                                    >()
                                                    .type_name(
                                                        "self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch\n::CallableCallFor<ForeignAssets, Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "NftFractionalization",
                            |v| {
                                v
                                    .index(54u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                                            NftFractionalization,
                                                            Runtime,
                                                        >,
                                                    >()
                                                    .type_name(
                                                        "self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch\n::CallableCallFor<NftFractionalization, Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "PoolAssets",
                            |v| {
                                v
                                    .index(55u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                                            PoolAssets,
                                                            Runtime,
                                                        >,
                                                    >()
                                                    .type_name(
                                                        "self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch\n::CallableCallFor<PoolAssets, Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        )
                        .variant(
                            "AssetConversion",
                            |v| {
                                v
                                    .index(56u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<
                                                        self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
                                                            AssetConversion,
                                                            Runtime,
                                                        >,
                                                    >()
                                                    .type_name(
                                                        "self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch\n::CallableCallFor<AssetConversion, Runtime>",
                                                    )
                                            }),
                                    )
                            },
                        ),
                )
        }
    }
};
impl core::fmt::Debug for RuntimeCall {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            Self::System(ref a0) => {
                fmt.debug_tuple("RuntimeCall::System").field(a0).finish()
            }
            Self::ParachainSystem(ref a0) => {
                fmt.debug_tuple("RuntimeCall::ParachainSystem").field(a0).finish()
            }
            Self::Timestamp(ref a0) => {
                fmt.debug_tuple("RuntimeCall::Timestamp").field(a0).finish()
            }
            Self::Balances(ref a0) => {
                fmt.debug_tuple("RuntimeCall::Balances").field(a0).finish()
            }
            Self::CollatorSelection(ref a0) => {
                fmt.debug_tuple("RuntimeCall::CollatorSelection").field(a0).finish()
            }
            Self::Session(ref a0) => {
                fmt.debug_tuple("RuntimeCall::Session").field(a0).finish()
            }
            Self::XcmpQueue(ref a0) => {
                fmt.debug_tuple("RuntimeCall::XcmpQueue").field(a0).finish()
            }
            Self::PolkadotXcm(ref a0) => {
                fmt.debug_tuple("RuntimeCall::PolkadotXcm").field(a0).finish()
            }
            Self::DmpQueue(ref a0) => {
                fmt.debug_tuple("RuntimeCall::DmpQueue").field(a0).finish()
            }
            Self::Utility(ref a0) => {
                fmt.debug_tuple("RuntimeCall::Utility").field(a0).finish()
            }
            Self::Multisig(ref a0) => {
                fmt.debug_tuple("RuntimeCall::Multisig").field(a0).finish()
            }
            Self::Proxy(ref a0) => {
                fmt.debug_tuple("RuntimeCall::Proxy").field(a0).finish()
            }
            Self::Assets(ref a0) => {
                fmt.debug_tuple("RuntimeCall::Assets").field(a0).finish()
            }
            Self::Uniques(ref a0) => {
                fmt.debug_tuple("RuntimeCall::Uniques").field(a0).finish()
            }
            Self::Nfts(ref a0) => fmt.debug_tuple("RuntimeCall::Nfts").field(a0).finish(),
            Self::ForeignAssets(ref a0) => {
                fmt.debug_tuple("RuntimeCall::ForeignAssets").field(a0).finish()
            }
            Self::NftFractionalization(ref a0) => {
                fmt.debug_tuple("RuntimeCall::NftFractionalization").field(a0).finish()
            }
            Self::PoolAssets(ref a0) => {
                fmt.debug_tuple("RuntimeCall::PoolAssets").field(a0).finish()
            }
            Self::AssetConversion(ref a0) => {
                fmt.debug_tuple("RuntimeCall::AssetConversion").field(a0).finish()
            }
            _ => Ok(()),
        }
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::GetDispatchInfo
for RuntimeCall {
    fn get_dispatch_info(
        &self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::DispatchInfo {
        match self {
            RuntimeCall::System(call) => call.get_dispatch_info(),
            RuntimeCall::ParachainSystem(call) => call.get_dispatch_info(),
            RuntimeCall::Timestamp(call) => call.get_dispatch_info(),
            RuntimeCall::Balances(call) => call.get_dispatch_info(),
            RuntimeCall::CollatorSelection(call) => call.get_dispatch_info(),
            RuntimeCall::Session(call) => call.get_dispatch_info(),
            RuntimeCall::XcmpQueue(call) => call.get_dispatch_info(),
            RuntimeCall::PolkadotXcm(call) => call.get_dispatch_info(),
            RuntimeCall::DmpQueue(call) => call.get_dispatch_info(),
            RuntimeCall::Utility(call) => call.get_dispatch_info(),
            RuntimeCall::Multisig(call) => call.get_dispatch_info(),
            RuntimeCall::Proxy(call) => call.get_dispatch_info(),
            RuntimeCall::Assets(call) => call.get_dispatch_info(),
            RuntimeCall::Uniques(call) => call.get_dispatch_info(),
            RuntimeCall::Nfts(call) => call.get_dispatch_info(),
            RuntimeCall::ForeignAssets(call) => call.get_dispatch_info(),
            RuntimeCall::NftFractionalization(call) => call.get_dispatch_info(),
            RuntimeCall::PoolAssets(call) => call.get_dispatch_info(),
            RuntimeCall::AssetConversion(call) => call.get_dispatch_info(),
        }
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::GetCallMetadata
for RuntimeCall {
    fn get_call_metadata(
        &self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallMetadata {
        use self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::GetCallName;
        match self {
            RuntimeCall::System(call) => {
                let function_name = call.get_call_name();
                let pallet_name = "System";
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallMetadata {
                    function_name,
                    pallet_name,
                }
            }
            RuntimeCall::ParachainSystem(call) => {
                let function_name = call.get_call_name();
                let pallet_name = "ParachainSystem";
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallMetadata {
                    function_name,
                    pallet_name,
                }
            }
            RuntimeCall::Timestamp(call) => {
                let function_name = call.get_call_name();
                let pallet_name = "Timestamp";
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallMetadata {
                    function_name,
                    pallet_name,
                }
            }
            RuntimeCall::Balances(call) => {
                let function_name = call.get_call_name();
                let pallet_name = "Balances";
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallMetadata {
                    function_name,
                    pallet_name,
                }
            }
            RuntimeCall::CollatorSelection(call) => {
                let function_name = call.get_call_name();
                let pallet_name = "CollatorSelection";
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallMetadata {
                    function_name,
                    pallet_name,
                }
            }
            RuntimeCall::Session(call) => {
                let function_name = call.get_call_name();
                let pallet_name = "Session";
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallMetadata {
                    function_name,
                    pallet_name,
                }
            }
            RuntimeCall::XcmpQueue(call) => {
                let function_name = call.get_call_name();
                let pallet_name = "XcmpQueue";
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallMetadata {
                    function_name,
                    pallet_name,
                }
            }
            RuntimeCall::PolkadotXcm(call) => {
                let function_name = call.get_call_name();
                let pallet_name = "PolkadotXcm";
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallMetadata {
                    function_name,
                    pallet_name,
                }
            }
            RuntimeCall::DmpQueue(call) => {
                let function_name = call.get_call_name();
                let pallet_name = "DmpQueue";
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallMetadata {
                    function_name,
                    pallet_name,
                }
            }
            RuntimeCall::Utility(call) => {
                let function_name = call.get_call_name();
                let pallet_name = "Utility";
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallMetadata {
                    function_name,
                    pallet_name,
                }
            }
            RuntimeCall::Multisig(call) => {
                let function_name = call.get_call_name();
                let pallet_name = "Multisig";
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallMetadata {
                    function_name,
                    pallet_name,
                }
            }
            RuntimeCall::Proxy(call) => {
                let function_name = call.get_call_name();
                let pallet_name = "Proxy";
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallMetadata {
                    function_name,
                    pallet_name,
                }
            }
            RuntimeCall::Assets(call) => {
                let function_name = call.get_call_name();
                let pallet_name = "Assets";
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallMetadata {
                    function_name,
                    pallet_name,
                }
            }
            RuntimeCall::Uniques(call) => {
                let function_name = call.get_call_name();
                let pallet_name = "Uniques";
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallMetadata {
                    function_name,
                    pallet_name,
                }
            }
            RuntimeCall::Nfts(call) => {
                let function_name = call.get_call_name();
                let pallet_name = "Nfts";
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallMetadata {
                    function_name,
                    pallet_name,
                }
            }
            RuntimeCall::ForeignAssets(call) => {
                let function_name = call.get_call_name();
                let pallet_name = "ForeignAssets";
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallMetadata {
                    function_name,
                    pallet_name,
                }
            }
            RuntimeCall::NftFractionalization(call) => {
                let function_name = call.get_call_name();
                let pallet_name = "NftFractionalization";
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallMetadata {
                    function_name,
                    pallet_name,
                }
            }
            RuntimeCall::PoolAssets(call) => {
                let function_name = call.get_call_name();
                let pallet_name = "PoolAssets";
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallMetadata {
                    function_name,
                    pallet_name,
                }
            }
            RuntimeCall::AssetConversion(call) => {
                let function_name = call.get_call_name();
                let pallet_name = "AssetConversion";
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::CallMetadata {
                    function_name,
                    pallet_name,
                }
            }
        }
    }
    fn get_module_names() -> &'static [&'static str] {
        &[
            "System",
            "ParachainSystem",
            "Timestamp",
            "Balances",
            "CollatorSelection",
            "Session",
            "XcmpQueue",
            "PolkadotXcm",
            "DmpQueue",
            "Utility",
            "Multisig",
            "Proxy",
            "Assets",
            "Uniques",
            "Nfts",
            "ForeignAssets",
            "NftFractionalization",
            "PoolAssets",
            "AssetConversion",
        ]
    }
    fn get_call_names(module: &str) -> &'static [&'static str] {
        use self::sp_api_hidden_includes_construct_runtime::hidden_include::{
            dispatch::Callable, traits::GetCallName,
        };
        match module {
            "System" => {
                <<System as Callable<
                    Runtime,
                >>::RuntimeCall as GetCallName>::get_call_names()
            }
            "ParachainSystem" => {
                <<ParachainSystem as Callable<
                    Runtime,
                >>::RuntimeCall as GetCallName>::get_call_names()
            }
            "Timestamp" => {
                <<Timestamp as Callable<
                    Runtime,
                >>::RuntimeCall as GetCallName>::get_call_names()
            }
            "Balances" => {
                <<Balances as Callable<
                    Runtime,
                >>::RuntimeCall as GetCallName>::get_call_names()
            }
            "CollatorSelection" => {
                <<CollatorSelection as Callable<
                    Runtime,
                >>::RuntimeCall as GetCallName>::get_call_names()
            }
            "Session" => {
                <<Session as Callable<
                    Runtime,
                >>::RuntimeCall as GetCallName>::get_call_names()
            }
            "XcmpQueue" => {
                <<XcmpQueue as Callable<
                    Runtime,
                >>::RuntimeCall as GetCallName>::get_call_names()
            }
            "PolkadotXcm" => {
                <<PolkadotXcm as Callable<
                    Runtime,
                >>::RuntimeCall as GetCallName>::get_call_names()
            }
            "DmpQueue" => {
                <<DmpQueue as Callable<
                    Runtime,
                >>::RuntimeCall as GetCallName>::get_call_names()
            }
            "Utility" => {
                <<Utility as Callable<
                    Runtime,
                >>::RuntimeCall as GetCallName>::get_call_names()
            }
            "Multisig" => {
                <<Multisig as Callable<
                    Runtime,
                >>::RuntimeCall as GetCallName>::get_call_names()
            }
            "Proxy" => {
                <<Proxy as Callable<
                    Runtime,
                >>::RuntimeCall as GetCallName>::get_call_names()
            }
            "Assets" => {
                <<Assets as Callable<
                    Runtime,
                >>::RuntimeCall as GetCallName>::get_call_names()
            }
            "Uniques" => {
                <<Uniques as Callable<
                    Runtime,
                >>::RuntimeCall as GetCallName>::get_call_names()
            }
            "Nfts" => {
                <<Nfts as Callable<
                    Runtime,
                >>::RuntimeCall as GetCallName>::get_call_names()
            }
            "ForeignAssets" => {
                <<ForeignAssets as Callable<
                    Runtime,
                >>::RuntimeCall as GetCallName>::get_call_names()
            }
            "NftFractionalization" => {
                <<NftFractionalization as Callable<
                    Runtime,
                >>::RuntimeCall as GetCallName>::get_call_names()
            }
            "PoolAssets" => {
                <<PoolAssets as Callable<
                    Runtime,
                >>::RuntimeCall as GetCallName>::get_call_names()
            }
            "AssetConversion" => {
                <<AssetConversion as Callable<
                    Runtime,
                >>::RuntimeCall as GetCallName>::get_call_names()
            }
            _ => ::core::panicking::panic("internal error: entered unreachable code"),
        }
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::Dispatchable
for RuntimeCall {
    type RuntimeOrigin = RuntimeOrigin;
    type Config = RuntimeCall;
    type Info = self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::DispatchInfo;
    type PostInfo = self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::PostDispatchInfo;
    fn dispatch(
        self,
        origin: RuntimeOrigin,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::DispatchResultWithPostInfo {
        if !<Self::RuntimeOrigin as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::OriginTrait>::filter_call(
            &origin,
            &self,
        ) {
            return self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::result::Result::Err(
                frame_system::Error::<Runtime>::CallFiltered.into(),
            );
        }
        self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable::dispatch_bypass_filter(
            self,
            origin,
        )
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable
for RuntimeCall {
    type RuntimeOrigin = RuntimeOrigin;
    fn dispatch_bypass_filter(
        self,
        origin: RuntimeOrigin,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::DispatchResultWithPostInfo {
        match self {
            RuntimeCall::System(call) => {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable::dispatch_bypass_filter(
                    call,
                    origin,
                )
            }
            RuntimeCall::ParachainSystem(call) => {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable::dispatch_bypass_filter(
                    call,
                    origin,
                )
            }
            RuntimeCall::Timestamp(call) => {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable::dispatch_bypass_filter(
                    call,
                    origin,
                )
            }
            RuntimeCall::Balances(call) => {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable::dispatch_bypass_filter(
                    call,
                    origin,
                )
            }
            RuntimeCall::CollatorSelection(call) => {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable::dispatch_bypass_filter(
                    call,
                    origin,
                )
            }
            RuntimeCall::Session(call) => {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable::dispatch_bypass_filter(
                    call,
                    origin,
                )
            }
            RuntimeCall::XcmpQueue(call) => {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable::dispatch_bypass_filter(
                    call,
                    origin,
                )
            }
            RuntimeCall::PolkadotXcm(call) => {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable::dispatch_bypass_filter(
                    call,
                    origin,
                )
            }
            RuntimeCall::DmpQueue(call) => {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable::dispatch_bypass_filter(
                    call,
                    origin,
                )
            }
            RuntimeCall::Utility(call) => {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable::dispatch_bypass_filter(
                    call,
                    origin,
                )
            }
            RuntimeCall::Multisig(call) => {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable::dispatch_bypass_filter(
                    call,
                    origin,
                )
            }
            RuntimeCall::Proxy(call) => {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable::dispatch_bypass_filter(
                    call,
                    origin,
                )
            }
            RuntimeCall::Assets(call) => {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable::dispatch_bypass_filter(
                    call,
                    origin,
                )
            }
            RuntimeCall::Uniques(call) => {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable::dispatch_bypass_filter(
                    call,
                    origin,
                )
            }
            RuntimeCall::Nfts(call) => {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable::dispatch_bypass_filter(
                    call,
                    origin,
                )
            }
            RuntimeCall::ForeignAssets(call) => {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable::dispatch_bypass_filter(
                    call,
                    origin,
                )
            }
            RuntimeCall::NftFractionalization(call) => {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable::dispatch_bypass_filter(
                    call,
                    origin,
                )
            }
            RuntimeCall::PoolAssets(call) => {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable::dispatch_bypass_filter(
                    call,
                    origin,
                )
            }
            RuntimeCall::AssetConversion(call) => {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::UnfilteredDispatchable::dispatch_bypass_filter(
                    call,
                    origin,
                )
            }
        }
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::IsSubType<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        System,
        Runtime,
    >,
> for RuntimeCall {
    #[allow(unreachable_patterns)]
    fn is_sub_type(
        &self,
    ) -> Option<
        &self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            System,
            Runtime,
        >,
    > {
        match self {
            RuntimeCall::System(call) => Some(call),
            _ => None,
        }
    }
}
impl From<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        System,
        Runtime,
    >,
> for RuntimeCall {
    fn from(
        call: self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            System,
            Runtime,
        >,
    ) -> Self {
        RuntimeCall::System(call)
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::IsSubType<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        ParachainSystem,
        Runtime,
    >,
> for RuntimeCall {
    #[allow(unreachable_patterns)]
    fn is_sub_type(
        &self,
    ) -> Option<
        &self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            ParachainSystem,
            Runtime,
        >,
    > {
        match self {
            RuntimeCall::ParachainSystem(call) => Some(call),
            _ => None,
        }
    }
}
impl From<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        ParachainSystem,
        Runtime,
    >,
> for RuntimeCall {
    fn from(
        call: self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            ParachainSystem,
            Runtime,
        >,
    ) -> Self {
        RuntimeCall::ParachainSystem(call)
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::IsSubType<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        Timestamp,
        Runtime,
    >,
> for RuntimeCall {
    #[allow(unreachable_patterns)]
    fn is_sub_type(
        &self,
    ) -> Option<
        &self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Timestamp,
            Runtime,
        >,
    > {
        match self {
            RuntimeCall::Timestamp(call) => Some(call),
            _ => None,
        }
    }
}
impl From<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        Timestamp,
        Runtime,
    >,
> for RuntimeCall {
    fn from(
        call: self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Timestamp,
            Runtime,
        >,
    ) -> Self {
        RuntimeCall::Timestamp(call)
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::IsSubType<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        Balances,
        Runtime,
    >,
> for RuntimeCall {
    #[allow(unreachable_patterns)]
    fn is_sub_type(
        &self,
    ) -> Option<
        &self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Balances,
            Runtime,
        >,
    > {
        match self {
            RuntimeCall::Balances(call) => Some(call),
            _ => None,
        }
    }
}
impl From<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        Balances,
        Runtime,
    >,
> for RuntimeCall {
    fn from(
        call: self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Balances,
            Runtime,
        >,
    ) -> Self {
        RuntimeCall::Balances(call)
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::IsSubType<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        CollatorSelection,
        Runtime,
    >,
> for RuntimeCall {
    #[allow(unreachable_patterns)]
    fn is_sub_type(
        &self,
    ) -> Option<
        &self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            CollatorSelection,
            Runtime,
        >,
    > {
        match self {
            RuntimeCall::CollatorSelection(call) => Some(call),
            _ => None,
        }
    }
}
impl From<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        CollatorSelection,
        Runtime,
    >,
> for RuntimeCall {
    fn from(
        call: self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            CollatorSelection,
            Runtime,
        >,
    ) -> Self {
        RuntimeCall::CollatorSelection(call)
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::IsSubType<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        Session,
        Runtime,
    >,
> for RuntimeCall {
    #[allow(unreachable_patterns)]
    fn is_sub_type(
        &self,
    ) -> Option<
        &self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Session,
            Runtime,
        >,
    > {
        match self {
            RuntimeCall::Session(call) => Some(call),
            _ => None,
        }
    }
}
impl From<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        Session,
        Runtime,
    >,
> for RuntimeCall {
    fn from(
        call: self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Session,
            Runtime,
        >,
    ) -> Self {
        RuntimeCall::Session(call)
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::IsSubType<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        XcmpQueue,
        Runtime,
    >,
> for RuntimeCall {
    #[allow(unreachable_patterns)]
    fn is_sub_type(
        &self,
    ) -> Option<
        &self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            XcmpQueue,
            Runtime,
        >,
    > {
        match self {
            RuntimeCall::XcmpQueue(call) => Some(call),
            _ => None,
        }
    }
}
impl From<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        XcmpQueue,
        Runtime,
    >,
> for RuntimeCall {
    fn from(
        call: self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            XcmpQueue,
            Runtime,
        >,
    ) -> Self {
        RuntimeCall::XcmpQueue(call)
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::IsSubType<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        PolkadotXcm,
        Runtime,
    >,
> for RuntimeCall {
    #[allow(unreachable_patterns)]
    fn is_sub_type(
        &self,
    ) -> Option<
        &self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            PolkadotXcm,
            Runtime,
        >,
    > {
        match self {
            RuntimeCall::PolkadotXcm(call) => Some(call),
            _ => None,
        }
    }
}
impl From<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        PolkadotXcm,
        Runtime,
    >,
> for RuntimeCall {
    fn from(
        call: self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            PolkadotXcm,
            Runtime,
        >,
    ) -> Self {
        RuntimeCall::PolkadotXcm(call)
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::IsSubType<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        DmpQueue,
        Runtime,
    >,
> for RuntimeCall {
    #[allow(unreachable_patterns)]
    fn is_sub_type(
        &self,
    ) -> Option<
        &self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            DmpQueue,
            Runtime,
        >,
    > {
        match self {
            RuntimeCall::DmpQueue(call) => Some(call),
            _ => None,
        }
    }
}
impl From<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        DmpQueue,
        Runtime,
    >,
> for RuntimeCall {
    fn from(
        call: self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            DmpQueue,
            Runtime,
        >,
    ) -> Self {
        RuntimeCall::DmpQueue(call)
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::IsSubType<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        Utility,
        Runtime,
    >,
> for RuntimeCall {
    #[allow(unreachable_patterns)]
    fn is_sub_type(
        &self,
    ) -> Option<
        &self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Utility,
            Runtime,
        >,
    > {
        match self {
            RuntimeCall::Utility(call) => Some(call),
            _ => None,
        }
    }
}
impl From<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        Utility,
        Runtime,
    >,
> for RuntimeCall {
    fn from(
        call: self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Utility,
            Runtime,
        >,
    ) -> Self {
        RuntimeCall::Utility(call)
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::IsSubType<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        Multisig,
        Runtime,
    >,
> for RuntimeCall {
    #[allow(unreachable_patterns)]
    fn is_sub_type(
        &self,
    ) -> Option<
        &self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Multisig,
            Runtime,
        >,
    > {
        match self {
            RuntimeCall::Multisig(call) => Some(call),
            _ => None,
        }
    }
}
impl From<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        Multisig,
        Runtime,
    >,
> for RuntimeCall {
    fn from(
        call: self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Multisig,
            Runtime,
        >,
    ) -> Self {
        RuntimeCall::Multisig(call)
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::IsSubType<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        Proxy,
        Runtime,
    >,
> for RuntimeCall {
    #[allow(unreachable_patterns)]
    fn is_sub_type(
        &self,
    ) -> Option<
        &self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Proxy,
            Runtime,
        >,
    > {
        match self {
            RuntimeCall::Proxy(call) => Some(call),
            _ => None,
        }
    }
}
impl From<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        Proxy,
        Runtime,
    >,
> for RuntimeCall {
    fn from(
        call: self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Proxy,
            Runtime,
        >,
    ) -> Self {
        RuntimeCall::Proxy(call)
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::IsSubType<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        Assets,
        Runtime,
    >,
> for RuntimeCall {
    #[allow(unreachable_patterns)]
    fn is_sub_type(
        &self,
    ) -> Option<
        &self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Assets,
            Runtime,
        >,
    > {
        match self {
            RuntimeCall::Assets(call) => Some(call),
            _ => None,
        }
    }
}
impl From<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        Assets,
        Runtime,
    >,
> for RuntimeCall {
    fn from(
        call: self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Assets,
            Runtime,
        >,
    ) -> Self {
        RuntimeCall::Assets(call)
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::IsSubType<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        Uniques,
        Runtime,
    >,
> for RuntimeCall {
    #[allow(unreachable_patterns)]
    fn is_sub_type(
        &self,
    ) -> Option<
        &self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Uniques,
            Runtime,
        >,
    > {
        match self {
            RuntimeCall::Uniques(call) => Some(call),
            _ => None,
        }
    }
}
impl From<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        Uniques,
        Runtime,
    >,
> for RuntimeCall {
    fn from(
        call: self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Uniques,
            Runtime,
        >,
    ) -> Self {
        RuntimeCall::Uniques(call)
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::IsSubType<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        Nfts,
        Runtime,
    >,
> for RuntimeCall {
    #[allow(unreachable_patterns)]
    fn is_sub_type(
        &self,
    ) -> Option<
        &self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Nfts,
            Runtime,
        >,
    > {
        match self {
            RuntimeCall::Nfts(call) => Some(call),
            _ => None,
        }
    }
}
impl From<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        Nfts,
        Runtime,
    >,
> for RuntimeCall {
    fn from(
        call: self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            Nfts,
            Runtime,
        >,
    ) -> Self {
        RuntimeCall::Nfts(call)
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::IsSubType<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        ForeignAssets,
        Runtime,
    >,
> for RuntimeCall {
    #[allow(unreachable_patterns)]
    fn is_sub_type(
        &self,
    ) -> Option<
        &self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            ForeignAssets,
            Runtime,
        >,
    > {
        match self {
            RuntimeCall::ForeignAssets(call) => Some(call),
            _ => None,
        }
    }
}
impl From<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        ForeignAssets,
        Runtime,
    >,
> for RuntimeCall {
    fn from(
        call: self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            ForeignAssets,
            Runtime,
        >,
    ) -> Self {
        RuntimeCall::ForeignAssets(call)
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::IsSubType<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        NftFractionalization,
        Runtime,
    >,
> for RuntimeCall {
    #[allow(unreachable_patterns)]
    fn is_sub_type(
        &self,
    ) -> Option<
        &self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            NftFractionalization,
            Runtime,
        >,
    > {
        match self {
            RuntimeCall::NftFractionalization(call) => Some(call),
            _ => None,
        }
    }
}
impl From<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        NftFractionalization,
        Runtime,
    >,
> for RuntimeCall {
    fn from(
        call: self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            NftFractionalization,
            Runtime,
        >,
    ) -> Self {
        RuntimeCall::NftFractionalization(call)
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::IsSubType<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        PoolAssets,
        Runtime,
    >,
> for RuntimeCall {
    #[allow(unreachable_patterns)]
    fn is_sub_type(
        &self,
    ) -> Option<
        &self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            PoolAssets,
            Runtime,
        >,
    > {
        match self {
            RuntimeCall::PoolAssets(call) => Some(call),
            _ => None,
        }
    }
}
impl From<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        PoolAssets,
        Runtime,
    >,
> for RuntimeCall {
    fn from(
        call: self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            PoolAssets,
            Runtime,
        >,
    ) -> Self {
        RuntimeCall::PoolAssets(call)
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::IsSubType<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        AssetConversion,
        Runtime,
    >,
> for RuntimeCall {
    #[allow(unreachable_patterns)]
    fn is_sub_type(
        &self,
    ) -> Option<
        &self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            AssetConversion,
            Runtime,
        >,
    > {
        match self {
            RuntimeCall::AssetConversion(call) => Some(call),
            _ => None,
        }
    }
}
impl From<
    self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
        AssetConversion,
        Runtime,
    >,
> for RuntimeCall {
    fn from(
        call: self::sp_api_hidden_includes_construct_runtime::hidden_include::dispatch::CallableCallFor<
            AssetConversion,
            Runtime,
        >,
    ) -> Self {
        RuntimeCall::AssetConversion(call)
    }
}
impl Runtime {
    fn metadata_ir() -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::MetadataIR {
        let rt = Runtime;
        let ty = self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
            <<Runtime as frame_system::Config>::Block as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Block>::Extrinsic,
        >();
        let address_ty = self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
            <<<<Runtime as frame_system::Config>::Block as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Block>::Extrinsic as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Extrinsic>::SignaturePayload as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::SignaturePayload>::SignatureAddress,
        >();
        let call_ty = self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
            <<<Runtime as frame_system::Config>::Block as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Block>::Extrinsic as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Extrinsic>::Call,
        >();
        let signature_ty = self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
            <<<<Runtime as frame_system::Config>::Block as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Block>::Extrinsic as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Extrinsic>::SignaturePayload as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::SignaturePayload>::Signature,
        >();
        let extra_ty = self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
            <<<<Runtime as frame_system::Config>::Block as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Block>::Extrinsic as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Extrinsic>::SignaturePayload as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::SignaturePayload>::SignatureExtra,
        >();
        self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::MetadataIR {
            pallets: <[_]>::into_vec(
                #[rustc_box]
                ::alloc::boxed::Box::new([
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "System",
                        index: 0u8,
                        storage: Some(
                            frame_system::Pallet::<Runtime>::storage_metadata(),
                        ),
                        calls: Some(frame_system::Pallet::<Runtime>::call_functions()),
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                frame_system::Event<Runtime>,
                            >(),
                        }),
                        constants: frame_system::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: frame_system::Pallet::<Runtime>::error_metadata(),
                        docs: frame_system::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "ParachainSystem",
                        index: 1u8,
                        storage: Some(
                            cumulus_pallet_parachain_system::Pallet::<
                                Runtime,
                            >::storage_metadata(),
                        ),
                        calls: Some(
                            cumulus_pallet_parachain_system::Pallet::<
                                Runtime,
                            >::call_functions(),
                        ),
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                cumulus_pallet_parachain_system::Event<Runtime>,
                            >(),
                        }),
                        constants: cumulus_pallet_parachain_system::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: cumulus_pallet_parachain_system::Pallet::<
                            Runtime,
                        >::error_metadata(),
                        docs: cumulus_pallet_parachain_system::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "Timestamp",
                        index: 3u8,
                        storage: Some(
                            pallet_timestamp::Pallet::<Runtime>::storage_metadata(),
                        ),
                        calls: Some(
                            pallet_timestamp::Pallet::<Runtime>::call_functions(),
                        ),
                        event: None,
                        constants: pallet_timestamp::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: pallet_timestamp::Pallet::<Runtime>::error_metadata(),
                        docs: pallet_timestamp::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "ParachainInfo",
                        index: 4u8,
                        storage: Some(
                            parachain_info::Pallet::<Runtime>::storage_metadata(),
                        ),
                        calls: None,
                        event: None,
                        constants: parachain_info::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: parachain_info::Pallet::<Runtime>::error_metadata(),
                        docs: parachain_info::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "Balances",
                        index: 10u8,
                        storage: Some(
                            pallet_balances::Pallet::<Runtime>::storage_metadata(),
                        ),
                        calls: Some(
                            pallet_balances::Pallet::<Runtime>::call_functions(),
                        ),
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                pallet_balances::Event<Runtime>,
                            >(),
                        }),
                        constants: pallet_balances::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: pallet_balances::Pallet::<Runtime>::error_metadata(),
                        docs: pallet_balances::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "TransactionPayment",
                        index: 11u8,
                        storage: Some(
                            pallet_transaction_payment::Pallet::<
                                Runtime,
                            >::storage_metadata(),
                        ),
                        calls: None,
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                pallet_transaction_payment::Event<Runtime>,
                            >(),
                        }),
                        constants: pallet_transaction_payment::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: pallet_transaction_payment::Pallet::<
                            Runtime,
                        >::error_metadata(),
                        docs: pallet_transaction_payment::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "AssetTxPayment",
                        index: 13u8,
                        storage: None,
                        calls: None,
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                pallet_asset_conversion_tx_payment::Event<Runtime>,
                            >(),
                        }),
                        constants: pallet_asset_conversion_tx_payment::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: pallet_asset_conversion_tx_payment::Pallet::<
                            Runtime,
                        >::error_metadata(),
                        docs: pallet_asset_conversion_tx_payment::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "Authorship",
                        index: 20u8,
                        storage: Some(
                            pallet_authorship::Pallet::<Runtime>::storage_metadata(),
                        ),
                        calls: None,
                        event: None,
                        constants: pallet_authorship::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: pallet_authorship::Pallet::<Runtime>::error_metadata(),
                        docs: pallet_authorship::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "CollatorSelection",
                        index: 21u8,
                        storage: Some(
                            pallet_collator_selection::Pallet::<
                                Runtime,
                            >::storage_metadata(),
                        ),
                        calls: Some(
                            pallet_collator_selection::Pallet::<
                                Runtime,
                            >::call_functions(),
                        ),
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                pallet_collator_selection::Event<Runtime>,
                            >(),
                        }),
                        constants: pallet_collator_selection::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: pallet_collator_selection::Pallet::<
                            Runtime,
                        >::error_metadata(),
                        docs: pallet_collator_selection::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "Session",
                        index: 22u8,
                        storage: Some(
                            pallet_session::Pallet::<Runtime>::storage_metadata(),
                        ),
                        calls: Some(pallet_session::Pallet::<Runtime>::call_functions()),
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                pallet_session::Event,
                            >(),
                        }),
                        constants: pallet_session::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: pallet_session::Pallet::<Runtime>::error_metadata(),
                        docs: pallet_session::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "Aura",
                        index: 23u8,
                        storage: Some(
                            pallet_aura::Pallet::<Runtime>::storage_metadata(),
                        ),
                        calls: None,
                        event: None,
                        constants: pallet_aura::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: pallet_aura::Pallet::<Runtime>::error_metadata(),
                        docs: pallet_aura::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "AuraExt",
                        index: 24u8,
                        storage: Some(
                            cumulus_pallet_aura_ext::Pallet::<
                                Runtime,
                            >::storage_metadata(),
                        ),
                        calls: None,
                        event: None,
                        constants: cumulus_pallet_aura_ext::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: cumulus_pallet_aura_ext::Pallet::<
                            Runtime,
                        >::error_metadata(),
                        docs: cumulus_pallet_aura_ext::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "XcmpQueue",
                        index: 30u8,
                        storage: Some(
                            cumulus_pallet_xcmp_queue::Pallet::<
                                Runtime,
                            >::storage_metadata(),
                        ),
                        calls: Some(
                            cumulus_pallet_xcmp_queue::Pallet::<
                                Runtime,
                            >::call_functions(),
                        ),
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                cumulus_pallet_xcmp_queue::Event<Runtime>,
                            >(),
                        }),
                        constants: cumulus_pallet_xcmp_queue::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: cumulus_pallet_xcmp_queue::Pallet::<
                            Runtime,
                        >::error_metadata(),
                        docs: cumulus_pallet_xcmp_queue::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "PolkadotXcm",
                        index: 31u8,
                        storage: Some(pallet_xcm::Pallet::<Runtime>::storage_metadata()),
                        calls: Some(pallet_xcm::Pallet::<Runtime>::call_functions()),
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                pallet_xcm::Event<Runtime>,
                            >(),
                        }),
                        constants: pallet_xcm::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: pallet_xcm::Pallet::<Runtime>::error_metadata(),
                        docs: pallet_xcm::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "CumulusXcm",
                        index: 32u8,
                        storage: None,
                        calls: None,
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                cumulus_pallet_xcm::Event<Runtime>,
                            >(),
                        }),
                        constants: cumulus_pallet_xcm::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: cumulus_pallet_xcm::Pallet::<Runtime>::error_metadata(),
                        docs: cumulus_pallet_xcm::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "DmpQueue",
                        index: 33u8,
                        storage: Some(
                            cumulus_pallet_dmp_queue::Pallet::<
                                Runtime,
                            >::storage_metadata(),
                        ),
                        calls: Some(
                            cumulus_pallet_dmp_queue::Pallet::<Runtime>::call_functions(),
                        ),
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                cumulus_pallet_dmp_queue::Event<Runtime>,
                            >(),
                        }),
                        constants: cumulus_pallet_dmp_queue::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: cumulus_pallet_dmp_queue::Pallet::<
                            Runtime,
                        >::error_metadata(),
                        docs: cumulus_pallet_dmp_queue::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "Utility",
                        index: 40u8,
                        storage: None,
                        calls: Some(pallet_utility::Pallet::<Runtime>::call_functions()),
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                pallet_utility::Event,
                            >(),
                        }),
                        constants: pallet_utility::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: pallet_utility::Pallet::<Runtime>::error_metadata(),
                        docs: pallet_utility::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "Multisig",
                        index: 41u8,
                        storage: Some(
                            pallet_multisig::Pallet::<Runtime>::storage_metadata(),
                        ),
                        calls: Some(
                            pallet_multisig::Pallet::<Runtime>::call_functions(),
                        ),
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                pallet_multisig::Event<Runtime>,
                            >(),
                        }),
                        constants: pallet_multisig::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: pallet_multisig::Pallet::<Runtime>::error_metadata(),
                        docs: pallet_multisig::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "Proxy",
                        index: 42u8,
                        storage: Some(
                            pallet_proxy::Pallet::<Runtime>::storage_metadata(),
                        ),
                        calls: Some(pallet_proxy::Pallet::<Runtime>::call_functions()),
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                pallet_proxy::Event<Runtime>,
                            >(),
                        }),
                        constants: pallet_proxy::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: pallet_proxy::Pallet::<Runtime>::error_metadata(),
                        docs: pallet_proxy::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "Assets",
                        index: 50u8,
                        storage: Some(
                            pallet_assets::Pallet::<
                                Runtime,
                                pallet_assets::Instance1,
                            >::storage_metadata(),
                        ),
                        calls: Some(
                            pallet_assets::Pallet::<
                                Runtime,
                                pallet_assets::Instance1,
                            >::call_functions(),
                        ),
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                pallet_assets::Event<Runtime, pallet_assets::Instance1>,
                            >(),
                        }),
                        constants: pallet_assets::Pallet::<
                            Runtime,
                            pallet_assets::Instance1,
                        >::pallet_constants_metadata(),
                        error: pallet_assets::Pallet::<
                            Runtime,
                            pallet_assets::Instance1,
                        >::error_metadata(),
                        docs: pallet_assets::Pallet::<
                            Runtime,
                            pallet_assets::Instance1,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "Uniques",
                        index: 51u8,
                        storage: Some(
                            pallet_uniques::Pallet::<Runtime>::storage_metadata(),
                        ),
                        calls: Some(pallet_uniques::Pallet::<Runtime>::call_functions()),
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                pallet_uniques::Event<Runtime>,
                            >(),
                        }),
                        constants: pallet_uniques::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: pallet_uniques::Pallet::<Runtime>::error_metadata(),
                        docs: pallet_uniques::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "Nfts",
                        index: 52u8,
                        storage: Some(
                            pallet_nfts::Pallet::<Runtime>::storage_metadata(),
                        ),
                        calls: Some(pallet_nfts::Pallet::<Runtime>::call_functions()),
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                pallet_nfts::Event<Runtime>,
                            >(),
                        }),
                        constants: pallet_nfts::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: pallet_nfts::Pallet::<Runtime>::error_metadata(),
                        docs: pallet_nfts::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "ForeignAssets",
                        index: 53u8,
                        storage: Some(
                            pallet_assets::Pallet::<
                                Runtime,
                                pallet_assets::Instance2,
                            >::storage_metadata(),
                        ),
                        calls: Some(
                            pallet_assets::Pallet::<
                                Runtime,
                                pallet_assets::Instance2,
                            >::call_functions(),
                        ),
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                pallet_assets::Event<Runtime, pallet_assets::Instance2>,
                            >(),
                        }),
                        constants: pallet_assets::Pallet::<
                            Runtime,
                            pallet_assets::Instance2,
                        >::pallet_constants_metadata(),
                        error: pallet_assets::Pallet::<
                            Runtime,
                            pallet_assets::Instance2,
                        >::error_metadata(),
                        docs: pallet_assets::Pallet::<
                            Runtime,
                            pallet_assets::Instance2,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "NftFractionalization",
                        index: 54u8,
                        storage: Some(
                            pallet_nft_fractionalization::Pallet::<
                                Runtime,
                            >::storage_metadata(),
                        ),
                        calls: Some(
                            pallet_nft_fractionalization::Pallet::<
                                Runtime,
                            >::call_functions(),
                        ),
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                pallet_nft_fractionalization::Event<Runtime>,
                            >(),
                        }),
                        constants: pallet_nft_fractionalization::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: pallet_nft_fractionalization::Pallet::<
                            Runtime,
                        >::error_metadata(),
                        docs: pallet_nft_fractionalization::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "PoolAssets",
                        index: 55u8,
                        storage: Some(
                            pallet_assets::Pallet::<
                                Runtime,
                                pallet_assets::Instance3,
                            >::storage_metadata(),
                        ),
                        calls: Some(
                            pallet_assets::Pallet::<
                                Runtime,
                                pallet_assets::Instance3,
                            >::call_functions(),
                        ),
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                pallet_assets::Event<Runtime, pallet_assets::Instance3>,
                            >(),
                        }),
                        constants: pallet_assets::Pallet::<
                            Runtime,
                            pallet_assets::Instance3,
                        >::pallet_constants_metadata(),
                        error: pallet_assets::Pallet::<
                            Runtime,
                            pallet_assets::Instance3,
                        >::error_metadata(),
                        docs: pallet_assets::Pallet::<
                            Runtime,
                            pallet_assets::Instance3,
                        >::pallet_documentation_metadata(),
                    },
                    self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletMetadataIR {
                        name: "AssetConversion",
                        index: 56u8,
                        storage: Some(
                            pallet_asset_conversion::Pallet::<
                                Runtime,
                            >::storage_metadata(),
                        ),
                        calls: Some(
                            pallet_asset_conversion::Pallet::<Runtime>::call_functions(),
                        ),
                        event: Some(self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::PalletEventMetadataIR {
                            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                                pallet_asset_conversion::Event<Runtime>,
                            >(),
                        }),
                        constants: pallet_asset_conversion::Pallet::<
                            Runtime,
                        >::pallet_constants_metadata(),
                        error: pallet_asset_conversion::Pallet::<
                            Runtime,
                        >::error_metadata(),
                        docs: pallet_asset_conversion::Pallet::<
                            Runtime,
                        >::pallet_documentation_metadata(),
                    },
                ]),
            ),
            extrinsic: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::ExtrinsicMetadataIR {
                ty,
                version: <<<Runtime as frame_system::Config>::Block as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Block>::Extrinsic as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::ExtrinsicMetadata>::VERSION,
                address_ty,
                call_ty,
                signature_ty,
                extra_ty,
                signed_extensions: <<<<Runtime as frame_system::Config>::Block as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Block>::Extrinsic as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::ExtrinsicMetadata>::SignedExtensions as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::SignedExtension>::metadata()
                    .into_iter()
                    .map(|meta| self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::SignedExtensionMetadataIR {
                        identifier: meta.identifier,
                        ty: meta.ty,
                        additional_signed: meta.additional_signed,
                    })
                    .collect(),
            },
            ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                Runtime,
            >(),
            apis: (&rt).runtime_metadata(),
            outer_enums: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::OuterEnumsIR {
                call_enum_ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                    <Runtime as frame_system::Config>::RuntimeCall,
                >(),
                event_enum_ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                    RuntimeEvent,
                >(),
                error_enum_ty: self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::scale_info::meta_type::<
                    RuntimeError,
                >(),
            },
        }
    }
    pub fn metadata() -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata::RuntimeMetadataPrefixed {
        self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::into_v14(
            Runtime::metadata_ir(),
        )
    }
    pub fn metadata_at_version(
        version: u32,
    ) -> Option<
        self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::OpaqueMetadata,
    > {
        self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::into_version(
                Runtime::metadata_ir(),
                version,
            )
            .map(|prefixed| {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::OpaqueMetadata::new(
                    prefixed.into(),
                )
            })
    }
    pub fn metadata_versions() -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::vec::Vec<
        u32,
    > {
        self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::metadata_ir::supported_versions()
    }
}
pub type SystemConfig = frame_system::GenesisConfig<Runtime>;
pub type ParachainSystemConfig = cumulus_pallet_parachain_system::GenesisConfig<Runtime>;
pub type ParachainInfoConfig = parachain_info::GenesisConfig<Runtime>;
pub type BalancesConfig = pallet_balances::GenesisConfig<Runtime>;
pub type CollatorSelectionConfig = pallet_collator_selection::GenesisConfig<Runtime>;
pub type SessionConfig = pallet_session::GenesisConfig<Runtime>;
pub type AuraConfig = pallet_aura::GenesisConfig<Runtime>;
pub type AuraExtConfig = cumulus_pallet_aura_ext::GenesisConfig<Runtime>;
pub type PolkadotXcmConfig = pallet_xcm::GenesisConfig<Runtime>;
use self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::serde as __genesis_config_serde_import__;
#[serde(rename_all = "camelCase")]
#[serde(deny_unknown_fields)]
#[serde(crate = "__genesis_config_serde_import__")]
pub struct RuntimeGenesisConfig {
    pub system: SystemConfig,
    pub parachain_system: ParachainSystemConfig,
    pub parachain_info: ParachainInfoConfig,
    pub balances: BalancesConfig,
    pub collator_selection: CollatorSelectionConfig,
    pub session: SessionConfig,
    pub aura: AuraConfig,
    pub aura_ext: AuraExtConfig,
    pub polkadot_xcm: PolkadotXcmConfig,
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    use __genesis_config_serde_import__ as _serde;
    #[automatically_derived]
    impl __genesis_config_serde_import__::Serialize for RuntimeGenesisConfig {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> __genesis_config_serde_import__::__private::Result<__S::Ok, __S::Error>
        where
            __S: __genesis_config_serde_import__::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "RuntimeGenesisConfig",
                false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "system",
                &self.system,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "parachainSystem",
                &self.parachain_system,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "parachainInfo",
                &self.parachain_info,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "balances",
                &self.balances,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "collatorSelection",
                &self.collator_selection,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "session",
                &self.session,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "aura",
                &self.aura,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "auraExt",
                &self.aura_ext,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "polkadotXcm",
                &self.polkadot_xcm,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    use __genesis_config_serde_import__ as _serde;
    #[automatically_derived]
    impl<'de> __genesis_config_serde_import__::Deserialize<'de>
    for RuntimeGenesisConfig {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> __genesis_config_serde_import__::__private::Result<Self, __D::Error>
        where
            __D: __genesis_config_serde_import__::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __field6,
                __field7,
                __field8,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        5u64 => _serde::__private::Ok(__Field::__field5),
                        6u64 => _serde::__private::Ok(__Field::__field6),
                        7u64 => _serde::__private::Ok(__Field::__field7),
                        8u64 => _serde::__private::Ok(__Field::__field8),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 9",
                                ),
                            )
                        }
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "system" => _serde::__private::Ok(__Field::__field0),
                        "parachainSystem" => _serde::__private::Ok(__Field::__field1),
                        "parachainInfo" => _serde::__private::Ok(__Field::__field2),
                        "balances" => _serde::__private::Ok(__Field::__field3),
                        "collatorSelection" => _serde::__private::Ok(__Field::__field4),
                        "session" => _serde::__private::Ok(__Field::__field5),
                        "aura" => _serde::__private::Ok(__Field::__field6),
                        "auraExt" => _serde::__private::Ok(__Field::__field7),
                        "polkadotXcm" => _serde::__private::Ok(__Field::__field8),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::unknown_field(__value, FIELDS),
                            )
                        }
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"system" => _serde::__private::Ok(__Field::__field0),
                        b"parachainSystem" => _serde::__private::Ok(__Field::__field1),
                        b"parachainInfo" => _serde::__private::Ok(__Field::__field2),
                        b"balances" => _serde::__private::Ok(__Field::__field3),
                        b"collatorSelection" => _serde::__private::Ok(__Field::__field4),
                        b"session" => _serde::__private::Ok(__Field::__field5),
                        b"aura" => _serde::__private::Ok(__Field::__field6),
                        b"auraExt" => _serde::__private::Ok(__Field::__field7),
                        b"polkadotXcm" => _serde::__private::Ok(__Field::__field8),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(
                                _serde::de::Error::unknown_field(__value, FIELDS),
                            )
                        }
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<RuntimeGenesisConfig>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = RuntimeGenesisConfig;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct RuntimeGenesisConfig",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        SystemConfig,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct RuntimeGenesisConfig with 9 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        ParachainSystemConfig,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct RuntimeGenesisConfig with 9 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        ParachainInfoConfig,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct RuntimeGenesisConfig with 9 elements",
                                ),
                            );
                        }
                    };
                    let __field3 = match _serde::de::SeqAccess::next_element::<
                        BalancesConfig,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct RuntimeGenesisConfig with 9 elements",
                                ),
                            );
                        }
                    };
                    let __field4 = match _serde::de::SeqAccess::next_element::<
                        CollatorSelectionConfig,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct RuntimeGenesisConfig with 9 elements",
                                ),
                            );
                        }
                    };
                    let __field5 = match _serde::de::SeqAccess::next_element::<
                        SessionConfig,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    5usize,
                                    &"struct RuntimeGenesisConfig with 9 elements",
                                ),
                            );
                        }
                    };
                    let __field6 = match _serde::de::SeqAccess::next_element::<
                        AuraConfig,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    6usize,
                                    &"struct RuntimeGenesisConfig with 9 elements",
                                ),
                            );
                        }
                    };
                    let __field7 = match _serde::de::SeqAccess::next_element::<
                        AuraExtConfig,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    7usize,
                                    &"struct RuntimeGenesisConfig with 9 elements",
                                ),
                            );
                        }
                    };
                    let __field8 = match _serde::de::SeqAccess::next_element::<
                        PolkadotXcmConfig,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    8usize,
                                    &"struct RuntimeGenesisConfig with 9 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(RuntimeGenesisConfig {
                        system: __field0,
                        parachain_system: __field1,
                        parachain_info: __field2,
                        balances: __field3,
                        collator_selection: __field4,
                        session: __field5,
                        aura: __field6,
                        aura_ext: __field7,
                        polkadot_xcm: __field8,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<SystemConfig> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<ParachainSystemConfig> = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<ParachainInfoConfig> = _serde::__private::None;
                    let mut __field3: _serde::__private::Option<BalancesConfig> = _serde::__private::None;
                    let mut __field4: _serde::__private::Option<
                        CollatorSelectionConfig,
                    > = _serde::__private::None;
                    let mut __field5: _serde::__private::Option<SessionConfig> = _serde::__private::None;
                    let mut __field6: _serde::__private::Option<AuraConfig> = _serde::__private::None;
                    let mut __field7: _serde::__private::Option<AuraExtConfig> = _serde::__private::None;
                    let mut __field8: _serde::__private::Option<PolkadotXcmConfig> = _serde::__private::None;
                    while let _serde::__private::Some(__key)
                        = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("system"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        SystemConfig,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "parachainSystem",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        ParachainSystemConfig,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "parachainInfo",
                                        ),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        ParachainInfoConfig,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field3 => {
                                if _serde::__private::Option::is_some(&__field3) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "balances",
                                        ),
                                    );
                                }
                                __field3 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        BalancesConfig,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field4 => {
                                if _serde::__private::Option::is_some(&__field4) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "collatorSelection",
                                        ),
                                    );
                                }
                                __field4 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        CollatorSelectionConfig,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field5 => {
                                if _serde::__private::Option::is_some(&__field5) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "session",
                                        ),
                                    );
                                }
                                __field5 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        SessionConfig,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field6 => {
                                if _serde::__private::Option::is_some(&__field6) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("aura"),
                                    );
                                }
                                __field6 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<AuraConfig>(&mut __map)?,
                                );
                            }
                            __Field::__field7 => {
                                if _serde::__private::Option::is_some(&__field7) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "auraExt",
                                        ),
                                    );
                                }
                                __field7 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        AuraExtConfig,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field8 => {
                                if _serde::__private::Option::is_some(&__field8) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "polkadotXcm",
                                        ),
                                    );
                                }
                                __field8 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        PolkadotXcmConfig,
                                    >(&mut __map)?,
                                );
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("system")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("parachainSystem")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("parachainInfo")?
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::__private::Some(__field3) => __field3,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("balances")?
                        }
                    };
                    let __field4 = match __field4 {
                        _serde::__private::Some(__field4) => __field4,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("collatorSelection")?
                        }
                    };
                    let __field5 = match __field5 {
                        _serde::__private::Some(__field5) => __field5,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("session")?
                        }
                    };
                    let __field6 = match __field6 {
                        _serde::__private::Some(__field6) => __field6,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("aura")?
                        }
                    };
                    let __field7 = match __field7 {
                        _serde::__private::Some(__field7) => __field7,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("auraExt")?
                        }
                    };
                    let __field8 = match __field8 {
                        _serde::__private::Some(__field8) => __field8,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("polkadotXcm")?
                        }
                    };
                    _serde::__private::Ok(RuntimeGenesisConfig {
                        system: __field0,
                        parachain_system: __field1,
                        parachain_info: __field2,
                        balances: __field3,
                        collator_selection: __field4,
                        session: __field5,
                        aura: __field6,
                        aura_ext: __field7,
                        polkadot_xcm: __field8,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &[
                "system",
                "parachainSystem",
                "parachainInfo",
                "balances",
                "collatorSelection",
                "session",
                "aura",
                "auraExt",
                "polkadotXcm",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "RuntimeGenesisConfig",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<RuntimeGenesisConfig>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[automatically_derived]
impl ::core::default::Default for RuntimeGenesisConfig {
    #[inline]
    fn default() -> RuntimeGenesisConfig {
        RuntimeGenesisConfig {
            system: ::core::default::Default::default(),
            parachain_system: ::core::default::Default::default(),
            parachain_info: ::core::default::Default::default(),
            balances: ::core::default::Default::default(),
            collator_selection: ::core::default::Default::default(),
            session: ::core::default::Default::default(),
            aura: ::core::default::Default::default(),
            aura_ext: ::core::default::Default::default(),
            polkadot_xcm: ::core::default::Default::default(),
        }
    }
}
#[cfg(any(feature = "std", test))]
#[deprecated(
    note = "GenesisConfig is planned to be removed in December 2023. Use `RuntimeGenesisConfig` instead."
)]
pub type GenesisConfig = RuntimeGenesisConfig;
#[cfg(any(feature = "std", test))]
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::BuildStorage
for RuntimeGenesisConfig {
    fn assimilate_storage(
        &self,
        storage: &mut self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::Storage,
    ) -> std::result::Result<(), String> {
        self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::BasicExternalities::execute_with_storage(
            storage,
            || {
                <Self as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::BuildGenesisConfig>::build(
                    &self,
                );
                Ok(())
            },
        )
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::BuildGenesisConfig
for RuntimeGenesisConfig {
    fn build(&self) {
        <SystemConfig as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::BuildGenesisConfig>::build(
            &self.system,
        );
        <ParachainSystemConfig as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::BuildGenesisConfig>::build(
            &self.parachain_system,
        );
        <ParachainInfoConfig as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::BuildGenesisConfig>::build(
            &self.parachain_info,
        );
        <BalancesConfig as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::BuildGenesisConfig>::build(
            &self.balances,
        );
        <CollatorSelectionConfig as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::BuildGenesisConfig>::build(
            &self.collator_selection,
        );
        <SessionConfig as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::BuildGenesisConfig>::build(
            &self.session,
        );
        <AuraConfig as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::BuildGenesisConfig>::build(
            &self.aura,
        );
        <AuraExtConfig as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::BuildGenesisConfig>::build(
            &self.aura_ext,
        );
        <PolkadotXcmConfig as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::BuildGenesisConfig>::build(
            &self.polkadot_xcm,
        );
        <AllPalletsWithSystem as self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::OnGenesis>::on_genesis();
    }
}
trait InherentDataExt {
    fn create_extrinsics(
        &self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::vec::Vec<
        <<Runtime as frame_system::Config>::Block as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Block>::Extrinsic,
    >;
    fn check_extrinsics(
        &self,
        block: &<Runtime as frame_system::Config>::Block,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::inherent::CheckInherentsResult;
}
impl InherentDataExt
for self::sp_api_hidden_includes_construct_runtime::hidden_include::inherent::InherentData {
    fn create_extrinsics(
        &self,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::vec::Vec<
        <<Runtime as frame_system::Config>::Block as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Block>::Extrinsic,
    > {
        use self::sp_api_hidden_includes_construct_runtime::hidden_include::inherent::ProvideInherent;
        let mut inherents = self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::sp_std::vec::Vec::new();
        if let Some(inherent) = ParachainSystem::create_inherent(self) {
            let inherent = <<<Runtime as frame_system::Config>::Block as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Block>::Extrinsic as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Extrinsic>::new(
                    inherent.into(),
                    None,
                )
                .expect(
                    "Runtime UncheckedExtrinsic is not Opaque, so it has to return \
							`Some`; qed",
                );
            inherents.push(inherent);
        }
        if let Some(inherent) = Timestamp::create_inherent(self) {
            let inherent = <<<Runtime as frame_system::Config>::Block as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Block>::Extrinsic as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Extrinsic>::new(
                    inherent.into(),
                    None,
                )
                .expect(
                    "Runtime UncheckedExtrinsic is not Opaque, so it has to return \
							`Some`; qed",
                );
            inherents.push(inherent);
        }
        inherents
    }
    fn check_extrinsics(
        &self,
        block: &<Runtime as frame_system::Config>::Block,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::inherent::CheckInherentsResult {
        use self::sp_api_hidden_includes_construct_runtime::hidden_include::inherent::{
            ProvideInherent, IsFatalError,
        };
        use self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::{
            IsSubType, ExtrinsicCall,
        };
        use self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Block as _;
        use self::sp_api_hidden_includes_construct_runtime::hidden_include::__private::{
            sp_inherents::Error, log,
        };
        let mut result = self::sp_api_hidden_includes_construct_runtime::hidden_include::inherent::CheckInherentsResult::new();
        fn handle_put_error_result(res: Result<(), Error>) {
            const LOG_TARGET: &str = "runtime::inherent";
            match res {
                Ok(()) => {}
                Err(Error::InherentDataExists(id)) => {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "Some error already reported for inherent {0:?}, new non fatal error is ignored",
                                id
                            ),
                            lvl,
                            &(
                                LOG_TARGET,
                                "asset_hub_kusama_runtime",
                                "cumulus/parachains/runtimes/assets/asset-hub-kusama/src/lib.rs",
                            ),
                            823u32,
                            ::log::__private_api::Option::None,
                        );
                    }
                }
                Err(Error::FatalErrorReported) => {
                    let lvl = ::log::Level::Error;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "Fatal error already reported, unexpected considering there is only one fatal error"
                            ),
                            lvl,
                            &(
                                LOG_TARGET,
                                "asset_hub_kusama_runtime",
                                "cumulus/parachains/runtimes/assets/asset-hub-kusama/src/lib.rs",
                            ),
                            823u32,
                            ::log::__private_api::Option::None,
                        );
                    }
                }
                Err(_) => {
                    let lvl = ::log::Level::Error;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!("Unexpected error from `put_error` operation"),
                            lvl,
                            &(
                                LOG_TARGET,
                                "asset_hub_kusama_runtime",
                                "cumulus/parachains/runtimes/assets/asset-hub-kusama/src/lib.rs",
                            ),
                            823u32,
                            ::log::__private_api::Option::None,
                        );
                    }
                }
            }
        }
        for xt in block.extrinsics() {
            if self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Extrinsic::is_signed(
                    xt,
                )
                .unwrap_or(false)
            {
                break;
            }
            let mut is_inherent = false;
            {
                let call = <<<Runtime as frame_system::Config>::Block as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Block>::Extrinsic as ExtrinsicCall>::call(
                    xt,
                );
                if let Some(call) = IsSubType::<_>::is_sub_type(call) {
                    if ParachainSystem::is_inherent(call) {
                        is_inherent = true;
                        if let Err(e) = ParachainSystem::check_inherent(call, self) {
                            handle_put_error_result(
                                result.put_error(ParachainSystem::INHERENT_IDENTIFIER, &e),
                            );
                            if e.is_fatal_error() {
                                return result;
                            }
                        }
                    }
                }
            }
            {
                let call = <<<Runtime as frame_system::Config>::Block as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Block>::Extrinsic as ExtrinsicCall>::call(
                    xt,
                );
                if let Some(call) = IsSubType::<_>::is_sub_type(call) {
                    if Timestamp::is_inherent(call) {
                        is_inherent = true;
                        if let Err(e) = Timestamp::check_inherent(call, self) {
                            handle_put_error_result(
                                result.put_error(Timestamp::INHERENT_IDENTIFIER, &e),
                            );
                            if e.is_fatal_error() {
                                return result;
                            }
                        }
                    }
                }
            }
            if !is_inherent {
                break;
            }
        }
        match ParachainSystem::is_inherent_required(self) {
            Ok(Some(e)) => {
                let found = block
                    .extrinsics()
                    .iter()
                    .any(|xt| {
                        let is_signed = self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Extrinsic::is_signed(
                                xt,
                            )
                            .unwrap_or(false);
                        if !is_signed {
                            let call = <<<Runtime as frame_system::Config>::Block as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Block>::Extrinsic as ExtrinsicCall>::call(
                                xt,
                            );
                            if let Some(call) = IsSubType::<_>::is_sub_type(call) {
                                ParachainSystem::is_inherent(&call)
                            } else {
                                false
                            }
                        } else {
                            false
                        }
                    });
                if !found {
                    handle_put_error_result(
                        result.put_error(ParachainSystem::INHERENT_IDENTIFIER, &e),
                    );
                    if e.is_fatal_error() {
                        return result;
                    }
                }
            }
            Ok(None) => {}
            Err(e) => {
                handle_put_error_result(
                    result.put_error(ParachainSystem::INHERENT_IDENTIFIER, &e),
                );
                if e.is_fatal_error() {
                    return result;
                }
            }
        }
        match Timestamp::is_inherent_required(self) {
            Ok(Some(e)) => {
                let found = block
                    .extrinsics()
                    .iter()
                    .any(|xt| {
                        let is_signed = self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Extrinsic::is_signed(
                                xt,
                            )
                            .unwrap_or(false);
                        if !is_signed {
                            let call = <<<Runtime as frame_system::Config>::Block as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Block>::Extrinsic as ExtrinsicCall>::call(
                                xt,
                            );
                            if let Some(call) = IsSubType::<_>::is_sub_type(call) {
                                Timestamp::is_inherent(&call)
                            } else {
                                false
                            }
                        } else {
                            false
                        }
                    });
                if !found {
                    handle_put_error_result(
                        result.put_error(Timestamp::INHERENT_IDENTIFIER, &e),
                    );
                    if e.is_fatal_error() {
                        return result;
                    }
                }
            }
            Ok(None) => {}
            Err(e) => {
                handle_put_error_result(
                    result.put_error(Timestamp::INHERENT_IDENTIFIER, &e),
                );
                if e.is_fatal_error() {
                    return result;
                }
            }
        }
        result
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::EnsureInherentsAreFirst<
    <Runtime as frame_system::Config>::Block,
> for Runtime {
    fn ensure_inherents_are_first(
        block: &<Runtime as frame_system::Config>::Block,
    ) -> Result<(), u32> {
        use self::sp_api_hidden_includes_construct_runtime::hidden_include::inherent::ProvideInherent;
        use self::sp_api_hidden_includes_construct_runtime::hidden_include::traits::{
            IsSubType, ExtrinsicCall,
        };
        use self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Block as _;
        let mut first_signed_observed = false;
        for (i, xt) in block.extrinsics().iter().enumerate() {
            let is_signed = self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Extrinsic::is_signed(
                    xt,
                )
                .unwrap_or(false);
            let is_inherent = if is_signed {
                false
            } else {
                let mut is_inherent = false;
                {
                    let call = <<<Runtime as frame_system::Config>::Block as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Block>::Extrinsic as ExtrinsicCall>::call(
                        xt,
                    );
                    if let Some(call) = IsSubType::<_>::is_sub_type(call) {
                        if ParachainSystem::is_inherent(&call) {
                            is_inherent = true;
                        }
                    }
                }
                {
                    let call = <<<Runtime as frame_system::Config>::Block as self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::Block>::Extrinsic as ExtrinsicCall>::call(
                        xt,
                    );
                    if let Some(call) = IsSubType::<_>::is_sub_type(call) {
                        if Timestamp::is_inherent(&call) {
                            is_inherent = true;
                        }
                    }
                }
                is_inherent
            };
            if !is_inherent {
                first_signed_observed = true;
            }
            if first_signed_observed && is_inherent {
                return Err(i as u32);
            }
        }
        Ok(())
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::unsigned::ValidateUnsigned
for Runtime {
    type Call = RuntimeCall;
    fn pre_dispatch(
        call: &Self::Call,
    ) -> Result<
        (),
        self::sp_api_hidden_includes_construct_runtime::hidden_include::unsigned::TransactionValidityError,
    > {
        #[allow(unreachable_patterns)]
        match call {
            RuntimeCall::ParachainSystem(inner_call) => {
                ParachainSystem::pre_dispatch(inner_call)
            }
            _ => Ok(()),
        }
    }
    fn validate_unsigned(
        #[allow(unused_variables)]
        source: self::sp_api_hidden_includes_construct_runtime::hidden_include::unsigned::TransactionSource,
        call: &Self::Call,
    ) -> self::sp_api_hidden_includes_construct_runtime::hidden_include::unsigned::TransactionValidity {
        #[allow(unreachable_patterns)]
        match call {
            RuntimeCall::ParachainSystem(inner_call) => {
                ParachainSystem::validate_unsigned(source, inner_call)
            }
            _ => {
                self::sp_api_hidden_includes_construct_runtime::hidden_include::unsigned::UnknownTransaction::NoUnsignedValidator
                    .into()
            }
        }
    }
}
/// A reason for placing a freeze on funds.
pub enum RuntimeFreezeReason {}
#[automatically_derived]
impl ::core::marker::Copy for RuntimeFreezeReason {}
#[automatically_derived]
impl ::core::clone::Clone for RuntimeFreezeReason {
    #[inline]
    fn clone(&self) -> RuntimeFreezeReason {
        *self
    }
}
#[automatically_derived]
impl ::core::marker::StructuralEq for RuntimeFreezeReason {}
#[automatically_derived]
impl ::core::cmp::Eq for RuntimeFreezeReason {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {}
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for RuntimeFreezeReason {}
#[automatically_derived]
impl ::core::cmp::PartialEq for RuntimeFreezeReason {
    #[inline]
    fn eq(&self, other: &RuntimeFreezeReason) -> bool {
        match *self {}
    }
}
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Encode for RuntimeFreezeReason {}
    #[automatically_derived]
    impl ::codec::EncodeLike for RuntimeFreezeReason {}
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Decode for RuntimeFreezeReason {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            match __codec_input_edqy
                .read_byte()
                .map_err(|e| {
                    e
                        .chain(
                            "Could not decode `RuntimeFreezeReason`, failed to read variant byte",
                        )
                })?
            {
                _ => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Err(
                            <_ as ::core::convert::Into<
                                _,
                            >>::into(
                                "Could not decode `RuntimeFreezeReason`, variant doesn't exist",
                            ),
                        )
                    })();
                }
            }
        }
    }
};
const _: () = {
    impl ::codec::MaxEncodedLen for RuntimeFreezeReason {
        fn max_encoded_len() -> ::core::primitive::usize {
            0_usize.saturating_add(1)
        }
    }
};
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl ::scale_info::TypeInfo for RuntimeFreezeReason {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(
                    ::scale_info::Path::new(
                        "RuntimeFreezeReason",
                        "asset_hub_kusama_runtime",
                    ),
                )
                .type_params(::alloc::vec::Vec::new())
                .docs(&["A reason for placing a freeze on funds."])
                .variant(::scale_info::build::Variants::new())
        }
    }
};
impl core::fmt::Debug for RuntimeFreezeReason {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            _ => Ok(()),
        }
    }
}
/// A reason for placing a hold on funds.
pub enum RuntimeHoldReason {
    #[codec(index = 54u8)]
    NftFractionalization(pallet_nft_fractionalization::HoldReason),
}
#[automatically_derived]
impl ::core::marker::Copy for RuntimeHoldReason {}
#[automatically_derived]
impl ::core::clone::Clone for RuntimeHoldReason {
    #[inline]
    fn clone(&self) -> RuntimeHoldReason {
        let _: ::core::clone::AssertParamIsClone<
            pallet_nft_fractionalization::HoldReason,
        >;
        *self
    }
}
#[automatically_derived]
impl ::core::marker::StructuralEq for RuntimeHoldReason {}
#[automatically_derived]
impl ::core::cmp::Eq for RuntimeHoldReason {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<pallet_nft_fractionalization::HoldReason>;
    }
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for RuntimeHoldReason {}
#[automatically_derived]
impl ::core::cmp::PartialEq for RuntimeHoldReason {
    #[inline]
    fn eq(&self, other: &RuntimeHoldReason) -> bool {
        match (self, other) {
            (
                RuntimeHoldReason::NftFractionalization(__self_0),
                RuntimeHoldReason::NftFractionalization(__arg1_0),
            ) => *__self_0 == *__arg1_0,
        }
    }
}
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Encode for RuntimeHoldReason {
        fn size_hint(&self) -> usize {
            1_usize
                + match *self {
                    RuntimeHoldReason::NftFractionalization(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    _ => 0_usize,
                }
        }
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            match *self {
                RuntimeHoldReason::NftFractionalization(ref aa) => {
                    __codec_dest_edqy.push_byte(54u8 as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                _ => {}
            }
        }
    }
    #[automatically_derived]
    impl ::codec::EncodeLike for RuntimeHoldReason {}
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Decode for RuntimeHoldReason {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            match __codec_input_edqy
                .read_byte()
                .map_err(|e| {
                    e
                        .chain(
                            "Could not decode `RuntimeHoldReason`, failed to read variant byte",
                        )
                })?
            {
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 54u8 as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RuntimeHoldReason::NftFractionalization({
                                let __codec_res_edqy = <pallet_nft_fractionalization::HoldReason as ::codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e
                                                .chain(
                                                    "Could not decode `RuntimeHoldReason::NftFractionalization.0`",
                                                ),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                _ => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Err(
                            <_ as ::core::convert::Into<
                                _,
                            >>::into(
                                "Could not decode `RuntimeHoldReason`, variant doesn't exist",
                            ),
                        )
                    })();
                }
            }
        }
    }
};
const _: () = {
    impl ::codec::MaxEncodedLen for RuntimeHoldReason {
        fn max_encoded_len() -> ::core::primitive::usize {
            0_usize
                .max(
                    0_usize
                        .saturating_add(
                            <pallet_nft_fractionalization::HoldReason>::max_encoded_len(),
                        ),
                )
                .saturating_add(1)
        }
    }
};
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl ::scale_info::TypeInfo for RuntimeHoldReason {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(
                    ::scale_info::Path::new(
                        "RuntimeHoldReason",
                        "asset_hub_kusama_runtime",
                    ),
                )
                .type_params(::alloc::vec::Vec::new())
                .docs(&["A reason for placing a hold on funds."])
                .variant(
                    ::scale_info::build::Variants::new()
                        .variant(
                            "NftFractionalization",
                            |v| {
                                v
                                    .index(54u8 as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| {
                                                f
                                                    .ty::<pallet_nft_fractionalization::HoldReason>()
                                                    .type_name("pallet_nft_fractionalization::HoldReason")
                                            }),
                                    )
                            },
                        ),
                )
        }
    }
};
impl core::fmt::Debug for RuntimeHoldReason {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            Self::NftFractionalization(ref a0) => {
                fmt.debug_tuple("RuntimeHoldReason::NftFractionalization")
                    .field(a0)
                    .finish()
            }
            _ => Ok(()),
        }
    }
}
impl From<pallet_nft_fractionalization::HoldReason> for RuntimeHoldReason {
    fn from(hr: pallet_nft_fractionalization::HoldReason) -> Self {
        RuntimeHoldReason::NftFractionalization(hr)
    }
}
/// An identifier for each lock placed on funds.
pub enum RuntimeLockId {}
#[automatically_derived]
impl ::core::marker::Copy for RuntimeLockId {}
#[automatically_derived]
impl ::core::clone::Clone for RuntimeLockId {
    #[inline]
    fn clone(&self) -> RuntimeLockId {
        *self
    }
}
#[automatically_derived]
impl ::core::marker::StructuralEq for RuntimeLockId {}
#[automatically_derived]
impl ::core::cmp::Eq for RuntimeLockId {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {}
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for RuntimeLockId {}
#[automatically_derived]
impl ::core::cmp::PartialEq for RuntimeLockId {
    #[inline]
    fn eq(&self, other: &RuntimeLockId) -> bool {
        match *self {}
    }
}
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Encode for RuntimeLockId {}
    #[automatically_derived]
    impl ::codec::EncodeLike for RuntimeLockId {}
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Decode for RuntimeLockId {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            match __codec_input_edqy
                .read_byte()
                .map_err(|e| {
                    e
                        .chain(
                            "Could not decode `RuntimeLockId`, failed to read variant byte",
                        )
                })?
            {
                _ => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Err(
                            <_ as ::core::convert::Into<
                                _,
                            >>::into(
                                "Could not decode `RuntimeLockId`, variant doesn't exist",
                            ),
                        )
                    })();
                }
            }
        }
    }
};
const _: () = {
    impl ::codec::MaxEncodedLen for RuntimeLockId {
        fn max_encoded_len() -> ::core::primitive::usize {
            0_usize.saturating_add(1)
        }
    }
};
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl ::scale_info::TypeInfo for RuntimeLockId {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(
                    ::scale_info::Path::new("RuntimeLockId", "asset_hub_kusama_runtime"),
                )
                .type_params(::alloc::vec::Vec::new())
                .docs(&["An identifier for each lock placed on funds."])
                .variant(::scale_info::build::Variants::new())
        }
    }
};
impl core::fmt::Debug for RuntimeLockId {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            _ => Ok(()),
        }
    }
}
/// A reason for slashing funds.
pub enum RuntimeSlashReason {}
#[automatically_derived]
impl ::core::marker::Copy for RuntimeSlashReason {}
#[automatically_derived]
impl ::core::clone::Clone for RuntimeSlashReason {
    #[inline]
    fn clone(&self) -> RuntimeSlashReason {
        *self
    }
}
#[automatically_derived]
impl ::core::marker::StructuralEq for RuntimeSlashReason {}
#[automatically_derived]
impl ::core::cmp::Eq for RuntimeSlashReason {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {}
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for RuntimeSlashReason {}
#[automatically_derived]
impl ::core::cmp::PartialEq for RuntimeSlashReason {
    #[inline]
    fn eq(&self, other: &RuntimeSlashReason) -> bool {
        match *self {}
    }
}
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Encode for RuntimeSlashReason {}
    #[automatically_derived]
    impl ::codec::EncodeLike for RuntimeSlashReason {}
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Decode for RuntimeSlashReason {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            match __codec_input_edqy
                .read_byte()
                .map_err(|e| {
                    e
                        .chain(
                            "Could not decode `RuntimeSlashReason`, failed to read variant byte",
                        )
                })?
            {
                _ => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Err(
                            <_ as ::core::convert::Into<
                                _,
                            >>::into(
                                "Could not decode `RuntimeSlashReason`, variant doesn't exist",
                            ),
                        )
                    })();
                }
            }
        }
    }
};
const _: () = {
    impl ::codec::MaxEncodedLen for RuntimeSlashReason {
        fn max_encoded_len() -> ::core::primitive::usize {
            0_usize.saturating_add(1)
        }
    }
};
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl ::scale_info::TypeInfo for RuntimeSlashReason {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(
                    ::scale_info::Path::new(
                        "RuntimeSlashReason",
                        "asset_hub_kusama_runtime",
                    ),
                )
                .type_params(::alloc::vec::Vec::new())
                .docs(&["A reason for slashing funds."])
                .variant(::scale_info::build::Variants::new())
        }
    }
};
impl core::fmt::Debug for RuntimeSlashReason {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            _ => Ok(()),
        }
    }
}
const _: () = if !(<frame_system::Error<
    Runtime,
> as ::frame_support::traits::PalletError>::MAX_ENCODED_SIZE
    <= ::frame_support::MAX_MODULE_ERROR_ENCODED_SIZE)
{
    {
        ::core::panicking::panic_fmt(
            format_args!(
                "The maximum encoded size of the error type in the `System` pallet exceeds `MAX_MODULE_ERROR_ENCODED_SIZE`"
            ),
        );
    }
};
const _: () = if !(<cumulus_pallet_parachain_system::Error<
    Runtime,
> as ::frame_support::traits::PalletError>::MAX_ENCODED_SIZE
    <= ::frame_support::MAX_MODULE_ERROR_ENCODED_SIZE)
{
    {
        ::core::panicking::panic_fmt(
            format_args!(
                "The maximum encoded size of the error type in the `ParachainSystem` pallet exceeds `MAX_MODULE_ERROR_ENCODED_SIZE`"
            ),
        );
    }
};
const _: () = if !(<pallet_balances::Error<
    Runtime,
> as ::frame_support::traits::PalletError>::MAX_ENCODED_SIZE
    <= ::frame_support::MAX_MODULE_ERROR_ENCODED_SIZE)
{
    {
        ::core::panicking::panic_fmt(
            format_args!(
                "The maximum encoded size of the error type in the `Balances` pallet exceeds `MAX_MODULE_ERROR_ENCODED_SIZE`"
            ),
        );
    }
};
const _: () = if !(<pallet_collator_selection::Error<
    Runtime,
> as ::frame_support::traits::PalletError>::MAX_ENCODED_SIZE
    <= ::frame_support::MAX_MODULE_ERROR_ENCODED_SIZE)
{
    {
        ::core::panicking::panic_fmt(
            format_args!(
                "The maximum encoded size of the error type in the `CollatorSelection` pallet exceeds `MAX_MODULE_ERROR_ENCODED_SIZE`"
            ),
        );
    }
};
const _: () = if !(<pallet_session::Error<
    Runtime,
> as ::frame_support::traits::PalletError>::MAX_ENCODED_SIZE
    <= ::frame_support::MAX_MODULE_ERROR_ENCODED_SIZE)
{
    {
        ::core::panicking::panic_fmt(
            format_args!(
                "The maximum encoded size of the error type in the `Session` pallet exceeds `MAX_MODULE_ERROR_ENCODED_SIZE`"
            ),
        );
    }
};
const _: () = if !(<cumulus_pallet_xcmp_queue::Error<
    Runtime,
> as ::frame_support::traits::PalletError>::MAX_ENCODED_SIZE
    <= ::frame_support::MAX_MODULE_ERROR_ENCODED_SIZE)
{
    {
        ::core::panicking::panic_fmt(
            format_args!(
                "The maximum encoded size of the error type in the `XcmpQueue` pallet exceeds `MAX_MODULE_ERROR_ENCODED_SIZE`"
            ),
        );
    }
};
const _: () = if !(<pallet_xcm::Error<
    Runtime,
> as ::frame_support::traits::PalletError>::MAX_ENCODED_SIZE
    <= ::frame_support::MAX_MODULE_ERROR_ENCODED_SIZE)
{
    {
        ::core::panicking::panic_fmt(
            format_args!(
                "The maximum encoded size of the error type in the `PolkadotXcm` pallet exceeds `MAX_MODULE_ERROR_ENCODED_SIZE`"
            ),
        );
    }
};
const _: () = if !(<cumulus_pallet_xcm::Error<
    Runtime,
> as ::frame_support::traits::PalletError>::MAX_ENCODED_SIZE
    <= ::frame_support::MAX_MODULE_ERROR_ENCODED_SIZE)
{
    {
        ::core::panicking::panic_fmt(
            format_args!(
                "The maximum encoded size of the error type in the `CumulusXcm` pallet exceeds `MAX_MODULE_ERROR_ENCODED_SIZE`"
            ),
        );
    }
};
const _: () = if !(<cumulus_pallet_dmp_queue::Error<
    Runtime,
> as ::frame_support::traits::PalletError>::MAX_ENCODED_SIZE
    <= ::frame_support::MAX_MODULE_ERROR_ENCODED_SIZE)
{
    {
        ::core::panicking::panic_fmt(
            format_args!(
                "The maximum encoded size of the error type in the `DmpQueue` pallet exceeds `MAX_MODULE_ERROR_ENCODED_SIZE`"
            ),
        );
    }
};
const _: () = if !(<pallet_utility::Error<
    Runtime,
> as ::frame_support::traits::PalletError>::MAX_ENCODED_SIZE
    <= ::frame_support::MAX_MODULE_ERROR_ENCODED_SIZE)
{
    {
        ::core::panicking::panic_fmt(
            format_args!(
                "The maximum encoded size of the error type in the `Utility` pallet exceeds `MAX_MODULE_ERROR_ENCODED_SIZE`"
            ),
        );
    }
};
const _: () = if !(<pallet_multisig::Error<
    Runtime,
> as ::frame_support::traits::PalletError>::MAX_ENCODED_SIZE
    <= ::frame_support::MAX_MODULE_ERROR_ENCODED_SIZE)
{
    {
        ::core::panicking::panic_fmt(
            format_args!(
                "The maximum encoded size of the error type in the `Multisig` pallet exceeds `MAX_MODULE_ERROR_ENCODED_SIZE`"
            ),
        );
    }
};
const _: () = if !(<pallet_proxy::Error<
    Runtime,
> as ::frame_support::traits::PalletError>::MAX_ENCODED_SIZE
    <= ::frame_support::MAX_MODULE_ERROR_ENCODED_SIZE)
{
    {
        ::core::panicking::panic_fmt(
            format_args!(
                "The maximum encoded size of the error type in the `Proxy` pallet exceeds `MAX_MODULE_ERROR_ENCODED_SIZE`"
            ),
        );
    }
};
const _: () = if !(<pallet_assets::Error<
    Runtime,
> as ::frame_support::traits::PalletError>::MAX_ENCODED_SIZE
    <= ::frame_support::MAX_MODULE_ERROR_ENCODED_SIZE)
{
    {
        ::core::panicking::panic_fmt(
            format_args!(
                "The maximum encoded size of the error type in the `Assets` pallet exceeds `MAX_MODULE_ERROR_ENCODED_SIZE`"
            ),
        );
    }
};
const _: () = if !(<pallet_uniques::Error<
    Runtime,
> as ::frame_support::traits::PalletError>::MAX_ENCODED_SIZE
    <= ::frame_support::MAX_MODULE_ERROR_ENCODED_SIZE)
{
    {
        ::core::panicking::panic_fmt(
            format_args!(
                "The maximum encoded size of the error type in the `Uniques` pallet exceeds `MAX_MODULE_ERROR_ENCODED_SIZE`"
            ),
        );
    }
};
const _: () = if !(<pallet_nfts::Error<
    Runtime,
> as ::frame_support::traits::PalletError>::MAX_ENCODED_SIZE
    <= ::frame_support::MAX_MODULE_ERROR_ENCODED_SIZE)
{
    {
        ::core::panicking::panic_fmt(
            format_args!(
                "The maximum encoded size of the error type in the `Nfts` pallet exceeds `MAX_MODULE_ERROR_ENCODED_SIZE`"
            ),
        );
    }
};
const _: () = if !(<pallet_assets::Error<
    Runtime,
> as ::frame_support::traits::PalletError>::MAX_ENCODED_SIZE
    <= ::frame_support::MAX_MODULE_ERROR_ENCODED_SIZE)
{
    {
        ::core::panicking::panic_fmt(
            format_args!(
                "The maximum encoded size of the error type in the `ForeignAssets` pallet exceeds `MAX_MODULE_ERROR_ENCODED_SIZE`"
            ),
        );
    }
};
const _: () = if !(<pallet_nft_fractionalization::Error<
    Runtime,
> as ::frame_support::traits::PalletError>::MAX_ENCODED_SIZE
    <= ::frame_support::MAX_MODULE_ERROR_ENCODED_SIZE)
{
    {
        ::core::panicking::panic_fmt(
            format_args!(
                "The maximum encoded size of the error type in the `NftFractionalization` pallet exceeds `MAX_MODULE_ERROR_ENCODED_SIZE`"
            ),
        );
    }
};
const _: () = if !(<pallet_assets::Error<
    Runtime,
> as ::frame_support::traits::PalletError>::MAX_ENCODED_SIZE
    <= ::frame_support::MAX_MODULE_ERROR_ENCODED_SIZE)
{
    {
        ::core::panicking::panic_fmt(
            format_args!(
                "The maximum encoded size of the error type in the `PoolAssets` pallet exceeds `MAX_MODULE_ERROR_ENCODED_SIZE`"
            ),
        );
    }
};
const _: () = if !(<pallet_asset_conversion::Error<
    Runtime,
> as ::frame_support::traits::PalletError>::MAX_ENCODED_SIZE
    <= ::frame_support::MAX_MODULE_ERROR_ENCODED_SIZE)
{
    {
        ::core::panicking::panic_fmt(
            format_args!(
                "The maximum encoded size of the error type in the `AssetConversion` pallet exceeds `MAX_MODULE_ERROR_ENCODED_SIZE`"
            ),
        );
    }
};
const _: () = if !(<pallet_state_trie_migration::Error<
    Runtime,
> as ::frame_support::traits::PalletError>::MAX_ENCODED_SIZE
    <= ::frame_support::MAX_MODULE_ERROR_ENCODED_SIZE)
{
    {
        ::core::panicking::panic_fmt(
            format_args!(
                "The maximum encoded size of the error type in the `StateTrieMigration` pallet exceeds `MAX_MODULE_ERROR_ENCODED_SIZE`"
            ),
        );
    }
};
/// The address format for describing accounts.
pub type Address = sp_runtime::MultiAddress<AccountId, ()>;
/// Block type as expected by this runtime.
pub type Block = generic::Block<Header, UncheckedExtrinsic>;
/// A Block signed with a Justification
pub type SignedBlock = generic::SignedBlock<Block>;
/// BlockId type as expected by this runtime.
pub type BlockId = generic::BlockId<Block>;
/// The SignedExtension to the basic transaction logic.
pub type SignedExtra = (
    frame_system::CheckNonZeroSender<Runtime>,
    frame_system::CheckSpecVersion<Runtime>,
    frame_system::CheckTxVersion<Runtime>,
    frame_system::CheckGenesis<Runtime>,
    frame_system::CheckEra<Runtime>,
    frame_system::CheckNonce<Runtime>,
    frame_system::CheckWeight<Runtime>,
    pallet_asset_conversion_tx_payment::ChargeAssetTxPayment<Runtime>,
);
/// Unchecked extrinsic type as expected by this runtime.
pub type UncheckedExtrinsic = generic::UncheckedExtrinsic<
    Address,
    RuntimeCall,
    Signature,
    SignedExtra,
>;
/// Migrations to apply on runtime upgrade.
pub type Migrations = (pallet_collator_selection::migration::v1::MigrateToV1<Runtime>,);
/// Executive: handles dispatch to the various modules.
pub type Executive = frame_executive::Executive<
    Runtime,
    Block,
    frame_system::ChainContext<Runtime>,
    Runtime,
    AllPalletsWithSystem,
    Migrations,
>;
pub struct RuntimeApi {}
/// Implements all runtime apis for the client side.
pub struct RuntimeApiImpl<Block: sp_api::BlockT, C: sp_api::CallApiAt<Block> + 'static> {
    call: &'static C,
    transaction_depth: std::cell::RefCell<u16>,
    changes: std::cell::RefCell<sp_api::OverlayedChanges<sp_api::HashingFor<Block>>>,
    recorder: std::option::Option<sp_api::ProofRecorder<Block>>,
    call_context: sp_api::CallContext,
    extensions: std::cell::RefCell<sp_api::Extensions>,
    extensions_generated_for: std::cell::RefCell<std::option::Option<Block::Hash>>,
}
impl<Block: sp_api::BlockT, C: sp_api::CallApiAt<Block>> sp_api::ApiExt<Block>
for RuntimeApiImpl<Block, C> {
    fn execute_in_transaction<F: FnOnce(&Self) -> sp_api::TransactionOutcome<R>, R>(
        &self,
        call: F,
    ) -> R
    where
        Self: Sized,
    {
        self.start_transaction();
        *std::cell::RefCell::borrow_mut(&self.transaction_depth) += 1;
        let res = call(self);
        std::cell::RefCell::borrow_mut(&self.transaction_depth)
            .checked_sub(1)
            .expect("Transactions are opened and closed together; qed");
        self.commit_or_rollback_transaction(
            match res {
                sp_api::TransactionOutcome::Commit(_) => true,
                _ => false,
            },
        );
        res.into_inner()
    }
    fn has_api<A: sp_api::RuntimeApiInfo + ?Sized>(
        &self,
        at: <Block as sp_api::BlockT>::Hash,
    ) -> std::result::Result<bool, sp_api::ApiError>
    where
        Self: Sized,
    {
        sp_api::CallApiAt::<Block>::runtime_version_at(self.call, at)
            .map(|v| sp_api::RuntimeVersion::has_api_with(
                &v,
                &A::ID,
                |v| v == A::VERSION,
            ))
    }
    fn has_api_with<A: sp_api::RuntimeApiInfo + ?Sized, P: Fn(u32) -> bool>(
        &self,
        at: <Block as sp_api::BlockT>::Hash,
        pred: P,
    ) -> std::result::Result<bool, sp_api::ApiError>
    where
        Self: Sized,
    {
        sp_api::CallApiAt::<Block>::runtime_version_at(self.call, at)
            .map(|v| sp_api::RuntimeVersion::has_api_with(&v, &A::ID, pred))
    }
    fn api_version<A: sp_api::RuntimeApiInfo + ?Sized>(
        &self,
        at: <Block as sp_api::BlockT>::Hash,
    ) -> std::result::Result<Option<u32>, sp_api::ApiError>
    where
        Self: Sized,
    {
        sp_api::CallApiAt::<Block>::runtime_version_at(self.call, at)
            .map(|v| sp_api::RuntimeVersion::api_version(&v, &A::ID))
    }
    fn record_proof(&mut self) {
        self.recorder = std::option::Option::Some(std::default::Default::default());
    }
    fn proof_recorder(&self) -> std::option::Option<sp_api::ProofRecorder<Block>> {
        std::clone::Clone::clone(&self.recorder)
    }
    fn extract_proof(&mut self) -> std::option::Option<sp_api::StorageProof> {
        let recorder = std::option::Option::take(&mut self.recorder);
        std::option::Option::map(
            recorder,
            |recorder| { sp_api::ProofRecorder::<Block>::drain_storage_proof(recorder) },
        )
    }
    fn into_storage_changes<B: sp_api::StateBackend<sp_api::HashingFor<Block>>>(
        &self,
        backend: &B,
        parent_hash: Block::Hash,
    ) -> core::result::Result<sp_api::StorageChanges<Block>, String>
    where
        Self: Sized,
    {
        let state_version = sp_api::CallApiAt::<
            Block,
        >::runtime_version_at(self.call, std::clone::Clone::clone(&parent_hash))
            .map(|v| sp_api::RuntimeVersion::state_version(&v))
            .map_err(|e| {
                let res = ::alloc::fmt::format(
                    format_args!("Failed to get state version: {0}", e),
                );
                res
            })?;
        sp_api::OverlayedChanges::drain_storage_changes(
            &mut std::cell::RefCell::borrow_mut(&self.changes),
            backend,
            state_version,
        )
    }
    fn set_call_context(&mut self, call_context: sp_api::CallContext) {
        self.call_context = call_context;
    }
    fn register_extension<E: sp_api::Extension>(&mut self, extension: E) {
        std::cell::RefCell::borrow_mut(&self.extensions).register(extension);
    }
}
impl<Block: sp_api::BlockT, C> sp_api::ConstructRuntimeApi<Block, C> for RuntimeApi
where
    C: sp_api::CallApiAt<Block> + 'static,
{
    type RuntimeApi = RuntimeApiImpl<Block, C>;
    fn construct_runtime_api<'a>(call: &'a C) -> sp_api::ApiRef<'a, Self::RuntimeApi> {
        RuntimeApiImpl {
            call: unsafe { std::mem::transmute(call) },
            transaction_depth: 0.into(),
            changes: std::default::Default::default(),
            recorder: std::default::Default::default(),
            call_context: sp_api::CallContext::Offchain,
            extensions: std::default::Default::default(),
            extensions_generated_for: std::default::Default::default(),
        }
            .into()
    }
}
impl<Block: sp_api::BlockT, C: sp_api::CallApiAt<Block>> RuntimeApiImpl<Block, C> {
    fn commit_or_rollback_transaction(&self, commit: bool) {
        let proof = "\
					We only close a transaction when we opened one ourself.
					Other parts of the runtime that make use of transactions (state-machine)
					also balance their transactions. The runtime cannot close client initiated
					transactions; qed";
        let res = if commit {
            let res = if let Some(recorder) = &self.recorder {
                sp_api::ProofRecorder::<Block>::commit_transaction(&recorder)
            } else {
                Ok(())
            };
            let res2 = sp_api::OverlayedChanges::commit_transaction(
                &mut std::cell::RefCell::borrow_mut(&self.changes),
            );
            std::result::Result::and(res, std::result::Result::map_err(res2, drop))
        } else {
            let res = if let Some(recorder) = &self.recorder {
                sp_api::ProofRecorder::<Block>::rollback_transaction(&recorder)
            } else {
                Ok(())
            };
            let res2 = sp_api::OverlayedChanges::rollback_transaction(
                &mut std::cell::RefCell::borrow_mut(&self.changes),
            );
            std::result::Result::and(res, std::result::Result::map_err(res2, drop))
        };
        std::result::Result::expect(res, proof);
    }
    fn start_transaction(&self) {
        sp_api::OverlayedChanges::start_transaction(
            &mut std::cell::RefCell::borrow_mut(&self.changes),
        );
        if let Some(recorder) = &self.recorder {
            sp_api::ProofRecorder::<Block>::start_transaction(&recorder);
        }
    }
}
impl sp_consensus_aura::runtime_decl_for_aura_api::AuraApi<Block, AuraId> for Runtime {
    fn slot_duration() -> sp_consensus_aura::SlotDuration {
        sp_consensus_aura::SlotDuration::from_millis(Aura::slot_duration())
    }
    fn authorities() -> Vec<AuraId> {
        Aura::authorities().into_inner()
    }
}
impl sp_api::runtime_decl_for_core::Core<Block> for Runtime {
    fn version() -> RuntimeVersion {
        VERSION
    }
    fn execute_block(block: Block) {
        Executive::execute_block(block)
    }
    fn initialize_block(header: &<Block as BlockT>::Header) {
        Executive::initialize_block(header)
    }
}
impl sp_api::runtime_decl_for_metadata::Metadata<Block> for Runtime {
    fn metadata() -> OpaqueMetadata {
        OpaqueMetadata::new(Runtime::metadata().into())
    }
    fn metadata_at_version(version: u32) -> Option<OpaqueMetadata> {
        Runtime::metadata_at_version(version)
    }
    fn metadata_versions() -> sp_std::vec::Vec<u32> {
        Runtime::metadata_versions()
    }
}
impl sp_block_builder::runtime_decl_for_block_builder::BlockBuilder<Block> for Runtime {
    fn apply_extrinsic(extrinsic: <Block as BlockT>::Extrinsic) -> ApplyExtrinsicResult {
        Executive::apply_extrinsic(extrinsic)
    }
    fn finalize_block() -> <Block as BlockT>::Header {
        Executive::finalize_block()
    }
    fn inherent_extrinsics(
        data: sp_inherents::InherentData,
    ) -> Vec<<Block as BlockT>::Extrinsic> {
        data.create_extrinsics()
    }
    fn check_inherents(
        block: Block,
        data: sp_inherents::InherentData,
    ) -> sp_inherents::CheckInherentsResult {
        data.check_extrinsics(&block)
    }
}
impl sp_transaction_pool::runtime_api::runtime_decl_for_tagged_transaction_queue::TaggedTransactionQueue<
    Block,
> for Runtime {
    fn validate_transaction(
        source: TransactionSource,
        tx: <Block as BlockT>::Extrinsic,
        block_hash: <Block as BlockT>::Hash,
    ) -> TransactionValidity {
        Executive::validate_transaction(source, tx, block_hash)
    }
}
impl sp_offchain::runtime_decl_for_offchain_worker_api::OffchainWorkerApi<Block>
for Runtime {
    fn offchain_worker(header: &<Block as BlockT>::Header) {
        Executive::offchain_worker(header)
    }
}
impl sp_session::runtime_decl_for_session_keys::SessionKeys<Block> for Runtime {
    fn generate_session_keys(seed: Option<Vec<u8>>) -> Vec<u8> {
        SessionKeys::generate(seed)
    }
    fn decode_session_keys(encoded: Vec<u8>) -> Option<Vec<(Vec<u8>, KeyTypeId)>> {
        SessionKeys::decode_into_raw_public_keys(&encoded)
    }
}
impl frame_system_rpc_runtime_api::runtime_decl_for_account_nonce_api::AccountNonceApi<
    Block,
    AccountId,
    Nonce,
> for Runtime {
    fn account_nonce(account: AccountId) -> Nonce {
        System::account_nonce(account)
    }
}
impl pallet_asset_conversion::runtime_decl_for_asset_conversion_api::AssetConversionApi<
    Block,
    Balance,
    u128,
    Box<MultiLocation>,
> for Runtime {
    fn quote_price_exact_tokens_for_tokens(
        asset1: Box<MultiLocation>,
        asset2: Box<MultiLocation>,
        amount: u128,
        include_fee: bool,
    ) -> Option<Balance> {
        AssetConversion::quote_price_exact_tokens_for_tokens(
            asset1,
            asset2,
            amount,
            include_fee,
        )
    }
    fn quote_price_tokens_for_exact_tokens(
        asset1: Box<MultiLocation>,
        asset2: Box<MultiLocation>,
        amount: u128,
        include_fee: bool,
    ) -> Option<Balance> {
        AssetConversion::quote_price_tokens_for_exact_tokens(
            asset1,
            asset2,
            amount,
            include_fee,
        )
    }
    fn get_reserves(
        asset1: Box<MultiLocation>,
        asset2: Box<MultiLocation>,
    ) -> Option<(Balance, Balance)> {
        AssetConversion::get_reserves(&asset1, &asset2).ok()
    }
}
impl pallet_transaction_payment_rpc_runtime_api::runtime_decl_for_transaction_payment_api::TransactionPaymentApi<
    Block,
    Balance,
> for Runtime {
    fn query_info(
        uxt: <Block as BlockT>::Extrinsic,
        len: u32,
    ) -> pallet_transaction_payment_rpc_runtime_api::RuntimeDispatchInfo<Balance> {
        TransactionPayment::query_info(uxt, len)
    }
    fn query_fee_details(
        uxt: <Block as BlockT>::Extrinsic,
        len: u32,
    ) -> pallet_transaction_payment::FeeDetails<Balance> {
        TransactionPayment::query_fee_details(uxt, len)
    }
    fn query_weight_to_fee(weight: Weight) -> Balance {
        TransactionPayment::weight_to_fee(weight)
    }
    fn query_length_to_fee(length: u32) -> Balance {
        TransactionPayment::length_to_fee(length)
    }
}
impl pallet_transaction_payment_rpc_runtime_api::runtime_decl_for_transaction_payment_call_api::TransactionPaymentCallApi<
    Block,
    Balance,
    RuntimeCall,
> for Runtime {
    fn query_call_info(
        call: RuntimeCall,
        len: u32,
    ) -> pallet_transaction_payment::RuntimeDispatchInfo<Balance> {
        TransactionPayment::query_call_info(call, len)
    }
    fn query_call_fee_details(
        call: RuntimeCall,
        len: u32,
    ) -> pallet_transaction_payment::FeeDetails<Balance> {
        TransactionPayment::query_call_fee_details(call, len)
    }
    fn query_weight_to_fee(weight: Weight) -> Balance {
        TransactionPayment::weight_to_fee(weight)
    }
    fn query_length_to_fee(length: u32) -> Balance {
        TransactionPayment::length_to_fee(length)
    }
}
impl assets_common::runtime_api::runtime_decl_for_fungibles_api::FungiblesApi<
    Block,
    AccountId,
> for Runtime {
    fn query_account_balances(
        account: AccountId,
    ) -> Result<
        xcm::VersionedMultiAssets,
        assets_common::runtime_api::FungiblesAccessError,
    > {
        use assets_common::fungible_conversion::{convert, convert_balance};
        Ok(
            [
                {
                    let balance = Balances::free_balance(account.clone());
                    if balance > 0 {
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                convert_balance::<KsmLocation, Balance>(balance)?,
                            ]),
                        )
                    } else {
                        ::alloc::vec::Vec::new()
                    }
                },
                convert::<
                    _,
                    _,
                    _,
                    _,
                    TrustBackedAssetsConvertedConcreteId,
                >(
                    Assets::account_balances(account.clone())
                        .iter()
                        .filter(|(_, balance)| balance > &0),
                )?,
                convert::<
                    _,
                    _,
                    _,
                    _,
                    ForeignAssetsConvertedConcreteId,
                >(
                    ForeignAssets::account_balances(account.clone())
                        .iter()
                        .filter(|(_, balance)| balance > &0),
                )?,
                convert::<
                    _,
                    _,
                    _,
                    _,
                    PoolAssetsConvertedConcreteId,
                >(
                    PoolAssets::account_balances(account)
                        .iter()
                        .filter(|(_, balance)| balance > &0),
                )?,
            ]
                .concat()
                .into(),
        )
    }
}
impl cumulus_primitives_core::runtime_decl_for_collect_collation_info::CollectCollationInfo<
    Block,
> for Runtime {
    fn collect_collation_info(
        header: &<Block as BlockT>::Header,
    ) -> cumulus_primitives_core::CollationInfo {
        ParachainSystem::collect_collation_info(header)
    }
}
impl sp_genesis_builder::runtime_decl_for_genesis_builder::GenesisBuilder<Block>
for Runtime {
    fn create_default_config() -> Vec<u8> {
        create_default_config::<RuntimeGenesisConfig>()
    }
    fn build_config(config: Vec<u8>) -> sp_genesis_builder::Result {
        build_config::<RuntimeGenesisConfig>(config)
    }
}
impl<
    __SrApiBlock__: sp_api::BlockT + std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    RuntimeApiImplCall: sp_api::CallApiAt<__SrApiBlock__> + 'static,
> sp_consensus_aura::AuraApi<__SrApiBlock__, AuraId>
for RuntimeApiImpl<__SrApiBlock__, RuntimeApiImplCall>
where
    RuntimeApiImplCall::StateBackend: sp_api::StateBackend<
        sp_api::HashingFor<__SrApiBlock__>,
    >,
    &'static RuntimeApiImplCall: Send,
    sp_consensus_aura::SlotDuration: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Vec<AuraId>: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    __SrApiBlock__::Header: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
{
    fn __runtime_api_internal_call_api_at(
        &self,
        at: <__SrApiBlock__ as sp_api::BlockT>::Hash,
        params: std::vec::Vec<u8>,
        fn_name: &dyn Fn(sp_api::RuntimeVersion) -> &'static str,
    ) -> std::result::Result<std::vec::Vec<u8>, sp_api::ApiError> {
        let transaction_depth = *std::cell::RefCell::borrow(&self.transaction_depth);
        if transaction_depth == 0 {
            self.start_transaction();
        }
        let res = (|| {
            let version = sp_api::CallApiAt::<
                __SrApiBlock__,
            >::runtime_version_at(self.call, at)?;
            match &mut *std::cell::RefCell::borrow_mut(&self.extensions_generated_for) {
                Some(generated_for) => {
                    if *generated_for != at {
                        return std::result::Result::Err(
                            sp_api::ApiError::UsingSameInstanceForDifferentBlocks,
                        );
                    }
                }
                generated_for @ None => {
                    sp_api::CallApiAt::<
                        __SrApiBlock__,
                    >::initialize_extensions(
                        self.call,
                        at,
                        &mut std::cell::RefCell::borrow_mut(&self.extensions),
                    )?;
                    *generated_for = Some(at);
                }
            }
            let params = sp_api::CallApiAtParams {
                at,
                function: (*fn_name)(version),
                arguments: params,
                overlayed_changes: &self.changes,
                call_context: self.call_context,
                recorder: &self.recorder,
                extensions: &self.extensions,
            };
            sp_api::CallApiAt::<__SrApiBlock__>::call_api_at(self.call, params)
        })();
        if transaction_depth == 0 {
            self.commit_or_rollback_transaction(std::result::Result::is_ok(&res));
        }
        res
    }
}
impl<
    __SrApiBlock__: sp_api::BlockT + std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    RuntimeApiImplCall: sp_api::CallApiAt<__SrApiBlock__> + 'static,
> sp_api::Core<__SrApiBlock__> for RuntimeApiImpl<__SrApiBlock__, RuntimeApiImplCall>
where
    RuntimeApiImplCall::StateBackend: sp_api::StateBackend<
        sp_api::HashingFor<__SrApiBlock__>,
    >,
    &'static RuntimeApiImplCall: Send,
    RuntimeVersion: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    __SrApiBlock__: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    <__SrApiBlock__ as BlockT>::Header: std::panic::UnwindSafe
        + std::panic::RefUnwindSafe,
    __SrApiBlock__::Header: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
{
    fn __runtime_api_internal_call_api_at(
        &self,
        at: <__SrApiBlock__ as sp_api::BlockT>::Hash,
        params: std::vec::Vec<u8>,
        fn_name: &dyn Fn(sp_api::RuntimeVersion) -> &'static str,
    ) -> std::result::Result<std::vec::Vec<u8>, sp_api::ApiError> {
        let transaction_depth = *std::cell::RefCell::borrow(&self.transaction_depth);
        if transaction_depth == 0 {
            self.start_transaction();
        }
        let res = (|| {
            let version = sp_api::CallApiAt::<
                __SrApiBlock__,
            >::runtime_version_at(self.call, at)?;
            match &mut *std::cell::RefCell::borrow_mut(&self.extensions_generated_for) {
                Some(generated_for) => {
                    if *generated_for != at {
                        return std::result::Result::Err(
                            sp_api::ApiError::UsingSameInstanceForDifferentBlocks,
                        );
                    }
                }
                generated_for @ None => {
                    sp_api::CallApiAt::<
                        __SrApiBlock__,
                    >::initialize_extensions(
                        self.call,
                        at,
                        &mut std::cell::RefCell::borrow_mut(&self.extensions),
                    )?;
                    *generated_for = Some(at);
                }
            }
            let params = sp_api::CallApiAtParams {
                at,
                function: (*fn_name)(version),
                arguments: params,
                overlayed_changes: &self.changes,
                call_context: self.call_context,
                recorder: &self.recorder,
                extensions: &self.extensions,
            };
            sp_api::CallApiAt::<__SrApiBlock__>::call_api_at(self.call, params)
        })();
        if transaction_depth == 0 {
            self.commit_or_rollback_transaction(std::result::Result::is_ok(&res));
        }
        res
    }
}
impl<
    __SrApiBlock__: sp_api::BlockT + std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    RuntimeApiImplCall: sp_api::CallApiAt<__SrApiBlock__> + 'static,
> sp_api::Metadata<__SrApiBlock__> for RuntimeApiImpl<__SrApiBlock__, RuntimeApiImplCall>
where
    RuntimeApiImplCall::StateBackend: sp_api::StateBackend<
        sp_api::HashingFor<__SrApiBlock__>,
    >,
    &'static RuntimeApiImplCall: Send,
    OpaqueMetadata: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    u32: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Option<OpaqueMetadata>: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    sp_std::vec::Vec<u32>: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    __SrApiBlock__::Header: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
{
    fn __runtime_api_internal_call_api_at(
        &self,
        at: <__SrApiBlock__ as sp_api::BlockT>::Hash,
        params: std::vec::Vec<u8>,
        fn_name: &dyn Fn(sp_api::RuntimeVersion) -> &'static str,
    ) -> std::result::Result<std::vec::Vec<u8>, sp_api::ApiError> {
        let transaction_depth = *std::cell::RefCell::borrow(&self.transaction_depth);
        if transaction_depth == 0 {
            self.start_transaction();
        }
        let res = (|| {
            let version = sp_api::CallApiAt::<
                __SrApiBlock__,
            >::runtime_version_at(self.call, at)?;
            match &mut *std::cell::RefCell::borrow_mut(&self.extensions_generated_for) {
                Some(generated_for) => {
                    if *generated_for != at {
                        return std::result::Result::Err(
                            sp_api::ApiError::UsingSameInstanceForDifferentBlocks,
                        );
                    }
                }
                generated_for @ None => {
                    sp_api::CallApiAt::<
                        __SrApiBlock__,
                    >::initialize_extensions(
                        self.call,
                        at,
                        &mut std::cell::RefCell::borrow_mut(&self.extensions),
                    )?;
                    *generated_for = Some(at);
                }
            }
            let params = sp_api::CallApiAtParams {
                at,
                function: (*fn_name)(version),
                arguments: params,
                overlayed_changes: &self.changes,
                call_context: self.call_context,
                recorder: &self.recorder,
                extensions: &self.extensions,
            };
            sp_api::CallApiAt::<__SrApiBlock__>::call_api_at(self.call, params)
        })();
        if transaction_depth == 0 {
            self.commit_or_rollback_transaction(std::result::Result::is_ok(&res));
        }
        res
    }
}
impl<
    __SrApiBlock__: sp_api::BlockT + std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    RuntimeApiImplCall: sp_api::CallApiAt<__SrApiBlock__> + 'static,
> sp_block_builder::BlockBuilder<__SrApiBlock__>
for RuntimeApiImpl<__SrApiBlock__, RuntimeApiImplCall>
where
    RuntimeApiImplCall::StateBackend: sp_api::StateBackend<
        sp_api::HashingFor<__SrApiBlock__>,
    >,
    &'static RuntimeApiImplCall: Send,
    <__SrApiBlock__ as BlockT>::Extrinsic: std::panic::UnwindSafe
        + std::panic::RefUnwindSafe,
    ApplyExtrinsicResult: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    <__SrApiBlock__ as BlockT>::Header: std::panic::UnwindSafe
        + std::panic::RefUnwindSafe,
    sp_inherents::InherentData: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Vec<
        <__SrApiBlock__ as BlockT>::Extrinsic,
    >: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    __SrApiBlock__: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    sp_inherents::InherentData: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    sp_inherents::CheckInherentsResult: std::panic::UnwindSafe
        + std::panic::RefUnwindSafe,
    __SrApiBlock__::Header: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
{
    fn __runtime_api_internal_call_api_at(
        &self,
        at: <__SrApiBlock__ as sp_api::BlockT>::Hash,
        params: std::vec::Vec<u8>,
        fn_name: &dyn Fn(sp_api::RuntimeVersion) -> &'static str,
    ) -> std::result::Result<std::vec::Vec<u8>, sp_api::ApiError> {
        let transaction_depth = *std::cell::RefCell::borrow(&self.transaction_depth);
        if transaction_depth == 0 {
            self.start_transaction();
        }
        let res = (|| {
            let version = sp_api::CallApiAt::<
                __SrApiBlock__,
            >::runtime_version_at(self.call, at)?;
            match &mut *std::cell::RefCell::borrow_mut(&self.extensions_generated_for) {
                Some(generated_for) => {
                    if *generated_for != at {
                        return std::result::Result::Err(
                            sp_api::ApiError::UsingSameInstanceForDifferentBlocks,
                        );
                    }
                }
                generated_for @ None => {
                    sp_api::CallApiAt::<
                        __SrApiBlock__,
                    >::initialize_extensions(
                        self.call,
                        at,
                        &mut std::cell::RefCell::borrow_mut(&self.extensions),
                    )?;
                    *generated_for = Some(at);
                }
            }
            let params = sp_api::CallApiAtParams {
                at,
                function: (*fn_name)(version),
                arguments: params,
                overlayed_changes: &self.changes,
                call_context: self.call_context,
                recorder: &self.recorder,
                extensions: &self.extensions,
            };
            sp_api::CallApiAt::<__SrApiBlock__>::call_api_at(self.call, params)
        })();
        if transaction_depth == 0 {
            self.commit_or_rollback_transaction(std::result::Result::is_ok(&res));
        }
        res
    }
}
impl<
    __SrApiBlock__: sp_api::BlockT + std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    RuntimeApiImplCall: sp_api::CallApiAt<__SrApiBlock__> + 'static,
> sp_transaction_pool::runtime_api::TaggedTransactionQueue<__SrApiBlock__>
for RuntimeApiImpl<__SrApiBlock__, RuntimeApiImplCall>
where
    RuntimeApiImplCall::StateBackend: sp_api::StateBackend<
        sp_api::HashingFor<__SrApiBlock__>,
    >,
    &'static RuntimeApiImplCall: Send,
    TransactionSource: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    <__SrApiBlock__ as BlockT>::Extrinsic: std::panic::UnwindSafe
        + std::panic::RefUnwindSafe,
    <__SrApiBlock__ as BlockT>::Hash: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    TransactionValidity: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    __SrApiBlock__::Header: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
{
    fn __runtime_api_internal_call_api_at(
        &self,
        at: <__SrApiBlock__ as sp_api::BlockT>::Hash,
        params: std::vec::Vec<u8>,
        fn_name: &dyn Fn(sp_api::RuntimeVersion) -> &'static str,
    ) -> std::result::Result<std::vec::Vec<u8>, sp_api::ApiError> {
        let transaction_depth = *std::cell::RefCell::borrow(&self.transaction_depth);
        if transaction_depth == 0 {
            self.start_transaction();
        }
        let res = (|| {
            let version = sp_api::CallApiAt::<
                __SrApiBlock__,
            >::runtime_version_at(self.call, at)?;
            match &mut *std::cell::RefCell::borrow_mut(&self.extensions_generated_for) {
                Some(generated_for) => {
                    if *generated_for != at {
                        return std::result::Result::Err(
                            sp_api::ApiError::UsingSameInstanceForDifferentBlocks,
                        );
                    }
                }
                generated_for @ None => {
                    sp_api::CallApiAt::<
                        __SrApiBlock__,
                    >::initialize_extensions(
                        self.call,
                        at,
                        &mut std::cell::RefCell::borrow_mut(&self.extensions),
                    )?;
                    *generated_for = Some(at);
                }
            }
            let params = sp_api::CallApiAtParams {
                at,
                function: (*fn_name)(version),
                arguments: params,
                overlayed_changes: &self.changes,
                call_context: self.call_context,
                recorder: &self.recorder,
                extensions: &self.extensions,
            };
            sp_api::CallApiAt::<__SrApiBlock__>::call_api_at(self.call, params)
        })();
        if transaction_depth == 0 {
            self.commit_or_rollback_transaction(std::result::Result::is_ok(&res));
        }
        res
    }
}
impl<
    __SrApiBlock__: sp_api::BlockT + std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    RuntimeApiImplCall: sp_api::CallApiAt<__SrApiBlock__> + 'static,
> sp_offchain::OffchainWorkerApi<__SrApiBlock__>
for RuntimeApiImpl<__SrApiBlock__, RuntimeApiImplCall>
where
    RuntimeApiImplCall::StateBackend: sp_api::StateBackend<
        sp_api::HashingFor<__SrApiBlock__>,
    >,
    &'static RuntimeApiImplCall: Send,
    <__SrApiBlock__ as BlockT>::Header: std::panic::UnwindSafe
        + std::panic::RefUnwindSafe,
    __SrApiBlock__::Header: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
{
    fn __runtime_api_internal_call_api_at(
        &self,
        at: <__SrApiBlock__ as sp_api::BlockT>::Hash,
        params: std::vec::Vec<u8>,
        fn_name: &dyn Fn(sp_api::RuntimeVersion) -> &'static str,
    ) -> std::result::Result<std::vec::Vec<u8>, sp_api::ApiError> {
        let transaction_depth = *std::cell::RefCell::borrow(&self.transaction_depth);
        if transaction_depth == 0 {
            self.start_transaction();
        }
        let res = (|| {
            let version = sp_api::CallApiAt::<
                __SrApiBlock__,
            >::runtime_version_at(self.call, at)?;
            match &mut *std::cell::RefCell::borrow_mut(&self.extensions_generated_for) {
                Some(generated_for) => {
                    if *generated_for != at {
                        return std::result::Result::Err(
                            sp_api::ApiError::UsingSameInstanceForDifferentBlocks,
                        );
                    }
                }
                generated_for @ None => {
                    sp_api::CallApiAt::<
                        __SrApiBlock__,
                    >::initialize_extensions(
                        self.call,
                        at,
                        &mut std::cell::RefCell::borrow_mut(&self.extensions),
                    )?;
                    *generated_for = Some(at);
                }
            }
            let params = sp_api::CallApiAtParams {
                at,
                function: (*fn_name)(version),
                arguments: params,
                overlayed_changes: &self.changes,
                call_context: self.call_context,
                recorder: &self.recorder,
                extensions: &self.extensions,
            };
            sp_api::CallApiAt::<__SrApiBlock__>::call_api_at(self.call, params)
        })();
        if transaction_depth == 0 {
            self.commit_or_rollback_transaction(std::result::Result::is_ok(&res));
        }
        res
    }
}
impl<
    __SrApiBlock__: sp_api::BlockT + std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    RuntimeApiImplCall: sp_api::CallApiAt<__SrApiBlock__> + 'static,
> sp_session::SessionKeys<__SrApiBlock__>
for RuntimeApiImpl<__SrApiBlock__, RuntimeApiImplCall>
where
    RuntimeApiImplCall::StateBackend: sp_api::StateBackend<
        sp_api::HashingFor<__SrApiBlock__>,
    >,
    &'static RuntimeApiImplCall: Send,
    Option<Vec<u8>>: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Vec<u8>: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Vec<u8>: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Option<
        Vec<(Vec<u8>, KeyTypeId)>,
    >: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    __SrApiBlock__::Header: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
{
    fn __runtime_api_internal_call_api_at(
        &self,
        at: <__SrApiBlock__ as sp_api::BlockT>::Hash,
        params: std::vec::Vec<u8>,
        fn_name: &dyn Fn(sp_api::RuntimeVersion) -> &'static str,
    ) -> std::result::Result<std::vec::Vec<u8>, sp_api::ApiError> {
        let transaction_depth = *std::cell::RefCell::borrow(&self.transaction_depth);
        if transaction_depth == 0 {
            self.start_transaction();
        }
        let res = (|| {
            let version = sp_api::CallApiAt::<
                __SrApiBlock__,
            >::runtime_version_at(self.call, at)?;
            match &mut *std::cell::RefCell::borrow_mut(&self.extensions_generated_for) {
                Some(generated_for) => {
                    if *generated_for != at {
                        return std::result::Result::Err(
                            sp_api::ApiError::UsingSameInstanceForDifferentBlocks,
                        );
                    }
                }
                generated_for @ None => {
                    sp_api::CallApiAt::<
                        __SrApiBlock__,
                    >::initialize_extensions(
                        self.call,
                        at,
                        &mut std::cell::RefCell::borrow_mut(&self.extensions),
                    )?;
                    *generated_for = Some(at);
                }
            }
            let params = sp_api::CallApiAtParams {
                at,
                function: (*fn_name)(version),
                arguments: params,
                overlayed_changes: &self.changes,
                call_context: self.call_context,
                recorder: &self.recorder,
                extensions: &self.extensions,
            };
            sp_api::CallApiAt::<__SrApiBlock__>::call_api_at(self.call, params)
        })();
        if transaction_depth == 0 {
            self.commit_or_rollback_transaction(std::result::Result::is_ok(&res));
        }
        res
    }
}
impl<
    __SrApiBlock__: sp_api::BlockT + std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    RuntimeApiImplCall: sp_api::CallApiAt<__SrApiBlock__> + 'static,
> frame_system_rpc_runtime_api::AccountNonceApi<__SrApiBlock__, AccountId, Nonce>
for RuntimeApiImpl<__SrApiBlock__, RuntimeApiImplCall>
where
    RuntimeApiImplCall::StateBackend: sp_api::StateBackend<
        sp_api::HashingFor<__SrApiBlock__>,
    >,
    &'static RuntimeApiImplCall: Send,
    AccountId: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Nonce: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    __SrApiBlock__::Header: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
{
    fn __runtime_api_internal_call_api_at(
        &self,
        at: <__SrApiBlock__ as sp_api::BlockT>::Hash,
        params: std::vec::Vec<u8>,
        fn_name: &dyn Fn(sp_api::RuntimeVersion) -> &'static str,
    ) -> std::result::Result<std::vec::Vec<u8>, sp_api::ApiError> {
        let transaction_depth = *std::cell::RefCell::borrow(&self.transaction_depth);
        if transaction_depth == 0 {
            self.start_transaction();
        }
        let res = (|| {
            let version = sp_api::CallApiAt::<
                __SrApiBlock__,
            >::runtime_version_at(self.call, at)?;
            match &mut *std::cell::RefCell::borrow_mut(&self.extensions_generated_for) {
                Some(generated_for) => {
                    if *generated_for != at {
                        return std::result::Result::Err(
                            sp_api::ApiError::UsingSameInstanceForDifferentBlocks,
                        );
                    }
                }
                generated_for @ None => {
                    sp_api::CallApiAt::<
                        __SrApiBlock__,
                    >::initialize_extensions(
                        self.call,
                        at,
                        &mut std::cell::RefCell::borrow_mut(&self.extensions),
                    )?;
                    *generated_for = Some(at);
                }
            }
            let params = sp_api::CallApiAtParams {
                at,
                function: (*fn_name)(version),
                arguments: params,
                overlayed_changes: &self.changes,
                call_context: self.call_context,
                recorder: &self.recorder,
                extensions: &self.extensions,
            };
            sp_api::CallApiAt::<__SrApiBlock__>::call_api_at(self.call, params)
        })();
        if transaction_depth == 0 {
            self.commit_or_rollback_transaction(std::result::Result::is_ok(&res));
        }
        res
    }
}
impl<
    __SrApiBlock__: sp_api::BlockT + std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    RuntimeApiImplCall: sp_api::CallApiAt<__SrApiBlock__> + 'static,
> pallet_asset_conversion::AssetConversionApi<
    __SrApiBlock__,
    Balance,
    u128,
    Box<MultiLocation>,
> for RuntimeApiImpl<__SrApiBlock__, RuntimeApiImplCall>
where
    RuntimeApiImplCall::StateBackend: sp_api::StateBackend<
        sp_api::HashingFor<__SrApiBlock__>,
    >,
    &'static RuntimeApiImplCall: Send,
    Box<MultiLocation>: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Box<MultiLocation>: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    u128: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    bool: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Option<Balance>: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Box<MultiLocation>: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Box<MultiLocation>: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    u128: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    bool: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Option<Balance>: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Box<MultiLocation>: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Box<MultiLocation>: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Option<(Balance, Balance)>: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    __SrApiBlock__::Header: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
{
    fn __runtime_api_internal_call_api_at(
        &self,
        at: <__SrApiBlock__ as sp_api::BlockT>::Hash,
        params: std::vec::Vec<u8>,
        fn_name: &dyn Fn(sp_api::RuntimeVersion) -> &'static str,
    ) -> std::result::Result<std::vec::Vec<u8>, sp_api::ApiError> {
        let transaction_depth = *std::cell::RefCell::borrow(&self.transaction_depth);
        if transaction_depth == 0 {
            self.start_transaction();
        }
        let res = (|| {
            let version = sp_api::CallApiAt::<
                __SrApiBlock__,
            >::runtime_version_at(self.call, at)?;
            match &mut *std::cell::RefCell::borrow_mut(&self.extensions_generated_for) {
                Some(generated_for) => {
                    if *generated_for != at {
                        return std::result::Result::Err(
                            sp_api::ApiError::UsingSameInstanceForDifferentBlocks,
                        );
                    }
                }
                generated_for @ None => {
                    sp_api::CallApiAt::<
                        __SrApiBlock__,
                    >::initialize_extensions(
                        self.call,
                        at,
                        &mut std::cell::RefCell::borrow_mut(&self.extensions),
                    )?;
                    *generated_for = Some(at);
                }
            }
            let params = sp_api::CallApiAtParams {
                at,
                function: (*fn_name)(version),
                arguments: params,
                overlayed_changes: &self.changes,
                call_context: self.call_context,
                recorder: &self.recorder,
                extensions: &self.extensions,
            };
            sp_api::CallApiAt::<__SrApiBlock__>::call_api_at(self.call, params)
        })();
        if transaction_depth == 0 {
            self.commit_or_rollback_transaction(std::result::Result::is_ok(&res));
        }
        res
    }
}
impl<
    __SrApiBlock__: sp_api::BlockT + std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    RuntimeApiImplCall: sp_api::CallApiAt<__SrApiBlock__> + 'static,
> pallet_transaction_payment_rpc_runtime_api::TransactionPaymentApi<
    __SrApiBlock__,
    Balance,
> for RuntimeApiImpl<__SrApiBlock__, RuntimeApiImplCall>
where
    RuntimeApiImplCall::StateBackend: sp_api::StateBackend<
        sp_api::HashingFor<__SrApiBlock__>,
    >,
    &'static RuntimeApiImplCall: Send,
    <__SrApiBlock__ as BlockT>::Extrinsic: std::panic::UnwindSafe
        + std::panic::RefUnwindSafe,
    u32: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    pallet_transaction_payment_rpc_runtime_api::RuntimeDispatchInfo<
        Balance,
    >: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    <__SrApiBlock__ as BlockT>::Extrinsic: std::panic::UnwindSafe
        + std::panic::RefUnwindSafe,
    u32: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    pallet_transaction_payment::FeeDetails<
        Balance,
    >: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Weight: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Balance: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    u32: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Balance: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    __SrApiBlock__::Header: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
{
    fn __runtime_api_internal_call_api_at(
        &self,
        at: <__SrApiBlock__ as sp_api::BlockT>::Hash,
        params: std::vec::Vec<u8>,
        fn_name: &dyn Fn(sp_api::RuntimeVersion) -> &'static str,
    ) -> std::result::Result<std::vec::Vec<u8>, sp_api::ApiError> {
        let transaction_depth = *std::cell::RefCell::borrow(&self.transaction_depth);
        if transaction_depth == 0 {
            self.start_transaction();
        }
        let res = (|| {
            let version = sp_api::CallApiAt::<
                __SrApiBlock__,
            >::runtime_version_at(self.call, at)?;
            match &mut *std::cell::RefCell::borrow_mut(&self.extensions_generated_for) {
                Some(generated_for) => {
                    if *generated_for != at {
                        return std::result::Result::Err(
                            sp_api::ApiError::UsingSameInstanceForDifferentBlocks,
                        );
                    }
                }
                generated_for @ None => {
                    sp_api::CallApiAt::<
                        __SrApiBlock__,
                    >::initialize_extensions(
                        self.call,
                        at,
                        &mut std::cell::RefCell::borrow_mut(&self.extensions),
                    )?;
                    *generated_for = Some(at);
                }
            }
            let params = sp_api::CallApiAtParams {
                at,
                function: (*fn_name)(version),
                arguments: params,
                overlayed_changes: &self.changes,
                call_context: self.call_context,
                recorder: &self.recorder,
                extensions: &self.extensions,
            };
            sp_api::CallApiAt::<__SrApiBlock__>::call_api_at(self.call, params)
        })();
        if transaction_depth == 0 {
            self.commit_or_rollback_transaction(std::result::Result::is_ok(&res));
        }
        res
    }
}
impl<
    __SrApiBlock__: sp_api::BlockT + std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    RuntimeApiImplCall: sp_api::CallApiAt<__SrApiBlock__> + 'static,
> pallet_transaction_payment_rpc_runtime_api::TransactionPaymentCallApi<
    __SrApiBlock__,
    Balance,
    RuntimeCall,
> for RuntimeApiImpl<__SrApiBlock__, RuntimeApiImplCall>
where
    RuntimeApiImplCall::StateBackend: sp_api::StateBackend<
        sp_api::HashingFor<__SrApiBlock__>,
    >,
    &'static RuntimeApiImplCall: Send,
    RuntimeCall: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    u32: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    pallet_transaction_payment::RuntimeDispatchInfo<
        Balance,
    >: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    RuntimeCall: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    u32: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    pallet_transaction_payment::FeeDetails<
        Balance,
    >: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Weight: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Balance: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    u32: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Balance: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    __SrApiBlock__::Header: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
{
    fn __runtime_api_internal_call_api_at(
        &self,
        at: <__SrApiBlock__ as sp_api::BlockT>::Hash,
        params: std::vec::Vec<u8>,
        fn_name: &dyn Fn(sp_api::RuntimeVersion) -> &'static str,
    ) -> std::result::Result<std::vec::Vec<u8>, sp_api::ApiError> {
        let transaction_depth = *std::cell::RefCell::borrow(&self.transaction_depth);
        if transaction_depth == 0 {
            self.start_transaction();
        }
        let res = (|| {
            let version = sp_api::CallApiAt::<
                __SrApiBlock__,
            >::runtime_version_at(self.call, at)?;
            match &mut *std::cell::RefCell::borrow_mut(&self.extensions_generated_for) {
                Some(generated_for) => {
                    if *generated_for != at {
                        return std::result::Result::Err(
                            sp_api::ApiError::UsingSameInstanceForDifferentBlocks,
                        );
                    }
                }
                generated_for @ None => {
                    sp_api::CallApiAt::<
                        __SrApiBlock__,
                    >::initialize_extensions(
                        self.call,
                        at,
                        &mut std::cell::RefCell::borrow_mut(&self.extensions),
                    )?;
                    *generated_for = Some(at);
                }
            }
            let params = sp_api::CallApiAtParams {
                at,
                function: (*fn_name)(version),
                arguments: params,
                overlayed_changes: &self.changes,
                call_context: self.call_context,
                recorder: &self.recorder,
                extensions: &self.extensions,
            };
            sp_api::CallApiAt::<__SrApiBlock__>::call_api_at(self.call, params)
        })();
        if transaction_depth == 0 {
            self.commit_or_rollback_transaction(std::result::Result::is_ok(&res));
        }
        res
    }
}
impl<
    __SrApiBlock__: sp_api::BlockT + std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    RuntimeApiImplCall: sp_api::CallApiAt<__SrApiBlock__> + 'static,
> assets_common::runtime_api::FungiblesApi<__SrApiBlock__, AccountId>
for RuntimeApiImpl<__SrApiBlock__, RuntimeApiImplCall>
where
    RuntimeApiImplCall::StateBackend: sp_api::StateBackend<
        sp_api::HashingFor<__SrApiBlock__>,
    >,
    &'static RuntimeApiImplCall: Send,
    AccountId: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Result<
        xcm::VersionedMultiAssets,
        assets_common::runtime_api::FungiblesAccessError,
    >: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    __SrApiBlock__::Header: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
{
    fn __runtime_api_internal_call_api_at(
        &self,
        at: <__SrApiBlock__ as sp_api::BlockT>::Hash,
        params: std::vec::Vec<u8>,
        fn_name: &dyn Fn(sp_api::RuntimeVersion) -> &'static str,
    ) -> std::result::Result<std::vec::Vec<u8>, sp_api::ApiError> {
        let transaction_depth = *std::cell::RefCell::borrow(&self.transaction_depth);
        if transaction_depth == 0 {
            self.start_transaction();
        }
        let res = (|| {
            let version = sp_api::CallApiAt::<
                __SrApiBlock__,
            >::runtime_version_at(self.call, at)?;
            match &mut *std::cell::RefCell::borrow_mut(&self.extensions_generated_for) {
                Some(generated_for) => {
                    if *generated_for != at {
                        return std::result::Result::Err(
                            sp_api::ApiError::UsingSameInstanceForDifferentBlocks,
                        );
                    }
                }
                generated_for @ None => {
                    sp_api::CallApiAt::<
                        __SrApiBlock__,
                    >::initialize_extensions(
                        self.call,
                        at,
                        &mut std::cell::RefCell::borrow_mut(&self.extensions),
                    )?;
                    *generated_for = Some(at);
                }
            }
            let params = sp_api::CallApiAtParams {
                at,
                function: (*fn_name)(version),
                arguments: params,
                overlayed_changes: &self.changes,
                call_context: self.call_context,
                recorder: &self.recorder,
                extensions: &self.extensions,
            };
            sp_api::CallApiAt::<__SrApiBlock__>::call_api_at(self.call, params)
        })();
        if transaction_depth == 0 {
            self.commit_or_rollback_transaction(std::result::Result::is_ok(&res));
        }
        res
    }
}
impl<
    __SrApiBlock__: sp_api::BlockT + std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    RuntimeApiImplCall: sp_api::CallApiAt<__SrApiBlock__> + 'static,
> cumulus_primitives_core::CollectCollationInfo<__SrApiBlock__>
for RuntimeApiImpl<__SrApiBlock__, RuntimeApiImplCall>
where
    RuntimeApiImplCall::StateBackend: sp_api::StateBackend<
        sp_api::HashingFor<__SrApiBlock__>,
    >,
    &'static RuntimeApiImplCall: Send,
    <__SrApiBlock__ as BlockT>::Header: std::panic::UnwindSafe
        + std::panic::RefUnwindSafe,
    cumulus_primitives_core::CollationInfo: std::panic::UnwindSafe
        + std::panic::RefUnwindSafe,
    __SrApiBlock__::Header: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
{
    fn __runtime_api_internal_call_api_at(
        &self,
        at: <__SrApiBlock__ as sp_api::BlockT>::Hash,
        params: std::vec::Vec<u8>,
        fn_name: &dyn Fn(sp_api::RuntimeVersion) -> &'static str,
    ) -> std::result::Result<std::vec::Vec<u8>, sp_api::ApiError> {
        let transaction_depth = *std::cell::RefCell::borrow(&self.transaction_depth);
        if transaction_depth == 0 {
            self.start_transaction();
        }
        let res = (|| {
            let version = sp_api::CallApiAt::<
                __SrApiBlock__,
            >::runtime_version_at(self.call, at)?;
            match &mut *std::cell::RefCell::borrow_mut(&self.extensions_generated_for) {
                Some(generated_for) => {
                    if *generated_for != at {
                        return std::result::Result::Err(
                            sp_api::ApiError::UsingSameInstanceForDifferentBlocks,
                        );
                    }
                }
                generated_for @ None => {
                    sp_api::CallApiAt::<
                        __SrApiBlock__,
                    >::initialize_extensions(
                        self.call,
                        at,
                        &mut std::cell::RefCell::borrow_mut(&self.extensions),
                    )?;
                    *generated_for = Some(at);
                }
            }
            let params = sp_api::CallApiAtParams {
                at,
                function: (*fn_name)(version),
                arguments: params,
                overlayed_changes: &self.changes,
                call_context: self.call_context,
                recorder: &self.recorder,
                extensions: &self.extensions,
            };
            sp_api::CallApiAt::<__SrApiBlock__>::call_api_at(self.call, params)
        })();
        if transaction_depth == 0 {
            self.commit_or_rollback_transaction(std::result::Result::is_ok(&res));
        }
        res
    }
}
impl<
    __SrApiBlock__: sp_api::BlockT + std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    RuntimeApiImplCall: sp_api::CallApiAt<__SrApiBlock__> + 'static,
> sp_genesis_builder::GenesisBuilder<__SrApiBlock__>
for RuntimeApiImpl<__SrApiBlock__, RuntimeApiImplCall>
where
    RuntimeApiImplCall::StateBackend: sp_api::StateBackend<
        sp_api::HashingFor<__SrApiBlock__>,
    >,
    &'static RuntimeApiImplCall: Send,
    Vec<u8>: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    Vec<u8>: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    sp_genesis_builder::Result: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
    __SrApiBlock__::Header: std::panic::UnwindSafe + std::panic::RefUnwindSafe,
{
    fn __runtime_api_internal_call_api_at(
        &self,
        at: <__SrApiBlock__ as sp_api::BlockT>::Hash,
        params: std::vec::Vec<u8>,
        fn_name: &dyn Fn(sp_api::RuntimeVersion) -> &'static str,
    ) -> std::result::Result<std::vec::Vec<u8>, sp_api::ApiError> {
        let transaction_depth = *std::cell::RefCell::borrow(&self.transaction_depth);
        if transaction_depth == 0 {
            self.start_transaction();
        }
        let res = (|| {
            let version = sp_api::CallApiAt::<
                __SrApiBlock__,
            >::runtime_version_at(self.call, at)?;
            match &mut *std::cell::RefCell::borrow_mut(&self.extensions_generated_for) {
                Some(generated_for) => {
                    if *generated_for != at {
                        return std::result::Result::Err(
                            sp_api::ApiError::UsingSameInstanceForDifferentBlocks,
                        );
                    }
                }
                generated_for @ None => {
                    sp_api::CallApiAt::<
                        __SrApiBlock__,
                    >::initialize_extensions(
                        self.call,
                        at,
                        &mut std::cell::RefCell::borrow_mut(&self.extensions),
                    )?;
                    *generated_for = Some(at);
                }
            }
            let params = sp_api::CallApiAtParams {
                at,
                function: (*fn_name)(version),
                arguments: params,
                overlayed_changes: &self.changes,
                call_context: self.call_context,
                recorder: &self.recorder,
                extensions: &self.extensions,
            };
            sp_api::CallApiAt::<__SrApiBlock__>::call_api_at(self.call, params)
        })();
        if transaction_depth == 0 {
            self.commit_or_rollback_transaction(std::result::Result::is_ok(&res));
        }
        res
    }
}
const RUNTIME_API_VERSIONS: sp_api::ApisVec = ::sp_version::sp_std::borrow::Cow::Borrowed(
    &[
        (
            sp_consensus_aura::runtime_decl_for_aura_api::ID,
            sp_consensus_aura::runtime_decl_for_aura_api::VERSION,
        ),
        (sp_api::runtime_decl_for_core::ID, sp_api::runtime_decl_for_core::VERSION),
        (
            sp_api::runtime_decl_for_metadata::ID,
            sp_api::runtime_decl_for_metadata::VERSION,
        ),
        (
            sp_block_builder::runtime_decl_for_block_builder::ID,
            sp_block_builder::runtime_decl_for_block_builder::VERSION,
        ),
        (
            sp_transaction_pool::runtime_api::runtime_decl_for_tagged_transaction_queue::ID,
            sp_transaction_pool::runtime_api::runtime_decl_for_tagged_transaction_queue::VERSION,
        ),
        (
            sp_offchain::runtime_decl_for_offchain_worker_api::ID,
            sp_offchain::runtime_decl_for_offchain_worker_api::VERSION,
        ),
        (
            sp_session::runtime_decl_for_session_keys::ID,
            sp_session::runtime_decl_for_session_keys::VERSION,
        ),
        (
            frame_system_rpc_runtime_api::runtime_decl_for_account_nonce_api::ID,
            frame_system_rpc_runtime_api::runtime_decl_for_account_nonce_api::VERSION,
        ),
        (
            pallet_asset_conversion::runtime_decl_for_asset_conversion_api::ID,
            pallet_asset_conversion::runtime_decl_for_asset_conversion_api::VERSION,
        ),
        (
            pallet_transaction_payment_rpc_runtime_api::runtime_decl_for_transaction_payment_api::ID,
            pallet_transaction_payment_rpc_runtime_api::runtime_decl_for_transaction_payment_api::VERSION,
        ),
        (
            pallet_transaction_payment_rpc_runtime_api::runtime_decl_for_transaction_payment_call_api::ID,
            pallet_transaction_payment_rpc_runtime_api::runtime_decl_for_transaction_payment_call_api::VERSION,
        ),
        (
            assets_common::runtime_api::runtime_decl_for_fungibles_api::ID,
            assets_common::runtime_api::runtime_decl_for_fungibles_api::VERSION,
        ),
        (
            cumulus_primitives_core::runtime_decl_for_collect_collation_info::ID,
            cumulus_primitives_core::runtime_decl_for_collect_collation_info::VERSION,
        ),
        (
            sp_genesis_builder::runtime_decl_for_genesis_builder::ID,
            sp_genesis_builder::runtime_decl_for_genesis_builder::VERSION,
        ),
    ],
);
#[doc(hidden)]
trait InternalImplRuntimeApis {
    #[inline(always)]
    fn runtime_metadata(
        &self,
    ) -> sp_api::vec::Vec<sp_api::metadata_ir::RuntimeApiMetadataIR> {
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                sp_consensus_aura::runtime_decl_for_aura_api::runtime_metadata::<
                    Block,
                    AuraId,
                >(),
                sp_api::runtime_decl_for_core::runtime_metadata::<Block>(),
                sp_api::runtime_decl_for_metadata::runtime_metadata::<Block>(),
                sp_block_builder::runtime_decl_for_block_builder::runtime_metadata::<
                    Block,
                >(),
                sp_transaction_pool::runtime_api::runtime_decl_for_tagged_transaction_queue::runtime_metadata::<
                    Block,
                >(),
                sp_offchain::runtime_decl_for_offchain_worker_api::runtime_metadata::<
                    Block,
                >(),
                sp_session::runtime_decl_for_session_keys::runtime_metadata::<Block>(),
                frame_system_rpc_runtime_api::runtime_decl_for_account_nonce_api::runtime_metadata::<
                    Block,
                    AccountId,
                    Nonce,
                >(),
                pallet_asset_conversion::runtime_decl_for_asset_conversion_api::runtime_metadata::<
                    Block,
                    Balance,
                    u128,
                    Box<MultiLocation>,
                >(),
                pallet_transaction_payment_rpc_runtime_api::runtime_decl_for_transaction_payment_api::runtime_metadata::<
                    Block,
                    Balance,
                >(),
                pallet_transaction_payment_rpc_runtime_api::runtime_decl_for_transaction_payment_call_api::runtime_metadata::<
                    Block,
                    Balance,
                    RuntimeCall,
                >(),
                assets_common::runtime_api::runtime_decl_for_fungibles_api::runtime_metadata::<
                    Block,
                    AccountId,
                >(),
                cumulus_primitives_core::runtime_decl_for_collect_collation_info::runtime_metadata::<
                    Block,
                >(),
                sp_genesis_builder::runtime_decl_for_genesis_builder::runtime_metadata::<
                    Block,
                >(),
            ]),
        )
    }
}
#[doc(hidden)]
impl InternalImplRuntimeApis for Runtime {}
pub mod api {
    use super::*;
    pub fn dispatch(method: &str, mut _sp_api_input_data_: &[u8]) -> Option<Vec<u8>> {
        match method {
            "AuraApi_slot_duration" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            if !_sp_api_input_data_.is_empty() {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: expected no parameters, but input buffer is not empty.",
                                            "slot_duration"
                                        ),
                                    );
                                };
                            }
                            #[allow(deprecated)]
                            <Runtime as sp_consensus_aura::runtime_decl_for_aura_api::AuraApi<
                                Block,
                                AuraId,
                            >>::slot_duration()
                        },
                    ),
                )
            }
            "AuraApi_authorities" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            if !_sp_api_input_data_.is_empty() {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: expected no parameters, but input buffer is not empty.",
                                            "authorities"
                                        ),
                                    );
                                };
                            }
                            #[allow(deprecated)]
                            <Runtime as sp_consensus_aura::runtime_decl_for_aura_api::AuraApi<
                                Block,
                                AuraId,
                            >>::authorities()
                        },
                    ),
                )
            }
            "Core_version" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            if !_sp_api_input_data_.is_empty() {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: expected no parameters, but input buffer is not empty.",
                                            "version"
                                        ),
                                    );
                                };
                            }
                            #[allow(deprecated)]
                            <Runtime as sp_api::runtime_decl_for_core::Core<
                                Block,
                            >>::version()
                        },
                    ),
                )
            }
            "Core_execute_block" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let block: Block = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}", "execute_block", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as sp_api::runtime_decl_for_core::Core<
                                Block,
                            >>::execute_block(block)
                        },
                    ),
                )
            }
            "Core_initialize_block" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let header: <Block as BlockT>::Header = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}", "initialize_block", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as sp_api::runtime_decl_for_core::Core<
                                Block,
                            >>::initialize_block(&header)
                        },
                    ),
                )
            }
            "Metadata_metadata" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            if !_sp_api_input_data_.is_empty() {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: expected no parameters, but input buffer is not empty.",
                                            "metadata"
                                        ),
                                    );
                                };
                            }
                            #[allow(deprecated)]
                            <Runtime as sp_api::runtime_decl_for_metadata::Metadata<
                                Block,
                            >>::metadata()
                        },
                    ),
                )
            }
            "Metadata_metadata_at_version" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let version: u32 = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}",
                                            "metadata_at_version", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as sp_api::runtime_decl_for_metadata::Metadata<
                                Block,
                            >>::metadata_at_version(version)
                        },
                    ),
                )
            }
            "Metadata_metadata_versions" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            if !_sp_api_input_data_.is_empty() {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: expected no parameters, but input buffer is not empty.",
                                            "metadata_versions"
                                        ),
                                    );
                                };
                            }
                            #[allow(deprecated)]
                            <Runtime as sp_api::runtime_decl_for_metadata::Metadata<
                                Block,
                            >>::metadata_versions()
                        },
                    ),
                )
            }
            "BlockBuilder_apply_extrinsic" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let extrinsic: <Block as BlockT>::Extrinsic = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}", "apply_extrinsic", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as sp_block_builder::runtime_decl_for_block_builder::BlockBuilder<
                                Block,
                            >>::apply_extrinsic(extrinsic)
                        },
                    ),
                )
            }
            "BlockBuilder_finalize_block" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            if !_sp_api_input_data_.is_empty() {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: expected no parameters, but input buffer is not empty.",
                                            "finalize_block"
                                        ),
                                    );
                                };
                            }
                            #[allow(deprecated)]
                            <Runtime as sp_block_builder::runtime_decl_for_block_builder::BlockBuilder<
                                Block,
                            >>::finalize_block()
                        },
                    ),
                )
            }
            "BlockBuilder_inherent_extrinsics" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let data: sp_inherents::InherentData = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}",
                                            "inherent_extrinsics", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as sp_block_builder::runtime_decl_for_block_builder::BlockBuilder<
                                Block,
                            >>::inherent_extrinsics(data)
                        },
                    ),
                )
            }
            "BlockBuilder_check_inherents" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let (block, data): (Block, sp_inherents::InherentData) = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}", "check_inherents", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as sp_block_builder::runtime_decl_for_block_builder::BlockBuilder<
                                Block,
                            >>::check_inherents(block, data)
                        },
                    ),
                )
            }
            "TaggedTransactionQueue_validate_transaction" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let (
                                source,
                                tx,
                                block_hash,
                            ): (
                                TransactionSource,
                                <Block as BlockT>::Extrinsic,
                                <Block as BlockT>::Hash,
                            ) = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}",
                                            "validate_transaction", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as sp_transaction_pool::runtime_api::runtime_decl_for_tagged_transaction_queue::TaggedTransactionQueue<
                                Block,
                            >>::validate_transaction(source, tx, block_hash)
                        },
                    ),
                )
            }
            "OffchainWorkerApi_offchain_worker" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let header: <Block as BlockT>::Header = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}", "offchain_worker", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as sp_offchain::runtime_decl_for_offchain_worker_api::OffchainWorkerApi<
                                Block,
                            >>::offchain_worker(&header)
                        },
                    ),
                )
            }
            "SessionKeys_generate_session_keys" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let seed: Option<Vec<u8>> = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}",
                                            "generate_session_keys", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as sp_session::runtime_decl_for_session_keys::SessionKeys<
                                Block,
                            >>::generate_session_keys(seed)
                        },
                    ),
                )
            }
            "SessionKeys_decode_session_keys" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let encoded: Vec<u8> = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}",
                                            "decode_session_keys", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as sp_session::runtime_decl_for_session_keys::SessionKeys<
                                Block,
                            >>::decode_session_keys(encoded)
                        },
                    ),
                )
            }
            "AccountNonceApi_account_nonce" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let account: AccountId = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}", "account_nonce", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as frame_system_rpc_runtime_api::runtime_decl_for_account_nonce_api::AccountNonceApi<
                                Block,
                                AccountId,
                                Nonce,
                            >>::account_nonce(account)
                        },
                    ),
                )
            }
            "AssetConversionApi_quote_price_exact_tokens_for_tokens" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let (
                                asset1,
                                asset2,
                                amount,
                                include_fee,
                            ): (Box<MultiLocation>, Box<MultiLocation>, u128, bool) = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}",
                                            "quote_price_exact_tokens_for_tokens", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as pallet_asset_conversion::runtime_decl_for_asset_conversion_api::AssetConversionApi<
                                Block,
                                Balance,
                                u128,
                                Box<MultiLocation>,
                            >>::quote_price_exact_tokens_for_tokens(
                                asset1,
                                asset2,
                                amount,
                                include_fee,
                            )
                        },
                    ),
                )
            }
            "AssetConversionApi_quote_price_tokens_for_exact_tokens" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let (
                                asset1,
                                asset2,
                                amount,
                                include_fee,
                            ): (Box<MultiLocation>, Box<MultiLocation>, u128, bool) = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}",
                                            "quote_price_tokens_for_exact_tokens", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as pallet_asset_conversion::runtime_decl_for_asset_conversion_api::AssetConversionApi<
                                Block,
                                Balance,
                                u128,
                                Box<MultiLocation>,
                            >>::quote_price_tokens_for_exact_tokens(
                                asset1,
                                asset2,
                                amount,
                                include_fee,
                            )
                        },
                    ),
                )
            }
            "AssetConversionApi_get_reserves" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let (
                                asset1,
                                asset2,
                            ): (Box<MultiLocation>, Box<MultiLocation>) = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}", "get_reserves", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as pallet_asset_conversion::runtime_decl_for_asset_conversion_api::AssetConversionApi<
                                Block,
                                Balance,
                                u128,
                                Box<MultiLocation>,
                            >>::get_reserves(asset1, asset2)
                        },
                    ),
                )
            }
            "TransactionPaymentApi_query_info" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let (uxt, len): (<Block as BlockT>::Extrinsic, u32) = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}", "query_info", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as pallet_transaction_payment_rpc_runtime_api::runtime_decl_for_transaction_payment_api::TransactionPaymentApi<
                                Block,
                                Balance,
                            >>::query_info(uxt, len)
                        },
                    ),
                )
            }
            "TransactionPaymentApi_query_fee_details" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let (uxt, len): (<Block as BlockT>::Extrinsic, u32) = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}", "query_fee_details",
                                            e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as pallet_transaction_payment_rpc_runtime_api::runtime_decl_for_transaction_payment_api::TransactionPaymentApi<
                                Block,
                                Balance,
                            >>::query_fee_details(uxt, len)
                        },
                    ),
                )
            }
            "TransactionPaymentApi_query_weight_to_fee" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let weight: Weight = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}",
                                            "query_weight_to_fee", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as pallet_transaction_payment_rpc_runtime_api::runtime_decl_for_transaction_payment_api::TransactionPaymentApi<
                                Block,
                                Balance,
                            >>::query_weight_to_fee(weight)
                        },
                    ),
                )
            }
            "TransactionPaymentApi_query_length_to_fee" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let length: u32 = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}",
                                            "query_length_to_fee", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as pallet_transaction_payment_rpc_runtime_api::runtime_decl_for_transaction_payment_api::TransactionPaymentApi<
                                Block,
                                Balance,
                            >>::query_length_to_fee(length)
                        },
                    ),
                )
            }
            "TransactionPaymentCallApi_query_call_info" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let (call, len): (RuntimeCall, u32) = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}", "query_call_info", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as pallet_transaction_payment_rpc_runtime_api::runtime_decl_for_transaction_payment_call_api::TransactionPaymentCallApi<
                                Block,
                                Balance,
                                RuntimeCall,
                            >>::query_call_info(call, len)
                        },
                    ),
                )
            }
            "TransactionPaymentCallApi_query_call_fee_details" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let (call, len): (RuntimeCall, u32) = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}",
                                            "query_call_fee_details", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as pallet_transaction_payment_rpc_runtime_api::runtime_decl_for_transaction_payment_call_api::TransactionPaymentCallApi<
                                Block,
                                Balance,
                                RuntimeCall,
                            >>::query_call_fee_details(call, len)
                        },
                    ),
                )
            }
            "TransactionPaymentCallApi_query_weight_to_fee" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let weight: Weight = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}",
                                            "query_weight_to_fee", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as pallet_transaction_payment_rpc_runtime_api::runtime_decl_for_transaction_payment_call_api::TransactionPaymentCallApi<
                                Block,
                                Balance,
                                RuntimeCall,
                            >>::query_weight_to_fee(weight)
                        },
                    ),
                )
            }
            "TransactionPaymentCallApi_query_length_to_fee" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let length: u32 = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}",
                                            "query_length_to_fee", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as pallet_transaction_payment_rpc_runtime_api::runtime_decl_for_transaction_payment_call_api::TransactionPaymentCallApi<
                                Block,
                                Balance,
                                RuntimeCall,
                            >>::query_length_to_fee(length)
                        },
                    ),
                )
            }
            "FungiblesApi_query_account_balances" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let account: AccountId = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}",
                                            "query_account_balances", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as assets_common::runtime_api::runtime_decl_for_fungibles_api::FungiblesApi<
                                Block,
                                AccountId,
                            >>::query_account_balances(account)
                        },
                    ),
                )
            }
            "CollectCollationInfo_collect_collation_info" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let header: <Block as BlockT>::Header = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}",
                                            "collect_collation_info", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as cumulus_primitives_core::runtime_decl_for_collect_collation_info::CollectCollationInfo<
                                Block,
                            >>::collect_collation_info(&header)
                        },
                    ),
                )
            }
            "GenesisBuilder_create_default_config" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            if !_sp_api_input_data_.is_empty() {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: expected no parameters, but input buffer is not empty.",
                                            "create_default_config"
                                        ),
                                    );
                                };
                            }
                            #[allow(deprecated)]
                            <Runtime as sp_genesis_builder::runtime_decl_for_genesis_builder::GenesisBuilder<
                                Block,
                            >>::create_default_config()
                        },
                    ),
                )
            }
            "GenesisBuilder_build_config" => {
                Some(
                    sp_api::Encode::encode(
                        &{
                            let config: Vec<u8> = match sp_api::DecodeLimit::decode_all_with_depth_limit(
                                sp_api::MAX_EXTRINSIC_DEPTH,
                                &mut _sp_api_input_data_,
                            ) {
                                Ok(res) => res,
                                Err(e) => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Bad input data provided to {0}: {1}", "build_config", e
                                        ),
                                    );
                                }
                            };
                            #[allow(deprecated)]
                            <Runtime as sp_genesis_builder::runtime_decl_for_genesis_builder::GenesisBuilder<
                                Block,
                            >>::build_config(config)
                        },
                    ),
                )
            }
            _ => None,
        }
    }
}
